<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>System Design - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-interview">
    <header>
        <div class="container">
            <h1>System Design</h1>
            <p>Master Large-Scale System Architecture & Design</p>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'interview';</script>
    <script src="../menu.js"></script>
    <div class="container">
        <div class="content-with-sidebar">
            <div class="sidebar-toc">
                <div class="toc-header">
                    <h2>üèóÔ∏è System Design Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Overview</a></li>
                        <li><a href="#fundamentals">System Design Fundamentals</a></li>
                        <li><a href="#scalability">Scalability Principles</a></li>
                        <li><a href="#databases">Database Design</a></li>
                        <li><a href="#caching">Caching Strategies</a></li>
                        <li><a href="#load-balancing">Load Balancing</a></li>
                        <li><a href="#microservices">Microservices Architecture</a></li>
                        <li><a href="#messaging">Message Queues & Streaming</a></li>
                        <li><a href="#cdn">Content Delivery Networks</a></li>
                        <li><a href="#security">Security & Authentication</a></li>
                        <li><a href="#monitoring">Monitoring & Observability</a></li>
                        <li><a href="#case-studies">Real-World Case Studies</a></li>
                        <li><a href="#interview-prep">Interview Preparation</a></li>
                    </ul>
                </nav>
            </div>
            <div class="main-content">
                <div class="topic" id="overview">
                    <h2>System Design Mastery üèóÔ∏è</h2>
                    <p><strong>What is System Design?</strong> System design is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specified requirements. It involves designing scalable, reliable, and maintainable distributed systems.</p>
                    <p><strong>Why Learn System Design?</strong> Essential for senior engineering roles, system design skills help you build robust applications that can handle millions of users, ensure high availability, and scale efficiently.</p>
                    <p><strong>How to Master System Design?</strong> Start with fundamentals, understand trade-offs, practice with real-world examples, and learn from existing large-scale systems like Netflix, Amazon, and Google.</p>
                </div>

                <div class="topic" id="fundamentals">
                    <h2>System Design Fundamentals</h2>
                    <p><strong>What are System Design Fundamentals?</strong> Core concepts and principles that form the foundation of designing distributed systems, including scalability, reliability, consistency, and performance.</p>
                    <p><strong>How to Apply Fundamentals?</strong> Understand each concept deeply, learn when to apply specific patterns, and practice making architectural decisions based on requirements and constraints.</p>
                    <p><strong>Best Practices:</strong> Always consider trade-offs, start simple and evolve, design for failure, and prioritize user experience and business requirements.</p>

                    <h3>Key Concepts</h3>
                    <ul>
                        <li><strong>Scalability:</strong> Ability to handle increased load by adding resources</li>
                        <li><strong>Reliability:</strong> System continues to work correctly even when failures occur</li>
                        <li><strong>Availability:</strong> System remains operational over time</li>
                        <li><strong>Consistency:</strong> All nodes see the same data simultaneously</li>
                        <li><strong>Partition Tolerance:</strong> System continues despite network failures</li>
                        <li><strong>Latency:</strong> Time to process a single request</li>
                        <li><strong>Throughput:</strong> Number of requests processed per unit time</li>
                    </ul>

                    <h3>CAP Theorem</h3>
                    <p><strong>Definition:</strong> In a distributed system, you can only guarantee 2 out of 3: Consistency, Availability, Partition Tolerance</p>
                    <ul>
                        <li><strong>CP Systems:</strong> MongoDB, HBase (Consistency + Partition Tolerance)</li>
                        <li><strong>AP Systems:</strong> Cassandra, DynamoDB (Availability + Partition Tolerance)</li>
                        <li><strong>CA Systems:</strong> Traditional RDBMS (Consistency + Availability)</li>
                    </ul>

                    <h3>ACID vs BASE</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>ACID (SQL)</th>
                                <th>BASE (NoSQL)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Atomicity</td>
                                <td>Basically Available</td>
                            </tr>
                            <tr>
                                <td>Consistency</td>
                                <td>Soft State</td>
                            </tr>
                            <tr>
                                <td>Isolation</td>
                                <td>Eventually Consistent</td>
                            </tr>
                            <tr>
                                <td>Durability</td>
                                <td>-</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="topic" id="scalability">
                    <h2>Scalability Principles</h2>
                    <p><strong>What is Scalability?</strong> The ability of a system to handle increased workload by adding resources. It's about maintaining performance as the system grows.</p>
                    <p><strong>How to Achieve Scalability?</strong> Use horizontal scaling, implement proper caching, optimize database queries, and design stateless services.</p>
                    <p><strong>Best Practices:</strong> Scale horizontally when possible, identify bottlenecks early, use asynchronous processing, and implement proper monitoring.</p>

                    <h3>Types of Scaling</h3>
                    <h4>Vertical Scaling (Scale Up)</h4>
                    <ul>
                        <li><strong>Definition:</strong> Adding more power (CPU, RAM) to existing machines</li>
                        <li><strong>Pros:</strong> Simple, no code changes, strong consistency</li>
                        <li><strong>Cons:</strong> Hardware limits, single point of failure, expensive</li>
                        <li><strong>Use Cases:</strong> Legacy applications, databases requiring ACID properties</li>
                    </ul>

                    <h4>Horizontal Scaling (Scale Out)</h4>
                    <ul>
                        <li><strong>Definition:</strong> Adding more machines to the resource pool</li>
                        <li><strong>Pros:</strong> No hardware limits, fault tolerant, cost-effective</li>
                        <li><strong>Cons:</strong> Complex, eventual consistency, network overhead</li>
                        <li><strong>Use Cases:</strong> Web applications, microservices, big data processing</li>
                    </ul>

                    <h3>Scaling Strategies</h3>
                    <ul>
                        <li><strong>Stateless Services:</strong> No server-side state, easy to scale horizontally</li>
                        <li><strong>Database Sharding:</strong> Distribute data across multiple databases</li>
                        <li><strong>Read Replicas:</strong> Separate read and write operations</li>
                        <li><strong>Auto Scaling:</strong> Automatically adjust resources based on demand</li>
                        <li><strong>Circuit Breakers:</strong> Prevent cascade failures</li>
                    </ul>
                </div>

                <div class="topic" id="databases">
                    <h2>Database Design</h2>
                    <p><strong>What is Database Design?</strong> The process of structuring data storage to meet application requirements while ensuring performance, scalability, and data integrity.</p>
                    <p><strong>How to Design Databases?</strong> Understand data access patterns, choose appropriate database types, design efficient schemas, and plan for scaling needs.</p>
                    <p><strong>Best Practices:</strong> Normalize when needed, denormalize for performance, use appropriate indexes, and consider data consistency requirements.</p>

                    <h3>SQL vs NoSQL</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>SQL</th>
                                <th>NoSQL</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Schema</td>
                                <td>Fixed schema</td>
                                <td>Flexible schema</td>
                            </tr>
                            <tr>
                                <td>Scaling</td>
                                <td>Vertical</td>
                                <td>Horizontal</td>
                            </tr>
                            <tr>
                                <td>ACID</td>
                                <td>Full ACID</td>
                                <td>Eventually consistent</td>
                            </tr>
                            <tr>
                                <td>Queries</td>
                                <td>Complex SQL</td>
                                <td>Simple queries</td>
                            </tr>
                            <tr>
                                <td>Use Cases</td>
                                <td>Financial, CRM</td>
                                <td>Big data, real-time</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Database Types</h3>
                    <h4>Relational Databases (RDBMS)</h4>
                    <ul>
                        <li><strong>Examples:</strong> MySQL, PostgreSQL, Oracle</li>
                        <li><strong>Use Cases:</strong> Financial systems, e-commerce, CRM</li>
                        <li><strong>Strengths:</strong> ACID compliance, complex queries, mature ecosystem</li>
                    </ul>

                    <h4>Document Databases</h4>
                    <ul>
                        <li><strong>Examples:</strong> MongoDB, CouchDB</li>
                        <li><strong>Use Cases:</strong> Content management, catalogs, user profiles</li>
                        <li><strong>Strengths:</strong> Flexible schema, JSON-like documents</li>
                    </ul>

                    <h4>Key-Value Stores</h4>
                    <ul>
                        <li><strong>Examples:</strong> Redis, DynamoDB, Cassandra</li>
                        <li><strong>Use Cases:</strong> Caching, session storage, real-time recommendations</li>
                        <li><strong>Strengths:</strong> High performance, simple model, horizontal scaling</li>
                    </ul>

                    <h4>Graph Databases</h4>
                    <ul>
                        <li><strong>Examples:</strong> Neo4j, Amazon Neptune</li>
                        <li><strong>Use Cases:</strong> Social networks, recommendation engines, fraud detection</li>
                        <li><strong>Strengths:</strong> Relationship queries, network analysis</li>
                    </ul>

                    <h3>Database Scaling Patterns</h3>
                    <h4>Read Replicas</h4>
                    <ul>
                        <li><strong>Purpose:</strong> Distribute read load across multiple database instances</li>
                        <li><strong>Implementation:</strong> Master-slave replication</li>
                        <li><strong>Benefits:</strong> Improved read performance, high availability</li>
                    </ul>

                    <h4>Database Sharding</h4>
                    <ul>
                        <li><strong>Purpose:</strong> Distribute data across multiple databases</li>
                        <li><strong>Strategies:</strong> Range-based, hash-based, directory-based</li>
                        <li><strong>Challenges:</strong> Cross-shard queries, rebalancing</li>
                    </ul>
                </div>

                <div class="topic" id="caching">
                    <h2>Caching Strategies</h2>
                    <p><strong>What is Caching?</strong> Storing frequently accessed data in fast storage to reduce latency and improve system performance.</p>
                    <p><strong>How to Implement Caching?</strong> Identify cacheable data, choose appropriate cache levels, implement cache invalidation strategies, and monitor cache performance.</p>
                    <p><strong>Best Practices:</strong> Cache at multiple levels, implement proper TTL, handle cache misses gracefully, and monitor hit rates.</p>

                    <h3>Cache Levels</h3>
                    <ul>
                        <li><strong>Browser Cache:</strong> Client-side caching for static resources</li>
                        <li><strong>CDN Cache:</strong> Geographic distribution of content</li>
                        <li><strong>Reverse Proxy Cache:</strong> Server-side caching (Nginx, Varnish)</li>
                        <li><strong>Application Cache:</strong> In-memory caching (Redis, Memcached)</li>
                        <li><strong>Database Cache:</strong> Query result caching</li>
                    </ul>

                    <h3>Cache Patterns</h3>
                    <h4>Cache-Aside (Lazy Loading)</h4>
                    <pre><code>// Application manages cache
data = cache.get(key)
if (data == null) {
    data = database.get(key)
    cache.set(key, data)
}
return data</code></pre>

                    <h4>Write-Through</h4>
                    <pre><code>// Write to cache and database simultaneously
cache.set(key, data)
database.set(key, data)</code></pre>

                    <h4>Write-Behind (Write-Back)</h4>
                    <pre><code>// Write to cache immediately, database later
cache.set(key, data)
// Asynchronously write to database</code></pre>

                    <h3>Cache Invalidation</h3>
                    <ul>
                        <li><strong>TTL (Time To Live):</strong> Automatic expiration after time period</li>
                        <li><strong>Manual Invalidation:</strong> Explicit cache removal on data updates</li>
                        <li><strong>Event-Based:</strong> Invalidate based on system events</li>
                        <li><strong>LRU (Least Recently Used):</strong> Remove least accessed items</li>
                    </ul>
                </div>

                <div class="topic" id="load-balancing">
                    <h2>Load Balancing</h2>
                    <p><strong>What is Load Balancing?</strong> Distributing incoming requests across multiple servers to ensure no single server becomes overwhelmed.</p>
                    <p><strong>How to Implement Load Balancing?</strong> Choose appropriate algorithms, configure health checks, implement session management, and plan for failover scenarios.</p>
                    <p><strong>Best Practices:</strong> Use multiple load balancer layers, implement health checks, consider geographic distribution, and plan for auto-scaling.</p>

                    <h3>Load Balancing Algorithms</h3>
                    <ul>
                        <li><strong>Round Robin:</strong> Requests distributed sequentially</li>
                        <li><strong>Weighted Round Robin:</strong> Servers assigned weights based on capacity</li>
                        <li><strong>Least Connections:</strong> Route to server with fewest active connections</li>
                        <li><strong>IP Hash:</strong> Route based on client IP hash</li>
                        <li><strong>Geographic:</strong> Route based on client location</li>
                    </ul>

                    <h3>Types of Load Balancers</h3>
                    <h4>Layer 4 (Transport Layer)</h4>
                    <ul>
                        <li><strong>Function:</strong> Routes based on IP and port</li>
                        <li><strong>Pros:</strong> Fast, simple, protocol agnostic</li>
                        <li><strong>Cons:</strong> Limited routing decisions</li>
                    </ul>

                    <h4>Layer 7 (Application Layer)</h4>
                    <ul>
                        <li><strong>Function:</strong> Routes based on content (HTTP headers, URLs)</li>
                        <li><strong>Pros:</strong> Intelligent routing, SSL termination</li>
                        <li><strong>Cons:</strong> Higher latency, more complex</li>
                    </ul>

                    <h3>Session Management</h3>
                    <ul>
                        <li><strong>Sticky Sessions:</strong> Route user to same server</li>
                        <li><strong>Session Replication:</strong> Share session data across servers</li>
                        <li><strong>External Session Store:</strong> Store sessions in Redis/database</li>
                        <li><strong>Stateless Design:</strong> No server-side session state</li>
                    </ul>
                </div>

                <div class="topic" id="microservices">
                    <h2>Microservices Architecture</h2>
                    <p><strong>What are Microservices?</strong> An architectural approach where applications are built as a collection of small, independent services that communicate over well-defined APIs.</p>
                    <p><strong>How to Design Microservices?</strong> Identify service boundaries, design for independence, implement proper communication patterns, and ensure observability.</p>
                    <p><strong>Best Practices:</strong> Single responsibility per service, database per service, API versioning, and comprehensive monitoring.</p>

                    <h3>Microservices vs Monolith</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Aspect</th>
                                <th>Monolith</th>
                                <th>Microservices</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Deployment</td>
                                <td>Single unit</td>
                                <td>Independent services</td>
                            </tr>
                            <tr>
                                <td>Scaling</td>
                                <td>Scale entire app</td>
                                <td>Scale individual services</td>
                            </tr>
                            <tr>
                                <td>Technology</td>
                                <td>Single stack</td>
                                <td>Polyglot programming</td>
                            </tr>
                            <tr>
                                <td>Complexity</td>
                                <td>Simple initially</td>
                                <td>Distributed complexity</td>
                            </tr>
                            <tr>
                                <td>Team Structure</td>
                                <td>Single team</td>
                                <td>Multiple teams</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Service Communication</h3>
                    <h4>Synchronous Communication</h4>
                    <ul>
                        <li><strong>REST APIs:</strong> HTTP-based, stateless, cacheable</li>
                        <li><strong>GraphQL:</strong> Query language for APIs</li>
                        <li><strong>gRPC:</strong> High-performance RPC framework</li>
                    </ul>

                    <h4>Asynchronous Communication</h4>
                    <ul>
                        <li><strong>Message Queues:</strong> RabbitMQ, Apache Kafka</li>
                        <li><strong>Event Streaming:</strong> Apache Kafka, Amazon Kinesis</li>
                        <li><strong>Pub/Sub:</strong> Google Pub/Sub, Amazon SNS</li>
                    </ul>

                    <h3>Service Discovery</h3>
                    <ul>
                        <li><strong>Client-Side Discovery:</strong> Client queries service registry</li>
                        <li><strong>Server-Side Discovery:</strong> Load balancer queries registry</li>
                        <li><strong>Service Mesh:</strong> Infrastructure layer for service communication</li>
                        <li><strong>Tools:</strong> Consul, Eureka, Istio</li>
                    </ul>
                </div>

                <div class="topic" id="messaging">
                    <h2>Message Queues & Streaming</h2>
                    <p><strong>What is Message Queuing?</strong> Asynchronous communication pattern where messages are stored in queues and processed by consumers, enabling loose coupling between services.</p>
                    <p><strong>How to Implement Messaging?</strong> Choose appropriate messaging patterns, design for reliability, implement proper error handling, and ensure message ordering when needed.</p>
                    <p><strong>Best Practices:</strong> Design idempotent consumers, implement dead letter queues, monitor queue depths, and plan for message replay.</p>

                    <h3>Messaging Patterns</h3>
                    <h4>Point-to-Point (Queue)</h4>
                    <ul>
                        <li><strong>Pattern:</strong> One producer, one consumer per message</li>
                        <li><strong>Use Cases:</strong> Task processing, work distribution</li>
                        <li><strong>Examples:</strong> RabbitMQ, Amazon SQS</li>
                    </ul>

                    <h4>Publish-Subscribe (Topic)</h4>
                    <ul>
                        <li><strong>Pattern:</strong> One producer, multiple consumers</li>
                        <li><strong>Use Cases:</strong> Event notifications, data replication</li>
                        <li><strong>Examples:</strong> Apache Kafka, Amazon SNS</li>
                    </ul>

                    <h3>Message Queue Technologies</h3>
                    <h4>RabbitMQ</h4>
                    <ul>
                        <li><strong>Type:</strong> Traditional message broker</li>
                        <li><strong>Strengths:</strong> Flexible routing, AMQP protocol</li>
                        <li><strong>Use Cases:</strong> Complex routing, guaranteed delivery</li>
                    </ul>

                    <h4>Apache Kafka</h4>
                    <ul>
                        <li><strong>Type:</strong> Distributed streaming platform</li>
                        <li><strong>Strengths:</strong> High throughput, durability, replay capability</li>
                        <li><strong>Use Cases:</strong> Event streaming, log aggregation, real-time analytics</li>
                    </ul>

                    <h4>Amazon SQS</h4>
                    <ul>
                        <li><strong>Type:</strong> Managed message queue service</li>
                        <li><strong>Strengths:</strong> Fully managed, scalable, integrated with AWS</li>
                        <li><strong>Use Cases:</strong> Decoupling microservices, batch processing</li>
                    </ul>

                    <h3>Event Sourcing & CQRS</h3>
                    <h4>Event Sourcing</h4>
                    <ul>
                        <li><strong>Concept:</strong> Store events instead of current state</li>
                        <li><strong>Benefits:</strong> Complete audit trail, time travel, replay capability</li>
                        <li><strong>Challenges:</strong> Event schema evolution, snapshot management</li>
                    </ul>

                    <h4>CQRS (Command Query Responsibility Segregation)</h4>
                    <ul>
                        <li><strong>Concept:</strong> Separate read and write models</li>
                        <li><strong>Benefits:</strong> Optimized queries, independent scaling</li>
                        <li><strong>Use Cases:</strong> Complex domains, high read/write ratios</li>
                    </ul>
                </div>

                <div class="topic" id="cdn">
                    <h2>Content Delivery Networks</h2>
                    <p><strong>What is a CDN?</strong> A geographically distributed network of servers that deliver content to users from the nearest location, reducing latency and improving performance.</p>
                    <p><strong>How CDNs Work?</strong> Cache content at edge locations, route requests to nearest server, implement intelligent caching strategies, and provide global load distribution.</p>
                    <p><strong>Best Practices:</strong> Optimize cache headers, implement proper invalidation, use appropriate TTL values, and monitor cache hit rates.</p>

                    <h3>CDN Benefits</h3>
                    <ul>
                        <li><strong>Reduced Latency:</strong> Content served from nearest edge location</li>
                        <li><strong>Improved Performance:</strong> Faster page load times</li>
                        <li><strong>Reduced Server Load:</strong> Offload traffic from origin servers</li>
                        <li><strong>Global Reach:</strong> Serve users worldwide efficiently</li>
                        <li><strong>DDoS Protection:</strong> Absorb and mitigate attacks</li>
                    </ul>

                    <h3>CDN Architecture</h3>
                    <ul>
                        <li><strong>Edge Servers:</strong> Geographically distributed cache servers</li>
                        <li><strong>Origin Servers:</strong> Source of original content</li>
                        <li><strong>DNS Resolution:</strong> Route users to nearest edge server</li>
                        <li><strong>Cache Hierarchy:</strong> Multi-tier caching strategy</li>
                    </ul>

                    <h3>Caching Strategies</h3>
                    <ul>
                        <li><strong>Static Content:</strong> Images, CSS, JavaScript (long TTL)</li>
                        <li><strong>Dynamic Content:</strong> API responses, personalized content (short TTL)</li>
                        <li><strong>Edge Side Includes:</strong> Assemble pages at edge</li>
                        <li><strong>Purge/Invalidation:</strong> Remove outdated content</li>
                    </ul>

                    <h3>Popular CDN Providers</h3>
                    <ul>
                        <li><strong>CloudFlare:</strong> Global network, security features</li>
                        <li><strong>Amazon CloudFront:</strong> AWS integration, Lambda@Edge</li>
                        <li><strong>Akamai:</strong> Enterprise-focused, extensive network</li>
                        <li><strong>Google Cloud CDN:</strong> GCP integration, global infrastructure</li>
                    </ul>
                </div>

                <div class="topic" id="security">
                    <h2>Security & Authentication</h2>
                    <p><strong>What is System Security?</strong> Protecting systems and data from unauthorized access, ensuring data integrity, and maintaining system availability against various threats.</p>
                    <p><strong>How to Implement Security?</strong> Apply defense in depth, implement proper authentication and authorization, encrypt data in transit and at rest, and follow security best practices.</p>
                    <p><strong>Best Practices:</strong> Principle of least privilege, regular security audits, input validation, and comprehensive logging.</p>

                    <h3>Authentication Methods</h3>
                    <h4>Session-Based Authentication</h4>
                    <ul>
                        <li><strong>Process:</strong> Server creates session, stores session ID in cookie</li>
                        <li><strong>Pros:</strong> Simple, server controls session</li>
                        <li><strong>Cons:</strong> Server state, scaling challenges</li>
                    </ul>

                    <h4>Token-Based Authentication (JWT)</h4>
                    <ul>
                        <li><strong>Process:</strong> Server issues signed token, client includes in requests</li>
                        <li><strong>Pros:</strong> Stateless, scalable, cross-domain</li>
                        <li><strong>Cons:</strong> Token size, revocation challenges</li>
                    </ul>

                    <h4>OAuth 2.0</h4>
                    <ul>
                        <li><strong>Purpose:</strong> Authorization framework for third-party access</li>
                        <li><strong>Flows:</strong> Authorization Code, Client Credentials, Implicit</li>
                        <li><strong>Use Cases:</strong> Social login, API access delegation</li>
                    </ul>

                    <h3>Security Measures</h3>
                    <ul>
                        <li><strong>HTTPS/TLS:</strong> Encrypt data in transit</li>
                        <li><strong>Input Validation:</strong> Prevent injection attacks</li>
                        <li><strong>Rate Limiting:</strong> Prevent abuse and DDoS</li>
                        <li><strong>CORS:</strong> Control cross-origin requests</li>
                        <li><strong>CSP:</strong> Content Security Policy headers</li>
                        <li><strong>WAF:</strong> Web Application Firewall</li>
                    </ul>

                    <h3>Common Vulnerabilities</h3>
                    <ul>
                        <li><strong>SQL Injection:</strong> Use parameterized queries</li>
                        <li><strong>XSS:</strong> Sanitize user input, use CSP</li>
                        <li><strong>CSRF:</strong> Use CSRF tokens, SameSite cookies</li>
                        <li><strong>Broken Authentication:</strong> Strong password policies, MFA</li>
                        <li><strong>Insecure Direct Object References:</strong> Proper authorization checks</li>
                    </ul>
                </div>

                <div class="topic" id="monitoring">
                    <h2>Monitoring & Observability</h2>
                    <p><strong>What is Observability?</strong> The ability to understand the internal state of a system based on external outputs, including metrics, logs, and traces.</p>
                    <p><strong>How to Implement Monitoring?</strong> Collect comprehensive metrics, implement structured logging, use distributed tracing, and create meaningful dashboards and alerts.</p>
                    <p><strong>Best Practices:</strong> Monitor business metrics, implement SLIs/SLOs, use correlation IDs, and practice chaos engineering.</p>

                    <h3>Three Pillars of Observability</h3>
                    <h4>Metrics</h4>
                    <ul>
                        <li><strong>Definition:</strong> Numerical measurements over time</li>
                        <li><strong>Types:</strong> Counter, Gauge, Histogram, Summary</li>
                        <li><strong>Examples:</strong> Request rate, error rate, response time</li>
                        <li><strong>Tools:</strong> Prometheus, Grafana, DataDog</li>
                    </ul>

                    <h4>Logs</h4>
                    <ul>
                        <li><strong>Definition:</strong> Timestamped records of events</li>
                        <li><strong>Levels:</strong> ERROR, WARN, INFO, DEBUG</li>
                        <li><strong>Structure:</strong> Structured logging (JSON) preferred</li>
                        <li><strong>Tools:</strong> ELK Stack, Splunk, Fluentd</li>
                    </ul>

                    <h4>Traces</h4>
                    <ul>
                        <li><strong>Definition:</strong> Request journey through distributed system</li>
                        <li><strong>Components:</strong> Spans, trace context, baggage</li>
                        <li><strong>Benefits:</strong> Performance bottlenecks, dependency mapping</li>
                        <li><strong>Tools:</strong> Jaeger, Zipkin, AWS X-Ray</li>
                    </ul>

                    <h3>Key Metrics to Monitor</h3>
                    <h4>Golden Signals (SRE)</h4>
                    <ul>
                        <li><strong>Latency:</strong> Time to serve requests</li>
                        <li><strong>Traffic:</strong> Demand on the system</li>
                        <li><strong>Errors:</strong> Rate of failed requests</li>
                        <li><strong>Saturation:</strong> Resource utilization</li>
                    </ul>

                    <h4>RED Method</h4>
                    <ul>
                        <li><strong>Rate:</strong> Requests per second</li>
                        <li><strong>Errors:</strong> Error rate</li>
                        <li><strong>Duration:</strong> Response time distribution</li>
                    </ul>

                    <h3>Alerting Best Practices</h3>
                    <ul>
                        <li><strong>Alert on Symptoms:</strong> Not causes</li>
                        <li><strong>Actionable Alerts:</strong> Every alert should require action</li>
                        <li><strong>Alert Fatigue:</strong> Avoid too many alerts</li>
                        <li><strong>Escalation:</strong> Proper escalation policies</li>
                        <li><strong>Runbooks:</strong> Document response procedures</li>
                    </ul>
                </div>

                <div class="topic" id="case-studies">
                    <h2>Real-World Case Studies</h2>
                    <p><strong>What are System Design Case Studies?</strong> Real-world examples of how large-scale systems are designed and implemented, providing practical insights into architectural decisions.</p>
                    <p><strong>How to Learn from Case Studies?</strong> Understand the requirements, analyze architectural choices, study trade-offs made, and apply lessons to your own designs.</p>
                    <p><strong>Best Practices:</strong> Focus on scalability challenges, understand business context, analyze failure scenarios, and study evolution over time.</p>

                    <h3>Design a URL Shortener (like bit.ly)</h3>
                    <h4>Requirements</h4>
                    <ul>
                        <li><strong>Functional:</strong> Shorten URLs, redirect to original URL, custom aliases</li>
                        <li><strong>Non-Functional:</strong> 100:1 read/write ratio, 100M URLs/day, 99.9% availability</li>
                        <li><strong>Scale:</strong> 100M URLs/day = 1160 URLs/second</li>
                    </ul>

                    <h4>High-Level Design</h4>
                    <pre><code>Client ‚Üí Load Balancer ‚Üí Web Servers ‚Üí Cache ‚Üí Database
                                    ‚Üì
                              Analytics Service</code></pre>

                    <h4>Database Schema</h4>
                    <pre><code>URLs Table:
- short_url (PK)
- long_url
- user_id
- created_at
- expires_at</code></pre>

                    <h4>URL Encoding Algorithm</h4>
                    <ul>
                        <li><strong>Base62 Encoding:</strong> [a-z, A-Z, 0-9] = 62 characters</li>
                        <li><strong>7 characters:</strong> 62^7 = 3.5 trillion combinations</li>
                        <li><strong>Counter-based:</strong> Use auto-incrementing ID</li>
                    </ul>

                    <h3>Design a Chat System (like WhatsApp)</h3>
                    <h4>Requirements</h4>
                    <ul>
                        <li><strong>Functional:</strong> 1-on-1 chat, group chat, online presence</li>
                        <li><strong>Non-Functional:</strong> Real-time, 50M DAU, 99.9% availability</li>
                        <li><strong>Scale:</strong> 1B messages/day</li>
                    </ul>

                    <h4>High-Level Architecture</h4>
                    <pre><code>Mobile Client ‚Üî Load Balancer ‚Üî Chat Service ‚Üî Message Queue
                                                        ‚Üì
                                              Notification Service
                                                        ‚Üì
                                                  Database</code></pre>

                    <h4>Real-time Communication</h4>
                    <ul>
                        <li><strong>WebSocket:</strong> Persistent connection for real-time messaging</li>
                        <li><strong>Message Queue:</strong> Kafka for message delivery</li>
                        <li><strong>Presence Service:</strong> Track online/offline status</li>
                    </ul>

                    <h3>Design a Social Media Feed (like Twitter)</h3>
                    <h4>Requirements</h4>
                    <ul>
                        <li><strong>Functional:</strong> Post tweets, follow users, timeline generation</li>
                        <li><strong>Non-Functional:</strong> 300M users, 150M DAU, 300K tweets/day</li>
                        <li><strong>Read Heavy:</strong> 300K tweets/day, 150M timeline reads/day</li>
                    </ul>

                    <h4>Feed Generation Approaches</h4>
                    <h5>Pull Model (Fan-out on Read)</h5>
                    <ul>
                        <li><strong>Process:</strong> Generate timeline when user requests</li>
                        <li><strong>Pros:</strong> No storage overhead, good for inactive users</li>
                        <li><strong>Cons:</strong> Slow timeline generation</li>
                    </ul>

                    <h5>Push Model (Fan-out on Write)</h5>
                    <ul>
                        <li><strong>Process:</strong> Pre-compute timelines when tweet is posted</li>
                        <li><strong>Pros:</strong> Fast timeline reads</li>
                        <li><strong>Cons:</strong> Storage overhead, slow for celebrities</li>
                    </ul>

                    <h5>Hybrid Approach</h5>
                    <ul>
                        <li><strong>Strategy:</strong> Push for normal users, pull for celebrities</li>
                        <li><strong>Implementation:</strong> Separate handling based on follower count</li>
                    </ul>
                </div>

                <div class="topic" id="interview-prep">
                    <h2>Interview Preparation</h2>
                    <p><strong>What is System Design Interview?</strong> A technical interview where candidates design large-scale distributed systems, demonstrating their understanding of scalability, reliability, and system architecture.</p>
                    <p><strong>How to Prepare?</strong> Study fundamentals, practice with real examples, understand trade-offs, and develop a structured approach to problem-solving.</p>
                    <p><strong>Best Practices:</strong> Ask clarifying questions, start simple and iterate, explain trade-offs, and consider all aspects of the system.</p>

                    <h3>Interview Process</h3>
                    <h4>1. Requirements Gathering (5-10 minutes)</h4>
                    <ul>
                        <li><strong>Functional Requirements:</strong> What should the system do?</li>
                        <li><strong>Non-Functional Requirements:</strong> Scale, performance, availability</li>
                        <li><strong>Constraints:</strong> Budget, timeline, existing systems</li>
                    </ul>

                    <h4>2. Capacity Estimation (5-10 minutes)</h4>
                    <ul>
                        <li><strong>Users:</strong> Daily/Monthly active users</li>
                        <li><strong>Traffic:</strong> Requests per second, read/write ratio</li>
                        <li><strong>Storage:</strong> Data size, growth rate</li>
                        <li><strong>Bandwidth:</strong> Network requirements</li>
                    </ul>

                    <h4>3. High-Level Design (10-15 minutes)</h4>
                    <ul>
                        <li><strong>Core Components:</strong> Main services and databases</li>
                        <li><strong>API Design:</strong> Key endpoints and data flow</li>
                        <li><strong>Database Schema:</strong> Main entities and relationships</li>
                    </ul>

                    <h4>4. Detailed Design (15-20 minutes)</h4>
                    <ul>
                        <li><strong>Deep Dive:</strong> Focus on 1-2 components</li>
                        <li><strong>Algorithms:</strong> Core algorithms and data structures</li>
                        <li><strong>Optimizations:</strong> Caching, indexing, partitioning</li>
                    </ul>

                    <h4>5. Scale and Reliability (5-10 minutes)</h4>
                    <ul>
                        <li><strong>Bottlenecks:</strong> Identify and address limitations</li>
                        <li><strong>Scaling:</strong> Horizontal scaling strategies</li>
                        <li><strong>Reliability:</strong> Failure scenarios and mitigation</li>
                    </ul>

                    <h3>Common Interview Questions</h3>
                    <ul>
                        <li><strong>Design a URL Shortener</strong> (bit.ly, tinyurl)</li>
                        <li><strong>Design a Social Media Platform</strong> (Twitter, Facebook)</li>
                        <li><strong>Design a Chat System</strong> (WhatsApp, Slack)</li>
                        <li><strong>Design a Video Streaming Service</strong> (YouTube, Netflix)</li>
                        <li><strong>Design a Search Engine</strong> (Google Search)</li>
                        <li><strong>Design a Ride-Sharing Service</strong> (Uber, Lyft)</li>
                        <li><strong>Design a Food Delivery System</strong> (DoorDash, Uber Eats)</li>
                        <li><strong>Design a Notification System</strong></li>
                        <li><strong>Design a Rate Limiter</strong></li>
                        <li><strong>Design a Distributed Cache</strong></li>
                    </ul>

                    <h3>Key Tips for Success</h3>
                    <ul>
                        <li><strong>Ask Questions:</strong> Clarify requirements before designing</li>
                        <li><strong>Start Simple:</strong> Begin with basic design, then add complexity</li>
                        <li><strong>Think Out Loud:</strong> Explain your thought process</li>
                        <li><strong>Consider Trade-offs:</strong> Discuss pros and cons of decisions</li>
                        <li><strong>Be Realistic:</strong> Use reasonable numbers and estimates</li>
                        <li><strong>Draw Diagrams:</strong> Visual representations help communication</li>
                        <li><strong>Handle Scale:</strong> Show how system handles growth</li>
                        <li><strong>Consider Failures:</strong> Discuss failure scenarios and recovery</li>
                    </ul>

                    <h3>Common Mistakes to Avoid</h3>
                    <ul>
                        <li><strong>Jumping to Details:</strong> Start with high-level design first</li>
                        <li><strong>Over-Engineering:</strong> Don't add unnecessary complexity</li>
                        <li><strong>Ignoring Requirements:</strong> Always refer back to requirements</li>
                        <li><strong>Not Considering Scale:</strong> Design for the specified scale</li>
                        <li><strong>Forgetting Non-Functional Requirements:</strong> Consider availability, consistency</li>
                        <li><strong>Not Explaining Trade-offs:</strong> Always justify your decisions</li>
                    </ul>

                    <h3>Recommended Resources</h3>
                    <ul>
                        <li><strong>Books:</strong> "Designing Data-Intensive Applications" by Martin Kleppmann</li>
                        <li><strong>Courses:</strong> "System Design Interview" by Alex Xu</li>
                        <li><strong>Blogs:</strong> High Scalability, AWS Architecture Center</li>
                        <li><strong>Practice:</strong> Pramp, InterviewBit System Design</li>
                        <li><strong>Papers:</strong> Google MapReduce, Amazon Dynamo, Facebook TAO</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    <script src="../footer.js"></script>
</body>
</html>