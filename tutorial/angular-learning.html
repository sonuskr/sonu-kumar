<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Angular Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="tutorial-styles.css">
</head>
<body class="page-angular">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Angular Learning Tutorial</h1>
                <p>Master Angular Modern Development</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'angular';</script>
    <script src="menu.js"></script>
    <div class="container">
        <div class="content-with-sidebar">
            <div class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Table of Contents</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#what-is-angular">What is Angular?</a></li>
                        <li><a href="#evolution">Angular Evolution</a></li>
                        <li><a href="#architecture">Angular Architecture</a></li>
                        <li><a href="#components">Creating Components</a></li>
                        <li><a href="#lifecycle">Component Lifecycle</a></li>
                        <li><a href="#dependency-injection">Dependency Injection</a></li>
                        <li><a href="#data-binding">Data Binding</a></li>
                        <li><a href="#control-flow">Control Flow</a></li>
                        <li><a href="#rxjs">RxJS Observables</a></li>
                        <li><a href="#forms">Reactive Forms</a></li>
                        <li><a href="#routing">Routing</a></li>
                        <li><a href="#http">HTTP Services</a></li>
                        <li><a href="#directives">Custom Directives</a></li>
                        <li><a href="#pipes">Pipes</a></li>
                        <li><a href="#signals">State Management</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                        <li><a href="#cli">Angular CLI</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                    </ul>
                </nav>
            </div>
            <div class="main-content">
                <div class="topic">
                    <h1>Angular - Complete Guide</h1>
                
                <section id="what-is-angular" class="section">
                    <h2>üöÄ What is Angular?</h2>
                    <p><strong>What it is:</strong> Angular is a modern TypeScript-based framework for building single-page applications (SPAs) with a component-based architecture.</p>
                    <p><strong>How it works:</strong> Uses components as building blocks, dependency injection for services, and reactive programming with RxJS for handling asynchronous operations.</p>
                    <p><strong>Why use it:</strong> Provides complete solution for building dynamic, interactive web applications with built-in dependency injection, routing, forms handling, and HTTP services.</p>
                    
                    <div class="subsection">
                        <h3>Key Features</h3>
                        <ul>
                            <li><strong>Component-Based:</strong> Reusable UI components with encapsulated logic</li>
                            <li><strong>TypeScript:</strong> Strong typing and modern JavaScript features</li>
                            <li><strong>Dependency Injection:</strong> Manages service dependencies automatically</li>
                            <li><strong>Reactive Programming:</strong> RxJS observables for async data handling</li>
                            <li><strong>CLI Tools:</strong> Powerful command-line interface for development</li>
                        </ul>
                    </div>
                </section>

                <section id="evolution" class="section">
                    <h2>üìà Angular Evolution</h2>
                    <p><strong>What it shows:</strong> Angular's progression from AngularJS to modern framework with regular updates every 6 months.</p>
                    <p><strong>How it evolved:</strong> Started as AngularJS (2010), completely rewritten as Angular 2+ (2016) with TypeScript, then continuous improvements.</p>
                    
                    <div class="subsection">
                        <h3>Major Milestones</h3>
                        <ul>
                            <li><strong>AngularJS (1.x):</strong> JavaScript-based, MVC pattern (2010-2021)</li>
                            <li><strong>Angular 2:</strong> Complete rewrite in TypeScript, component-based (2016)</li>
                            <li><strong>Angular 4-9:</strong> Incremental improvements, RxJS integration, Ivy renderer</li>
                            <li><strong>Angular 12:</strong> TypeScript 4.2+ support, strict mode by default</li>
                            <li><strong>Angular 14:</strong> Typed Forms, standalone components preview</li>
                            <li><strong>Angular 15:</strong> Standalone components stable, directive composition API</li>
                            <li><strong>Angular 16:</strong> Control flow syntax (@if, @for, @switch), signals preview</li>
                            <li><strong>Angular 17:</strong> New @if/@for/@switch stable, signals API, new lifecycle</li>
                        </ul>
                    </div>
                </section>

                <section id="architecture" class="section">
                    <h2>üè¢ Angular Architecture - Core Building Blocks</h2>
                    <p><strong>What it is:</strong> Angular follows a modular architecture where applications are built using interconnected building blocks.</p>
                    <p><strong>How it works:</strong> Components handle UI, services manage data/logic, modules organize features, and dependency injection connects everything.</p>
                    
                    <div class="subsection">
                        <h3>Core Building Blocks</h3>
                        <ul>
                            <li><strong>Components:</strong> Basic UI building blocks with template, class, and metadata</li>
                            <li><strong>Modules (NgModule):</strong> Logical grouping of components, services, pipes (being replaced by standalone)</li>
                            <li><strong>Services:</strong> Reusable business logic injected via dependency injection</li>
                            <li><strong>Directives:</strong> Structural (*ngIf, *ngFor) and attribute directives for DOM manipulation</li>
                            <li><strong>Pipes:</strong> Transform data in templates (date, currency, uppercase, custom)</li>
                            <li><strong>Decorators:</strong> @Component, @Injectable, @Input, @Output provide metadata</li>
                            <li><strong>Dependency Injection:</strong> Inversion of control pattern for service management</li>
                        </ul>
                    </div>
                    
                    <div class="subsection">
                        <h3>Application Flow</h3>
                        <p>1. <strong>Bootstrap:</strong> main.ts starts the application<br>
                        2. <strong>Root Component:</strong> AppComponent loads first<br>
                        3. <strong>Routing:</strong> Router determines which component to display<br>
                        4. <strong>Services:</strong> Provide data and business logic<br>
                        5. <strong>Templates:</strong> Render UI with data binding</p>
                    </div>
                </section>

                <section id="components" class="section">
                    <h2>üß© Creating Components (Modern Angular 17)</h2>
                    <p><strong>What it does:</strong> Components are the fundamental building blocks that control a portion of the screen called a view.</p>
                    <p><strong>How it works:</strong> Each component consists of a TypeScript class with @Component decorator, HTML template, and CSS styles.</p>
                    <p><strong>Best Practice:</strong> Use standalone components (Angular 14+) for better tree-shaking and simpler architecture.</p>
                <pre><code>
// Standalone component (Angular 14+)
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-card',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div class="user-card">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <button (click)="onDelete()">Delete</button>
    </div>
  `,
  styles: [`
    .user-card {
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
    }
  `]
})
export class UserCardComponent {
  @Input() user: any;
  @Output() delete = new EventEmitter<any>();
  
  onDelete() {
    this.delete.emit(this.user.id);
  }
}
                </code></pre>

                </section>

                <section id="lifecycle" class="section">
                    <h2>üîÑ Component Lifecycle Hooks</h2>
                    <p><strong>What it does:</strong> Lifecycle hooks provide visibility into key moments in a component's lifecycle from creation to destruction.</p>
                    <p><strong>How it works:</strong> Angular calls these methods at specific times during component lifecycle, allowing you to tap into those moments.</p>
                    <p><strong>Most Important:</strong> OnInit (initialization), OnDestroy (cleanup), OnChanges (input changes).</p>
                <pre><code>
import { Component, OnInit, OnChanges, OnDestroy } from '@angular/core';

@Component({
  selector: 'app-lifecycle',
  template: '...'
})
export class LifecycleComponent 
  implements OnInit, OnChanges, OnDestroy {
  
  ngOnInit() {
    // Called after component initialized
    // Initialize data, load from service
  }
  
  ngOnChanges(changes: SimpleChanges) {
    // Called when @Input properties change
    if (changes['userId']) {
      console.log('User ID changed to:', changes['userId'].currentValue);
    }
  }
  
  ngOnDestroy() {
    // Called when component destroyed
    // Cleanup: unsubscribe, clear timers
  }
  
  // Other hooks: AfterViewInit, AfterContentInit, AfterViewChecked
}
                </code></pre>

                </section>

                <section id="dependency-injection" class="section">
                    <h2>üîå Dependency Injection</h2>
                    <p><strong>What it does:</strong> Design pattern where Angular provides dependencies to a class instead of the class creating them itself.</p>
                    <p><strong>How it works:</strong> Angular's injector creates service instances and injects them into components/services that need them.</p>
                    <p><strong>Benefits:</strong> Loose coupling, easier testing, better code organization, and automatic dependency management.</p>
                <pre><code>
// Service definition
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'  // Available app-wide
})
export class UserService {
  constructor(private http: HttpClient) {}
  
  getUsers(): Observable<any[]> {
    return this.http.get<any[]>('/api/users');
  }
  
  getUser(id: number): Observable<any> {
    return this.http.get<any>(`/api/users/${id}`);
  }
}

// Using service in component
@Component({
  selector: 'app-users',
  template: '...'
})
export class UsersComponent implements OnInit {
  users$ = new Observable<any[]>();
  
  // Inject service through constructor
  constructor(private userService: UserService) {}
  
  ngOnInit() {
    this.users$ = this.userService.getUsers();
  }
}
                </code></pre>

                </section>

                <section id="data-binding" class="section">
                    <h2>üîó Data Binding & Template Syntax</h2>
                    <p><strong>What it does:</strong> Connects component data with the DOM, automatically updating the UI when data changes.</p>
                    <p><strong>How it works:</strong> Angular provides four types of data binding: interpolation, property binding, event binding, and two-way binding.</p>
                    <p><strong>Performance:</strong> One-way binding is faster; use two-way binding sparingly for form inputs.</p>
                <pre><code>
// Property binding: [] - one way, component to template
&lt;img [src]="imageUrl" [alt]="imageName" /&gt;

// Event binding: () - template to component
&lt;button (click)="onClickButton()"&gt;Click me&lt;/button&gt;
&lt;input (keyup)="onKeyUp($event)" /&gt;

// Two-way binding: [()] - both directions
&lt;input [(ngModel)]="userName" /&gt;

// Interpolation: {{ }} - template expression
&lt;h1&gt;{{ title }}&lt;/h1&gt;
&lt;p&gt;{{ user.firstName + ' ' + user.lastName }}&lt;/p&gt;

// Property binding shorthand
&lt;div [title]="description"&gt;...&lt;/div&gt;

// Binding to custom components
&lt;app-user-card [user]="currentUser" (delete)="onDelete($event)"&gt;&lt;/app-user-card&gt;
                </code></pre>

                </section>

                <section id="control-flow" class="section">
                    <h2>üîÄ Control Flow (Angular 17+)</h2>
                    <p><strong>What it does:</strong> Controls which parts of the template are rendered based on conditions and data.</p>
                    <p><strong>How it works:</strong> New @if, @for, @switch syntax provides better performance and type safety than structural directives.</p>
                    <p><strong>Migration:</strong> Gradually replace *ngIf, *ngFor, *ngSwitch with new syntax for better performance.</p>
                <pre><code>
// @if - replaces *ngIf
&lt;div *ngIf="isLoggedIn; else notLoggedIn"&gt;
  Welcome {{ userName }}
&lt;/div&gt;
&lt;ng-template #notLoggedIn&gt;
  Please login
&lt;/ng-template&gt;

// Modern syntax (Angular 17)
@if (isLoggedIn) {
  &lt;div&gt;Welcome {{ userName }}&lt;/div&gt;
} @else {
  &lt;div&gt;Please login&lt;/div&gt;
}

// @for - replaces *ngFor
@for (item of items; track item.id) {
  &lt;li&gt;{{ item.name }} - ${{ item.price }}&lt;/li&gt;
}

// @switch - replaces [ngSwitch]
@switch (userRole) {
  @case ('admin') {
    &lt;p&gt;Admin Panel&lt;/p&gt;
  }
  @case ('user') {
    &lt;p&gt;User Dashboard&lt;/p&gt;
  }
  @default {
    &lt;p&gt;Guest View&lt;/p&gt;
  }
}
                </code></pre>

                </section>

                <section id="rxjs" class="section">
                    <h2>üåä RxJS Observables & Reactive Programming</h2>
                    <p><strong>What it does:</strong> Handles asynchronous data streams using reactive programming patterns with Observables.</p>
                    <p><strong>How it works:</strong> Observables emit values over time, operators transform data, and subscribers react to changes.</p>
                    <p><strong>Key Concept:</strong> Think of data as streams that flow through your application, transforming along the way.</p>
                <pre><code>
import { Observable, Subject, BehaviorSubject } from 'rxjs';
import { map, filter, switchMap, takeUntil } from 'rxjs/operators';

// Observable - one-way stream
const userClick$ = fromEvent(button, 'click');

// Subject - multicasting (many subscribers)
private messageSubject = new Subject<string>();
public message$ = this.messageSubject.asObservable();

// BehaviorSubject - has current value
private userSubject = new BehaviorSubject<User>(defaultUser);
public user$ = this.userSubject.asObservable();

getUser(id: number) {
  return this.http.get<User>(`/api/users/${id}`).pipe(
    map(user => ({ ...user, name: user.name.toUpperCase() })),
    filter(user => user.active),
    switchMap(user => this.getDetails(user.id))
  );
}

// Async pipe auto-unsubscribes
&lt;div&gt;{{ user$ | async | json }}&lt;/div&gt;
                </code></pre>

                </section>

                <section id="forms" class="section">
                    <h2>üìù Reactive Forms (Type-Safe)</h2>
                    <p><strong>What it does:</strong> Provides a model-driven approach to handling form inputs with validation and type safety.</p>
                    <p><strong>How it works:</strong> Form controls are created in component class, providing programmatic access to form state and validation.</p>
                    <p><strong>Advantages:</strong> Better for complex forms, easier testing, type safety, and reactive validation.</p>
                <pre><code>
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';

@Component({
  selector: 'app-user-form',
  imports: [ReactiveFormsModule],
  template: `
    &lt;form [formGroup]="form" (ngSubmit)="onSubmit()"&gt;
      &lt;input formControlName="name" required /&gt;
      &lt;input formControlName="email" type="email" /&gt;
      
      &lt;div formGroupName="address"&gt;
        &lt;input formControlName="street" /&gt;
        &lt;input formControlName="city" /&gt;
      &lt;/div&gt;
      
      &lt;div *ngIf="form.get('email')?.hasError('email')"&gt;
        Invalid email
      &lt;/div&gt;
      
      &lt;button [disabled]="form.invalid"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  `
})
export class UserFormComponent {
  form: FormGroup;
  
  constructor(private fb: FormBuilder) {
    this.form = this.fb.group({
      name: ['', [Validators.required]],
      email: ['', [Validators.required, Validators.email]],
      address: this.fb.group({
        street: [''],
        city: ['']
      })
    });
  }
  
  onSubmit() {
    if (this.form.valid) {
      console.log(this.form.value);
    }
  }
}
                </code></pre>

                </section>

                <section id="routing" class="section">
                    <h2>üó∫Ô∏è Routing & Navigation</h2>
                    <p><strong>What it does:</strong> Enables navigation between different views/components in a single-page application.</p>
                    <p><strong>How it works:</strong> Router maps URL paths to components, manages navigation history, and supports route parameters.</p>
                    <p><strong>Features:</strong> Lazy loading, route guards, nested routes, and programmatic navigation.</p>
                <pre><code>
import { Routes } from '@angular/router';
import { UsersComponent } from './users/users.component';
import { UserDetailComponent } from './user-detail/user-detail.component';

export const routes: Routes = [
  { path: '', redirectTo: '/users', pathMatch: 'full' },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id', component: UserDetailComponent },
  { path: 'admin', component: AdminComponent, canActivate: [authGuard] },
  { path: '**', component: PageNotFoundComponent }
];

// In component - navigate programmatically
import { Router } from '@angular/router';

export class UserDetailComponent {
  constructor(private router: Router, private route: ActivatedRoute) {}
  
  goToUsers() {
    this.router.navigate(['/users']);
  }
  
  // Get route parameters
  ngOnInit() {
    this.route.params.subscribe(params => {
      const id = params['id'];
      this.loadUser(id);
    });
  }
}
                </code></pre>

                </section>

                <section id="http" class="section">
                    <h2>üåê HTTP Services with Error Handling</h2>
                    <p><strong>What it does:</strong> Communicates with backend APIs using HTTP requests with built-in error handling and retry logic.</p>
                    <p><strong>How it works:</strong> HttpClient returns Observables, allowing reactive handling of HTTP responses with operators.</p>
                    <p><strong>Best Practices:</strong> Always handle errors, use interceptors for common logic, and implement retry strategies.</p>
                <pre><code>
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { catchError, retry } from 'rxjs/operators';
import { throwError } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  constructor(private http: HttpClient) {}
  
  getUsers() {
    return this.http.get<any[]>('/api/users').pipe(
      retry(1),
      catchError(this.handleError)
    );
  }
  
  createUser(user: any) {
    return this.http.post<any>('/api/users', user).pipe(
      catchError(error => {
        console.error('Error creating user:', error);
        return throwError(() => new Error('Failed to create user'));
      })
    );
  }
  
  private handleError(error: HttpErrorResponse) {
    let errorMsg = 'Unknown error occurred';
    
    if (error.error instanceof ErrorEvent) {
      errorMsg = `Client Error: ${error.error.message}`;
    } else {
      errorMsg = `Server Error: ${error.status} - ${error.message}`;
    }
    
    return throwError(() => new Error(errorMsg));
  }
}
                </code></pre>

                </section>

                <section id="directives" class="section">
                    <h2>üé® Custom Directives</h2>
                    <p><strong>What it does:</strong> Extends HTML with custom behavior by manipulating DOM elements or adding functionality.</p>
                    <p><strong>How it works:</strong> Attribute directives modify element behavior, structural directives change DOM layout.</p>
                    <p><strong>Use Cases:</strong> DOM manipulation, event handling, styling, validation, and reusable behaviors.</p>
                <pre><code>
import { Directive, ElementRef, HostListener, Input } from '@angular/core';

// Attribute Directive - modify behavior
@Directive({
  selector: '[appHighlight]',
  standalone: true
})
export class HighlightDirective {
  @Input() appHighlight = 'yellow';
  
  constructor(private el: ElementRef) {}
  
  @HostListener('mouseenter')
  onMouseEnter() {
    this.el.nativeElement.style.backgroundColor = this.appHighlight;
  }
  
  @HostListener('mouseleave')
  onMouseLeave() {
    this.el.nativeElement.style.backgroundColor = null;
  }
}

// Usage: &lt;div appHighlight="lightblue"&gt;Hover me&lt;/div&gt;
                </code></pre>

                </section>

                <section id="pipes" class="section">
                    <h2>üîÑ Pipes (Data Transformation)</h2>
                    <p><strong>What it does:</strong> Transforms data in templates without changing the original data, like formatting dates or currency.</p>
                    <p><strong>How it works:</strong> Takes input value, applies transformation logic, and returns formatted output for display.</p>
                    <p><strong>Performance:</strong> Pure pipes are cached and only re-run when input changes; impure pipes run on every change detection.</p>
                <pre><code>
// Built-in pipes
{{ date | date:'short' }}
{{ price | currency:'USD' }}
{{ text | uppercase }}
{{ items | slice:0:3 }}
{{ obj | json }}
{{ 0.259 | percent }}

// Custom pipe
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'titleCase',
  standalone: true
})
export class TitleCasePipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return value;
    return value
      .toLowerCase()
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
}

// Usage: {{ title | titleCase }}
                </code></pre>

                </section>

                <section id="signals" class="section">
                    <h2>üì° State Management with Signals (Angular 17)</h2>
                    <p><strong>What it does:</strong> Provides reactive state management with fine-grained reactivity and automatic dependency tracking.</p>
                    <p><strong>How it works:</strong> Signals are reactive primitives that notify consumers when their value changes, enabling efficient updates.</p>
                    <p><strong>Benefits:</strong> Better performance than Zone.js, simpler mental model, and automatic dependency tracking.</p>
                <pre><code>
import { signal, computed, effect } from '@angular/core';

export class CounterComponent {
  // Create reactive signal
  count = signal(0);
  
  // Computed signal - auto updates when dependency changes
  doubled = computed(() => this.count() * 2);
  
  // Effect - runs when signal changes
  constructor() {
    effect(() => {
      console.log(`Count changed to: ${this.count()}`);
    });
  }
  
  increment() {
    this.count.update(val => val + 1);
  }
  
  reset() {
    this.count.set(0);
  }
}

// In template
&lt;p&gt;Count: {{ count() }}&lt;/p&gt;
&lt;p&gt;Doubled: {{ doubled() }}&lt;/p&gt;
&lt;button (click)="increment()"&gt;Increment&lt;/button&gt;
                </code></pre>

                </section>

                <section id="interview" class="section">
                    <h2>üéØ Common Interview Problems & Patterns</h2>
                    <p><strong>What to expect:</strong> Interviewers focus on Angular concepts, performance optimization, and real-world problem-solving.</p>
                    <p><strong>How to prepare:</strong> Understand core concepts deeply, practice coding problems, and know performance best practices.</p>
                <ul>
                    <li><strong>Change Detection:</strong> OnPush vs Default strategy</li>
                    <li><strong>Memory Leaks:</strong> Unsubscribe patterns, takeUntil operator</li>
                    <li><strong>Component Communication:</strong> @Input/@Output, services, shared state</li>
                    <li><strong>Performance:</strong> TrackBy in *ngFor, lazy loading routes</li>
                    <li><strong>Error Handling:</strong> Global error handler, retry logic</li>
                    <li><strong>Testing:</strong> Unit tests with TestBed, async/fakeAsync</li>
                    <li><strong>Authentication:</strong> Guards, interceptors, JWT storage</li>
                </ul>

                </section>

                <section id="cli" class="section">
                    <h2>üõ†Ô∏è Angular CLI Commands</h2>
                    <p><strong>What it does:</strong> Command-line interface that automates development tasks like project creation, code generation, and building.</p>
                    <p><strong>How it works:</strong> Provides schematics (blueprints) for generating code and configurations with best practices built-in.</p>
                    <p><strong>Productivity:</strong> Saves time by generating boilerplate code and maintaining consistent project structure.</p>
                <pre><code>
// Create new project
ng new my-app

// Generate components, services, etc
ng generate component components/user-list
ng generate service services/user
ng generate directive directives/highlight
ng generate pipe pipes/title-case

// Development server
ng serve --open

// Build for production
ng build --configuration production

// Run tests
ng test
ng e2e
                </code></pre>

                </section>

                <section id="best-practices" class="section">
                    <h2>‚ú® Best Practices & Production Tips</h2>
                    <p><strong>What it covers:</strong> Industry-standard practices for building maintainable, performant, and scalable Angular applications.</p>
                    <p><strong>How to apply:</strong> Follow these patterns from the start of your project to avoid technical debt and performance issues.</p>
                    <p><strong>Real-world impact:</strong> These practices are used in production applications serving millions of users.</p>
                <ul>
                    <li><strong>Smart vs Presentational Components:</strong> Separate data/logic from UI</li>
                    <li><strong>OnPush Change Detection:</strong> Better performance with immutable patterns</li>
                    <li><strong>Unsubscribe Pattern:</strong> Prevent memory leaks with takeUntil()</li>
                    <li><strong>Standalone Components:</strong> Modern approach (Angular 14+)</li>
                    <li><strong>Async Pipe:</strong> Auto-subscribe/unsubscribe in templates</li>
                    <li><strong>Type Safety:</strong> Use typed forms and strict TypeScript</li>
                    <li><strong>Lazy Loading:</strong> Split code by routes for faster initial load</li>
                    <li><strong>Code Organization:</strong> Feature modules, shared module pattern</li>
                </ul>

                    <h3>Real-world Application Structure:</h3>
                    <pre><code>
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ core/                    # Singleton services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ interceptors/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ guards/
‚îÇ   ‚îú‚îÄ‚îÄ shared/                  # Reusable components, pipes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ directives/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pipes/
‚îÇ   ‚îú‚îÄ‚îÄ features/                # Feature modules
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user-routing.module.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ products/
‚îÇ   ‚îú‚îÄ‚îÄ app.component.ts
‚îÇ   ‚îî‚îÄ‚îÄ app.routes.ts
‚îú‚îÄ‚îÄ main.ts
‚îî‚îÄ‚îÄ styles.css
                    </code></pre>

                    <h3>Key Interview Questions:</h3>
                    <ul>
                        <li>What's the difference between standalone and NgModule components?</li>
                        <li>Explain change detection strategies and when to use OnPush</li>
                        <li>How do you handle memory leaks in Angular?</li>
                        <li>What are RxJS Observables and why use them?</li>
                        <li>Difference between Reactive Forms and Template-driven Forms?</li>
                        <li>How does dependency injection work in Angular?</li>
                        <li>Explain Angular routing and lazy loading</li>
                        <li>How to secure API calls with JWT in Angular?</li>
                        <li>What are HTTP interceptors and their use cases?</li>
                        <li>How to optimize Angular application performance?</li>
                    </ul>
                </section>
                </div>
            </div>
        </div>
    </div>
    <script src="footer.js"></script>
</body>
</html>