<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>TypeScript Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="tutorial-styles.css" />

  </head>
  <body class="page-typescript">
    <header>
      <div class="container">
        <div class="hero">
          <h1>TypeScript Learning Tutorial</h1>
          <p>Master TypeScript Advanced Types & Features</p>
        </div>
      </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'typescript';</script>
    <script src="menu.js"></script>
    <div class="container">
      <div class="content-with-sidebar">
        <div class="sidebar-toc">
          <div class="toc-header">
            <h2>ðŸ“š Table of Contents</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#what-is-typescript">What is TypeScript?</a></li>
              <li><a href="#basic-types">Basic Types</a></li>
              <li><a href="#interfaces">Interfaces & Objects</a></li>
              <li><a href="#classes">Classes & Inheritance</a></li>
              <li><a href="#generics">Generics</a></li>
              <li><a href="#advanced-types">Advanced Types</a></li>
              <li><a href="#decorators">Decorators</a></li>
              <li><a href="#utility-types">Utility Types</a></li>
              <li><a href="#type-narrowing">Type Narrowing</a></li>
              <li><a href="#modules">Modules & Namespaces</a></li>
              <li><a href="#enums">Enum Types</a></li>
              <li><a href="#async">Async/Await & Promises</a></li>
              <li><a href="#configuration">Configuration</a></li>
              <li><a href="#interview">Interview Questions</a></li>
              <li><a href="#best-practices">Best Practices</a></li>
            </ul>
          </nav>
        </div>
        <div class="main-content">
          <div class="topic">
            <h1>TypeScript - Complete Guide</h1>
          
          <section id="what-is-typescript" class="section">
            <h2>What is TypeScript?</h2>
          <p>TypeScript is a superset of JavaScript that adds static type checking, interfaces, and other object-oriented features. It compiles to clean, readable JavaScript and helps catch errors at compile-time rather than runtime. Essential for large-scale applications and frameworks like Angular and modern React projects.</p>
          
          </section>

          <section id="basic-types" class="section">
            <h2>Basic Types</h2>
          <pre><code>
// Primitive types
let isDone: boolean = true;
let count: number = 42;
let name: string = 'John';
let symbol: symbol = Symbol('unique');
let bigInt: bigint = 123n;

// null and undefined
let nothing: null = null;
let undef: undefined = undefined;

// Any type (avoid when possible)
let notSure: any = 'could be anything';

// Union types - can be one of several types
let id: string | number;
id = 'ID123';  // OK
id = 123;      // OK
// id = true;  // Error

// Literal types
let direction: 'up' | 'down' | 'left' | 'right' = 'up';
let status: 1 | 2 | 3 = 1;

// Type aliases
type Age = number;
type Status = 'pending' | 'completed' | 'failed';

let myAge: Age = 30;
let myStatus: Status = 'pending';
          </code></pre>

          </section>

          <section id="interfaces" class="section">
            <h2>Interfaces & Objects</h2>
          <pre><code>
// Interface definition
interface User {
    id: number;
    name: string;
    email?: string;              // Optional property
    readonly username: string;   // Read-only
    age?: number;
    greet(): string;             // Method
}

// Implementing interface
const user: User = {
    id: 1,
    name: 'John',
    username: 'john123',
    email: 'john@example.com',
    greet() {
        return 'Hello ' + this.name;
    }
};

// Interface extension
interface Admin extends User {
    role: 'admin' | 'moderator';
    permissions: string[];
}

// Indexable types
interface StringArray {
    [index: number]: string;
}

let arr: StringArray = ['a', 'b', 'c'];

// Interface for functions
interface SearchFunc {
    (source: string, subString: string): boolean;
}

const search: SearchFunc = (source, subString) => {
    return source.indexOf(subString) > -1;
};

// Intersection types - combine multiple types
interface Printable {
    print(): void;
}

interface Nameable {
    getName(): string;
}

type PrintableNameable = Printable & Nameable;
          </code></pre>

          </section>

          <section id="classes" class="section">
            <h2>Classes & Inheritance</h2>
          <pre><code>
// Basic class
class Animal {
    private name: string;              // Private - only in class
    protected age: number;             // Protected - in class & subclasses
    public species: string;            // Public - anywhere

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    private getAge(): number {
        return this.age;
    }

    public getName(): string {
        return this.name;
    }

    // Static members
    static species = 'Unknown';
    static getSpecies() {
        return this.species;
    }
}

// Inheritance
class Dog extends Animal {
    constructor(name: string, age: number) {
        super(name, age);
    }

    bark(): void {
        console.log('Woof!');
    }

    // Override method
    getName(): string {
        return 'Dog: ' + super.getName();
    }
}

// Abstract class - cannot be instantiated
abstract class Shape {
    abstract getArea(): number;

    printArea(): void {
        console.log('Area: ' + this.getArea());
    }
}

class Circle extends Shape {
    constructor(private radius: number) {
        super();
    }

    getArea(): number {
        return Math.PI * this.radius ** 2;
    }
}

// Getters and setters
class Rectangle {
    private _width: number = 0;

    get width(): number {
        return this._width;
    }

    set width(value: number) {
        if (value <= 0) {
            throw new Error('Width must be positive');
        }
        this._width = value;
    }
}
          </code></pre>

          </section>

          <section id="generics" class="section">
            <h2>Generics - Reusable Components</h2>
          <pre><code>
// Generic function
function identity<T>(arg: T): T {
    return arg;
}

let result = identity<string>('hello');   // Type: string
let result2 = identity(42);               // Type inferred as number

// Generic with multiple types
function swap<T, U>(tuple: [T, U]): [U, T] {
    return [tuple[1], tuple[0]];
}

const result = swap<string, number>(['hello', 5]);  // [5, 'hello']

// Generic constraints
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

const person = { name: 'John', age: 30 };
let name = getProperty(person, 'name');    // OK
// getProperty(person, 'email');           // Error - 'email' not in person

// Generic classes
class GenericRepository<T> {
    private items: T[] = [];

    add(item: T): void {
        this.items.push(item);
    }

    getAll(): T[] {
        return this.items;
    }

    getById(index: number): T {
        return this.items[index];
    }
}

interface User {
    id: number;
    name: string;
}

const userRepo = new GenericRepository<User>();
userRepo.add({ id: 1, name: 'John' });

// Generic interfaces
interface Pair<T, U> {
    first: T;
    second: U;
}

const pair: Pair<string, number> = {
    first: 'hello',
    second: 42
};

// Keyof operator
function printProperty<T, K extends keyof T>(obj: T, key: K): void {
    console.log(obj[key]);
}
          </code></pre>

          </section>

          <section id="advanced-types" class="section">
            <h2>Advanced Types</h2>
          <pre><code>
// Mapped types - transform existing types
interface User {
    id: number;
    name: string;
    email: string;
}

// Make all properties optional
type Partial<T> = {
    [K in keyof T]?: T[K];
};

type OptionalUser = Partial<User>;

// Make all properties readonly
type Readonly<T> = {
    readonly [K in keyof T]: T[K];
};

type ReadonlyUser = Readonly<User>;

// Pick - select specific properties
type UserPreview = Pick<User, 'id' | 'name'>;

// Record - object with specified keys
type Roles = 'admin' | 'user' | 'guest';
type RolePermissions = Record<Roles, string[]>;

const permissions: RolePermissions = {
    admin: ['read', 'write', 'delete'],
    user: ['read', 'write'],
    guest: ['read']
};

// Exclude - exclude types from union
type Everything = string | number | boolean;
type NoBoolean = Exclude<Everything, boolean>;  // string | number

// Extract - extract types from union
type Extracted = Extract<Everything, string | number>;  // string | number

// Conditional types
type IsString<T> = T extends string ? true : false;

type A = IsString<'hello'>;      // true
type B = IsString<number>;       // false

// Infer keyword
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getValue(): string {
    return 'value';
}

type Result = ReturnType<typeof getValue>;  // string
          </code></pre>

          </section>

          <section id="decorators" class="section">
            <h2>Decorators (Experimental)</h2>
          <pre><code>
// Class decorator
function Log(target: Function) {
    console.log('Class created:', target.name);
}

@Log
class User {
    constructor(public name: string) {}
}

// Method decorator
function Timer(target: any, key: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;

    descriptor.value = function(...args: any[]) {
        console.time(key);
        const result = original.apply(this, args);
        console.timeEnd(key);
        return result;
    };

    return descriptor;
}

class Calculator {
    @Timer
    expensiveOperation() {
        let sum = 0;
        for (let i = 0; i < 1000000; i++) {
            sum += i;
        }
        return sum;
    }
}

// Property decorator
function Validate(target: any, key: string) {
    let value = target[key];

    Object.defineProperty(target, key, {
        get: () => value,
        set: (newValue) => {
            if (typeof newValue !== 'string') {
                throw new Error(`${key} must be a string`);
            }
            value = newValue;
        }
    });
}

class Person {
    @Validate
    name: string = '';
}
          </code></pre>

          </section>

          <section id="utility-types" class="section">
            <h2>Utility Types (Built-in)</h2>
          <pre><code>
interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// Partial<T> - make all properties optional
type PartialUser = Partial<User>;

// Required<T> - make all properties required
type RequiredUser = Required<PartialUser>;

// Readonly<T> - make all properties readonly
type ReadonlyUser = Readonly<User>;

// Pick<T, K> - select properties
type UserPreview = Pick<User, 'id' | 'name'>;

// Omit<T, K> - exclude properties
type UserWithoutEmail = Omit<User, 'email'>;

// Record<K, T> - map keys to type
type Roles = 'admin' | 'user';
type RoleConfig = Record<Roles, { permissions: string[] }>;

// Exclude<T, U> - exclude type from union
type Result = Exclude<'a' | 'b' | 'c', 'b'>;  // 'a' | 'c'

// Extract<T, U> - extract matching type from union
type OnlyStrings = Extract<string | number | boolean, string>;

// NonNullable<T> - remove null and undefined
type NonNull = NonNullable<string | null | undefined>;  // string

// Parameters<T> - get function parameters as tuple
type Params = Parameters<(a: string, b: number) => void>;  // [string, number]

// ReturnType<T> - get function return type
type Return = ReturnType<() => string>;  // string

// InstanceType<T> - get instance type of constructor
type Instance = InstanceType<typeof User>;  // User
          </code></pre>

          </section>

          <section id="type-narrowing" class="section">
            <h2>Type Narrowing</h2>
          <pre><code>
// typeof guard
function processValue(value: string | number) {
    if (typeof value === 'string') {
        console.log(value.toUpperCase());
    } else {
        console.log(value.toFixed(2));
    }
}

// instanceof guard
class Cat {
    meow() {}
}

class Dog {
    bark() {}
}

function makeSound(animal: Cat | Dog) {
    if (animal instanceof Cat) {
        animal.meow();
    } else {
        animal.bark();
    }
}

// Discriminated unions (tagged unions)
interface Success {
    status: 'success';
    data: string;
}

interface Error {
    status: 'error';
    error: string;
}

type Result = Success | Error;

function handle(result: Result) {
    if (result.status === 'success') {
        console.log(result.data);
    } else {
        console.log(result.error);
    }
}

// User-defined type guard
function isUser(obj: any): obj is User {
    return obj && typeof obj === 'object' && 'id' in obj && 'name' in obj;
}

function processUser(data: unknown) {
    if (isUser(data)) {
        console.log(data.name);
    }
}

// Optional chaining and nullish coalescing
const user: User | null = null;
const name = user?.name;                    // undefined
const defaultName = user?.name ?? 'Guest';  // 'Guest'
          </code></pre>

          </section>

          <section id="modules" class="section">
            <h2>Modules & Namespaces</h2>
          <pre><code>
// Exporting
export interface User {
    id: number;
    name: string;
}

export class UserService {
    getUser(id: number): User {
        return { id, name: 'John' };
    }
}

// Default export
export default class AppService {
    run() {}
}

// Importing
import UserService, { User } from './user.service';
import * as UserModule from './user.service';

const service = new UserService();
const user: User = service.getUser(1);

// Namespaces (less common, use modules)
namespace Utilities {
    export function log(msg: string) {
        console.log(msg);
    }
}

Utilities.log('Hello');
          </code></pre>

          </section>

          <section id="enums" class="section">
            <h2>Enum Types</h2>
          <pre><code>
// Numeric enum
enum Direction {
    Up = 1,
    Down = 2,
    Left = 3,
    Right = 4
}

// String enum
enum Status {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Pending = 'PENDING'
}

// Heterogeneous enum (mix of string and number)
enum Response {
    No = 0,
    Yes = 'YES'
}

// Const enum (optimized away at compile time)
const enum Color {
    Red,
    Green,
    Blue
}

// Using enums
let direction: Direction = Direction.Up;
let status: Status = Status.Active;

function processStatus(status: Status) {
    if (status === Status.Active) {
        console.log('Active');
    }
}
          </code></pre>

          </section>

          <section id="async" class="section">
            <h2>Async/Await & Promises</h2>
          <pre><code>
// Promise types
function fetchUser(id: number): Promise<User> {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve({ id, name: 'John' });
        }, 1000);
    });
}

// Async/await
async function getUser(id: number): Promise<User> {
    try {
        const response = await fetch(`/api/users/${id}`);
        const user: User = await response.json();
        return user;
    } catch (error) {
        console.error(error);
        throw error;
    }
}

// Generic Promise wrapper
async function handleOperation<T>(
    promise: Promise<T>,
    timeout: number = 5000
): Promise<T | null> {
    try {
        return await Promise.race([
            promise,
            new Promise<T>((_, reject) =>
                setTimeout(() => reject(new Error('Timeout')), timeout)
            )
        ]);
    } catch (error) {
        console.error(error);
        return null;
    }
}
          </code></pre>

          </section>

          <section id="configuration" class="section">
            <h2>Configuration (tsconfig.json)</h2>
          <pre><code>
// Common compiler options
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "ESNext",
        "lib": ["ES2020", "DOM"],
        "jsx": "react-jsx",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "strictBindCallApply": true,
        "strictPropertyInitialization": true,
        "noImplicitThis": true,
        "alwaysStrict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
}
          </code></pre>

          </section>

          <section id="interview" class="section">
            <h2>Common Interview Problems</h2>
          <ul>
              <li><strong>Type vs Interface:</strong> When to use each</li>
              <li><strong>Generic Constraints:</strong> Using extends keyword</li>
              <li><strong>keyof & typeof:</strong> Getting types from values</li>
              <li><strong>Conditional Types:</strong> Type-level programming</li>
              <li><strong>Utility Types:</strong> Partial, Pick, Record, etc.</li>
              <li><strong>Discriminated Unions:</strong> Type-safe error handling</li>
              <li><strong>Module Resolution:</strong> Imports and exports</li>
              <li><strong>Type Narrowing:</strong> Guards and assertions</li>
          </ul>

          </section>

          <section id="best-practices" class="section">
            <h2>Best Practices</h2>
          <ul>
              <li>Enable strict mode in tsconfig.json</li>
              <li>Use interfaces for public API contracts</li>
              <li>Use types for unions and complex structures</li>
              <li>Avoid any - use unknown instead</li>
              <li>Use const assertions for literal types</li>
              <li>Prefer type guards over type assertions</li>
              <li>Document complex types with comments</li>
              <li>Use meaningful names for generics (not just T, U, V)</li>
              <li>Keep functions small and focused</li>
              <li>Use readonly for immutable data</li>
          </ul>

            <h3>TypeScript vs JavaScript:</h3>
            <ul>
                <li><strong>Type Safety:</strong> Catch errors at compile-time</li>
                <li><strong>Better IDE Support:</strong> Autocomplete and refactoring</li>
                <li><strong>Self-Documenting:</strong> Types serve as documentation</li>
                <li><strong>Interfaces:</strong> Define contracts between code</li>
                <li><strong>Compilation Step:</strong> Adds build complexity</li>
                <li><strong>Learning Curve:</strong> More concepts to understand</li>
            </ul>

            <h3>Key Interview Questions:</h3>
            <ul>
                <li>What's the difference between type and interface?</li>
                <li>Explain generic constraints and their use cases</li>
                <li>What are utility types and provide examples</li>
                <li>How does TypeScript handle type narrowing?</li>
                <li>What is the keyof operator used for?</li>
                <li>Explain conditional types and infer keyword</li>
                <li>How do mapped types work?</li>
                <li>What's the difference between any and unknown?</li>
                <li>How to use decorators in TypeScript?</li>
                <li>What are discriminated unions and their benefits?</li>
            </ul>
          </section>
          </div>
        </div>
      </div>
    </div>
      <script src="footer.js"></script>
</body>
</html>
