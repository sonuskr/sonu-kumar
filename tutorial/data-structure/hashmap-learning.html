<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>HashMap Data Structure - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
</head>
<body class="page-hashmap">
    <header>
        <div class="container">
            <div class="hero">
                <h1>HashMap Data Structure</h1>
                <p>Master HashMap Operations & Hash Algorithms</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = "datastructure";</script>
    <script src="../menu.js"></script>
    <script src="../theme-selector.js"></script>    <div class="container">
      <div class="content-with-sidebar">
        <div class="sidebar-toc">
          <div class="toc-header">
            <h2>ðŸ“š Table of Contents</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#what-is-hashmap">What is HashMap?</a></li>
              <li><a href="#key-concepts">Key Concepts</a></li>
              <li><a href="#comparison">HashMap vs HashTable</a></li>
              <li><a href="#basic-operations">Basic Operations</a></li>
              <li><a href="#hash-function">Hash Function</a></li>
              <li><a href="#collision-resolution">Collision Resolution</a></li>
              <li><a href="#interview-problems">Interview Problems</a></li>
              <li><a href="#time-complexity">Time & Space Complexity</a></li>
              <li><a href="#two-sum">Two Sum Example</a></li>
              <li><a href="#group-anagrams">Group Anagrams</a></li>
              <li><a href="#advantages">Pros & Cons</a></li>
              <li><a href="#applications">Applications</a></li>
              <li><a href="#interview-questions">Interview Questions</a></li>
            </ul>
          </nav>
        </div>
        <div class="main-content">
          <div class="topic">
            <h1>HashMap - Complete Guide</h1>
          
          <section id="what-is-hashmap" class="section">
            <h2>What is a HashMap?</h2>
          <p>HashMap is a data structure that implements a hash table - a structure that maps keys to values using a hash function. It provides O(1) average case access time for get and put operations.</p>
          
          </section>

          <section id="key-concepts" class="section">
            <h2>Key Concepts</h2>
          <ul>
            <li><strong>Hash Function:</strong> Maps keys to array indices</li>
            <li><strong>Collision:</strong> When two keys hash to same index</li>
            <li><strong>Load Factor:</strong> Ratio of entries to capacity (default 0.75)</li>
            <li><strong>Rehashing:</strong> Creating larger table when load factor exceeded</li>
            <li><strong>Bucket:</strong> Array position containing key-value pairs</li>
            <li><strong>Chaining:</strong> Linked list in bucket for collision handling</li>
          </ul>

          </section>

          <section id="comparison" class="section">
            <h2>HashMap vs HashTable vs ConcurrentHashMap</h2>
          <table>
            <tr>
              <th>Feature</th>
              <th>HashMap</th>
              <th>HashTable</th>
              <th>ConcurrentHashMap</th>
            </tr>
            <tr>
              <td>Thread Safe</td>
              <td>No</td>
              <td>Yes (Legacy)</td>
              <td>Yes (Segment Lock)</td>
            </tr>
            <tr>
              <td>Null Key/Value</td>
              <td>Allowed</td>
              <td>Not Allowed</td>
              <td>Not Allowed</td>
            </tr>
            <tr>
              <td>Performance</td>
              <td>Fast</td>
              <td>Slow</td>
              <td>Fast (Multi-thread)</td>
            </tr>
            <tr>
              <td>Iteration</td>
              <td>Fail-fast</td>
              <td>Fail-fast</td>
              <td>Weakly Consistent</td>
            </tr>
          </table>

          </section>

          <section id="basic-operations" class="section">
            <h2>Basic HashMap Operations</h2>
          <pre><code>
Map<String, Integer> map = new HashMap<>();

// put() - O(1) average
map.put("apple", 5);
map.put("banana", 3);

// get() - O(1) average
Integer value = map.get("apple");  // Returns 5
Integer missing = map.get("orange");  // Returns null

// containsKey() - O(1) average
if (map.containsKey("apple")) {
    System.out.println("Found");
}

// remove() - O(1) average
map.remove("banana");

// size() - O(1)
int size = map.size();

// Iteration
for (String key : map.keySet()) {
    System.out.println(key + ": " + map.get(key));
}

for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
          </code></pre>

          </section>

          <section id="hash-function" class="section">
            <h2>Hash Function Implementation</h2>
          <pre><code>
class SimpleHashMap<K, V> {
    private static final int CAPACITY = 16;
    private Entry<K, V>[] table;
    private int size;
    
    @SuppressWarnings("unchecked")
    public SimpleHashMap() {
        table = new Entry[CAPACITY];
        size = 0;
    }
    
    private int hash(K key) {
        if (key == null) return 0;
        return Math.abs(key.hashCode()) % CAPACITY;
    }
    
    public void put(K key, V value) {
        if (size > CAPACITY * 0.75) {
            rehash();  // Resize when load factor exceeded
        }
        
        int index = hash(key);
        Entry<K, V> entry = table[index];
        
        // Chaining: traverse linked list for collision
        while (entry != null) {
            if ((entry.key == null && key == null) || 
                (entry.key != null && entry.key.equals(key))) {
                entry.value = value;  // Update existing
                return;
            }
            entry = entry.next;
        }
        
        // Add new entry at head
        Entry<K, V> newEntry = new Entry<>(key, value);
        newEntry.next = table[index];
        table[index] = newEntry;
        size++;
    }
    
    public V get(K key) {
        int index = hash(key);
        Entry<K, V> entry = table[index];
        
        while (entry != null) {
            if ((entry.key == null && key == null) || 
                (entry.key != null && entry.key.equals(key))) {
                return entry.value;
            }
            entry = entry.next;
        }
        return null;
    }
    
    @SuppressWarnings("unchecked")
    private void rehash() {
        Entry<K, V>[] oldTable = table;
        CAPACITY = CAPACITY * 2;
        table = new Entry[CAPACITY];
        size = 0;
        
        for (Entry<K, V> entry : oldTable) {
            while (entry != null) {
                put(entry.key, entry.value);
                entry = entry.next;
            }
        }
    }
    
    static class Entry<K, V> {
        K key;
        V value;
        Entry<K, V> next;
        
        Entry(K key, V value) {
            this.key = key;
            this.value = value;
        }
    }
}
          </code></pre>

          </section>

          <section id="collision-resolution" class="section">
            <h2>Collision Resolution Strategies</h2>
          <pre><code>
// 1. Chaining (Java HashMaps default)
// Multiple entries in same bucket using linked list
// Lookup: O(1) average, O(n) worst case

// 2. Open Addressing with Linear Probing
public void put_linear(K key, V value) {
    int index = hash(key);
    
    while (table[index] != null && 
           !table[index].key.equals(key)) {
        index = (index + 1) % CAPACITY;  // Move to next
    }
    table[index] = new Entry(key, value);
}

// 3. Quadratic Probing
public void put_quadratic(K key, V value) {
    int index = hash(key);
    int i = 1;
    
    while (table[index] != null && 
           !table[index].key.equals(key)) {
        index = (hash(key) + i * i) % CAPACITY;
        i++;
    }
    table[index] = new Entry(key, value);
}

// 4. Double Hashing
public void put_double(K key, V value) {
    int index = hash(key);
    int stepSize = 7 - (hash(key) % 7);  // Secondary hash
    
    while (table[index] != null && 
           !table[index].key.equals(key)) {
        index = (index + stepSize) % CAPACITY;
    }
    table[index] = new Entry(key, value);
}
          </code></pre>

          </section>

          <section id="interview-problems" class="section">
            <h2>Common Interview Problems</h2>
          <ul>
            <li><strong>Two Sum:</strong> Find pair of numbers with target sum</li>
            <li><strong>Contains Duplicate:</strong> Check if array has duplicates</li>
            <li><strong>Group Anagrams:</strong> Group words that are anagrams</li>
            <li><strong>Valid Anagram:</strong> Check if two strings are anagrams</li>
            <li><strong>Majority Element:</strong> Find element appearing more than n/2 times</li>
            <li><strong>LRU Cache:</strong> Implement cache with eviction policy</li>
            <li><strong>Isomorphic Strings:</strong> Check pattern matching between strings</li>
            <li><strong>Word Pattern:</strong> Verify if pattern matches string</li>
          </ul>

          </section>

          <section id="time-complexity" class="section">
            <h2>Time & Space Complexity</h2>
          <table>
            <tr>
              <th>Operation</th>
              <th>Average</th>
              <th>Worst Case</th>
              <th>Notes</th>
            </tr>
            <tr>
              <td>put()</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>With chaining, if all hash to same</td>
            </tr>
            <tr>
              <td>get()</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>Depends on chain length</td>
            </tr>
            <tr>
              <td>remove()</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>Same as get</td>
            </tr>
            <tr>
              <td>containsKey()</td>
              <td>O(1)</td>
              <td>O(n)</td>
              <td>Same as get</td>
            </tr>
            <tr>
              <td>Space</td>
              <td>O(n)</td>
              <td>O(n)</td>
              <td>Where n is number of entries</td>
            </tr>
          </table>

          </section>

          <section id="two-sum" class="section">
            <h2>Example - Two Sum Problem</h2>
          <pre><code>
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        
        map.put(nums[i], i);
    }
    
    return null;
}

// Time: O(n), Space: O(n)
          </code></pre>

          </section>

          <section id="group-anagrams" class="section">
            <h2>Example - Group Anagrams</h2>
          <pre><code>
public List<List<String>> groupAnagrams(String[] strs) {
    Map<String, List<String>> map = new HashMap<>();
    
    for (String str : strs) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        String key = new String(chars);
        
        map.putIfAbsent(key, new ArrayList<>());
        map.get(key).add(str);
    }
    
    return new ArrayList<>(map.values());
}

// Input: ["eat", "tea", "ate", "nat", "tan", "bat"]
// Output: [["eat","tea","ate"], ["nat","tan"], ["bat"]]
// Time: O(n*k*logk), Space: O(n*k)
          </code></pre>

          </section>

          <section id="advantages" class="section">
            <h2>Advantages & Disadvantages</h2>
          <p><strong>Advantages:</strong></p>
          <ul>
            <li>O(1) average time for basic operations</li>
            <li>Flexible key-value mapping</li>
            <li>Handles null keys and values (HashMap)</li>
            <li>Simple and intuitive to use</li>
          </ul>
          <p><strong>Disadvantages:</strong></p>
          <ul>
            <li>O(n) worst case for operations</li>
            <li>Extra space for hash table</li>
            <li>Not ordered (use LinkedHashMap for order)</li>
            <li>Hash collisions possible</li>
            <li>Not thread-safe (use ConcurrentHashMap)</li>
          </ul>

          </section>

          <section id="applications" class="section">
            <h2>Real-world Applications</h2>
          <ul>
            <li>Caching and memoization</li>
            <li>Database indexing</li>
            <li>Counting frequencies</li>
            <li>Symbol tables in compilers</li>
            <li>URL mapping in web servers</li>
            <li>Deduplication</li>
            <li>Session storage</li>
          </ul>

          </section>

          <section id="interview-questions" class="section">
            <h2>Key Interview Questions</h2>
            <ul>
              <li>How does HashMap handle hash collisions?</li>
              <li>Why is load factor important? When to rehash?</li>
              <li>What's the difference between HashMap and HashTable?</li>
              <li>Can you explain the hash function and its properties?</li>
              <li>What's time complexity of get/put in worst case?</li>
              <li>How would you implement a custom HashMap?</li>
              <li>When would you use TreeMap over HashMap?</li>
            </ul>
          </section>
          </div>
        </div>
      </div>
    </div>
    <footer>
        <div class="container">
            <p>&copy; 2025 Sonu Kumar - Senior Full Stack Developer | Java Spring Boot Angular React Expert | Available for remote work, enterprise consulting, and full-time opportunities | Contact: <a href="mailto:skrdeveloper1@gmail.com">skrdeveloper1@gmail.com</a> | LinkedIn: <a href="https://www.linkedin.com/in/sonuskr">linkedin.com/in/sonuskr</a></p>
        </div>
    </footer>
</body>
</html>