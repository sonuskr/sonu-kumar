<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Graph Data Structure - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
  </head>
  <body class="page-graph">
    <header>
      <div class="container">
        <div class="hero">
          <h1>Graph Data Structure</h1>
          <p>Master Graph Operations & Network Algorithms</p>
        </div>
      </div>
    </header>
    <nav></nav>
    <script>window.activePage = "datastructure";</script>
    <script src="../menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            updateActiveNav();
        });
        
        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.toc-nav a');
            
            let currentSection = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentSection = section.id;
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateActiveNav);
        updateActiveNav();
    </script>
      <div class="content-with-sidebar">
        <div class="sidebar-toc">
          <div class="toc-header">
            <h2>ðŸ“š Table of Contents</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#what-is-graph">What is Graph?</a></li>
              <li><a href="#terminology">Graph Terminology</a></li>
              <li><a href="#types">Types of Graphs</a></li>
              <li><a href="#representations">Graph Representations</a></li>
              <li><a href="#bfs">BFS Traversal</a></li>
              <li><a href="#dfs">DFS Traversal</a></li>
              <li><a href="#dijkstra">Dijkstra's Algorithm</a></li>
              <li><a href="#bfs-shortest">BFS Shortest Path</a></li>
              <li><a href="#topological">Topological Sorting</a></li>
              <li><a href="#cycle-detection">Cycle Detection</a></li>
              <li><a href="#interview-problems">Interview Problems</a></li>
              <li><a href="#time-complexity">Time Complexity</a></li>
              <li><a href="#applications">Applications</a></li>
              <li><a href="#advantages">Pros & Cons</a></li>
            </ul>
          </nav>
        </div>
        <div class="main-content">
          <div class="topic">
            <h1>Graph - Complete Guide</h1>
          
          <section id="what-is-graph" class="section">
            <h2>What is a Graph?</h2>
          <p>A graph is a non-linear data structure consisting of vertices (nodes) connected by edges. Used to represent networks, relationships, and complex structures.</p>
          
          </section>

          <section id="terminology" class="section">
            <h2>Graph Terminology</h2>
          <ul>
            <li><strong>Vertex/Node:</strong> A point in the graph</li>
            <li><strong>Edge:</strong> Connection between two vertices</li>
            <li><strong>Degree:</strong> Number of edges connected to a vertex</li>
            <li><strong>Path:</strong> Sequence of vertices from one to another</li>
            <li><strong>Cycle:</strong> Path that starts and ends at same vertex</li>
            <li><strong>Connected Graph:</strong> Path exists between every pair of vertices</li>
          </ul>

          </section>

          <section id="types" class="section">
            <h2>Types of Graphs</h2>
          <ul>
            <li><strong>Directed Graph:</strong> Edges have direction (Aâ†’B)</li>
            <li><strong>Undirected Graph:</strong> Edges have no direction</li>
            <li><strong>Weighted Graph:</strong> Edges have weights</li>
            <li><strong>DAG:</strong> Directed Acyclic Graph (no cycles)</li>
            <li><strong>Bipartite:</strong> Vertices can be divided into two sets</li>
          </ul>

          </section>

          <section id="representations" class="section">
            <h2>Graph Representations</h2>
          <pre><code>
// 1. Adjacency Matrix (O(1) edge lookup)
int[][] graph = new int[n][n];
// graph[i][j] = 1 means edge from i to j
// Problem: O(nÂ²) space

// 2. Adjacency List (O(V+E) space)
List<Integer>[] graph = new ArrayList[n];
for (int i = 0; i < n; i++) {
    graph[i] = new ArrayList<>();
}
graph[0].add(1);  // Edge from 0 to 1
graph[1].add(2);  // Edge from 1 to 2

// 3. Weighted Graph with Pairs
class Edge {
    int dest;
    int weight;
    Edge(int dest, int weight) {
        this.dest = dest;
        this.weight = weight;
    }
}
List<Edge>[] graph = new ArrayList[n];
          </code></pre>

          </section>

          <section id="bfs" class="section">
            <h2>Graph Traversal - BFS (Breadth-First Search)</h2>
          <pre><code>
public void bfs(int start, List<Integer>[] graph) {
    boolean[] visited = new boolean[graph.length];
    Queue<Integer> queue = new LinkedList<>();
    
    queue.add(start);
    visited[start] = true;
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        System.out.println(node);
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.add(neighbor);
            }
        }
    }
}
          </code></pre>

          </section>

          <section id="dfs" class="section">
            <h2>Graph Traversal - DFS (Depth-First Search)</h2>
          <pre><code>
public void dfs(int node, List<Integer>[] graph, boolean[] visited) {
    visited[node] = true;
    System.out.println(node);
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited);
        }
    }
}

// Call DFS
boolean[] visited = new boolean[n];
dfs(0, graph, visited);
          </code></pre>

          </section>

          <section id="dijkstra" class="section">
            <h2>Shortest Path - Dijkstra's Algorithm</h2>
          <pre><code>
public int[] dijkstra(int[][] graph, int start) {
    int n = graph.length;
    int[] dist = new int[n];
    boolean[] visited = new boolean[n];
    
    for (int i = 0; i < n; i++) {
        dist[i] = Integer.MAX_VALUE;
    }
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        int u = -1;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {
                u = j;
            }
        }
        
        visited[u] = true;
        
        for (int v = 0; v < n; v++) {
            if (graph[u][v] != 0) {
                dist[v] = Math.min(dist[v], dist[u] + graph[u][v]);
            }
        }
    }
    return dist;
}
          </code></pre>

          </section>

          <section id="bfs-shortest" class="section">
            <h2>Shortest Path - BFS (Unweighted)</h2>
          <pre><code>
public int[] bfsShortestPath(List<Integer>[] graph, int start) {
    int n = graph.length;
    int[] distance = new int[n];
    boolean[] visited = new boolean[n];
    Queue<Integer> queue = new LinkedList<>();
    
    for (int i = 0; i < n; i++) {
        distance[i] = Integer.MAX_VALUE;
    }
    
    distance[start] = 0;
    visited[start] = true;
    queue.add(start);
    
    while (!queue.isEmpty()) {
        int node = queue.poll();
        
        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                distance[neighbor] = distance[node] + 1;
                queue.add(neighbor);
            }
        }
    }
    return distance;
}
          </code></pre>

          </section>

          <section id="topological" class="section">
            <h2>Topological Sorting (for DAG)</h2>
          <pre><code>
public List<Integer> topologicalSort(List<Integer>[] graph) {
    int n = graph.length;
    boolean[] visited = new boolean[n];
    Stack<Integer> stack = new Stack<>();
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i, graph, visited, stack);
        }
    }
    
    List<Integer> result = new ArrayList<>();
    while (!stack.isEmpty()) {
        result.add(stack.pop());
    }
    return result;
}

private void dfs(int node, List<Integer>[] graph, 
                 boolean[] visited, Stack<Integer> stack) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, graph, visited, stack);
        }
    }
    stack.push(node);
}
          </code></pre>

          </section>

          <section id="cycle-detection" class="section">
            <h2>Detect Cycle in Graph</h2>
          <pre><code>
// Undirected Graph
public boolean hasCycle(List<Integer>[] graph) {
    boolean[] visited = new boolean[graph.length];
    
    for (int i = 0; i < graph.length; i++) {
        if (!visited[i]) {
            if (dfsCycle(i, -1, graph, visited)) {
                return true;
            }
        }
    }
    return false;
}

private boolean dfsCycle(int node, int parent, 
                         List<Integer>[] graph, boolean[] visited) {
    visited[node] = true;
    
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            if (dfsCycle(neighbor, node, graph, visited)) {
                return true;
            }
        } else if (neighbor != parent) {
            return true;  // Found cycle
        }
    }
    return false;
}
          </code></pre>

          </section>

          <section id="interview-problems" class="section">
            <h2>Common Interview Problems</h2>
          <ul>
            <li><strong>Number of Islands:</strong> Count connected components</li>
            <li><strong>Bipartite Graph:</strong> Check if graph is bipartite</li>
            <li><strong>Course Schedule:</strong> Topological sort variant</li>
            <li><strong>Alien Dictionary:</strong> Order by given rules</li>
            <li><strong>Word Ladder:</strong> Shortest path with transformations</li>
            <li><strong>Network Delay Time:</strong> Dijkstra's algorithm</li>
            <li><strong>Critical Connections:</strong> Find bridges in graph</li>
          </ul>

          </section>

          <section id="time-complexity" class="section">
            <h2>Time Complexity Comparison</h2>
          <ul>
            <li><strong>BFS:</strong> O(V + E) - Visit each vertex and edge once</li>
            <li><strong>DFS:</strong> O(V + E) - Visit each vertex and edge once</li>
            <li><strong>Dijkstra:</strong> O(VÂ²) with matrix, O((V+E)logV) with heap</li>
            <li><strong>Topological Sort:</strong> O(V + E)</li>
            <li><strong>Cycle Detection:</strong> O(V + E)</li>
          </ul>

          </section>

          <section id="applications" class="section">
            <h2>Real-world Applications</h2>
          <ul>
            <li>Social Networks (connections between people)</li>
            <li>Google Maps (routing, shortest path)</li>
            <li>Flight Networks (connections between airports)</li>
            <li>Computer Networks (routing protocols)</li>
            <li>Recommendation Systems</li>
            <li>Web Crawling (link relationships)</li>
            <li>Compiler Design (dependency resolution)</li>
          </ul>

          </section>

          <section id="advantages" class="section">
            <h2>Advantages & Disadvantages</h2>
            <p><strong>Advantages:</strong></p>
            <ul>
              <li>Represents complex relationships</li>
              <li>Highly versatile</li>
              <li>Efficient for network problems</li>
            </ul>
            <p><strong>Disadvantages:</strong></p>
            <ul>
              <li>Can be complex to implement</li>
              <li>Memory intensive for dense graphs</li>
              <li>Traversal can be expensive for large graphs</li>
            </ul>
          </section>
          </div>
        </div>
      </div>
    </div>
      <script src="../footer.js"></script>
</body>
</html>
