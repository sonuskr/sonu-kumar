<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Spring Boot Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
</head>
<body class="page-spring-boot">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Spring Boot Learning Tutorial</h1>
                <p>Master Spring Boot Microservices</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'spring';</script>
    <script src="../menu.js"></script>
    <script src="../theme-selector.js"></script>
    
    <div class="breadcrumb">
        <div class="container">
            <ol>
                <li><a href="../tutorial-index.html">Home</a></li>
                <li><a href="../tutorial-index.html#spring">Spring</a></li>
                <li>Spring Boot</li>
            </ol>
        </div>
    </div>
    
    <div class="container">
        <div class="content-with-sidebar">
            <div class="sidebar-toc">
                <div class="toc-header">
                    <h2>ðŸ“š Table of Contents</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#what-is-spring-boot">What is Spring Boot?</a></li>
                        <li><a href="#evolution">Spring Boot Evolution</a></li>
                        <li><a href="#project-setup">Project Setup</a></li>
                        <li><a href="#main-application">Main Application Class</a></li>
                        <li><a href="#rest-controllers">REST Controllers</a></li>
                        <li><a href="#jpa-data">JPA & Data Access</a></li>
                        <li><a href="#dependency-injection">Dependency Injection</a></li>
                        <li><a href="#configuration">Configuration & Properties</a></li>
                        <li><a href="#exception-handling">Exception Handling</a></li>
                        <li><a href="#validation">Validation</a></li>
                        <li><a href="#transactions">Transactions</a></li>
                        <li><a href="#caching">Caching</a></li>
                        <li><a href="#async-scheduling">Async & Scheduling</a></li>
                        <li><a href="#testing">Testing</a></li>
                        <li><a href="#interview-topics">Interview Topics</a></li>
                        <li><a href="#microservices">Microservices Patterns</a></li>
                    </ul>
                </nav>
            </div>
            <div class="main-content">
                <div class="topic">
                    <h1>Spring Boot - Complete Guide</h1>
                
                <section id="what-is-spring-boot" class="section">
                    <h2>What is Spring Boot?</h2>
                <p>Spring Boot is an opinionated framework that simplifies Spring application development. It provides auto-configuration, embedded servers, and production-ready features out of the box. Spring Boot 3+ uses Java 17+ and supports the latest technologies for building microservices, REST APIs, and enterprise applications.</p>
                
                </section>

                <section id="evolution" class="section">
                    <h2>Spring Boot Evolution</h2>
                <ul>
                    <li><strong>Spring Boot 1.x:</strong> Foundation (2014)</li>
                    <li><strong>Spring Boot 2.x:</strong> Java 11+ support, reactive programming</li>
                    <li><strong>Spring Boot 3.0:</strong> Java 17+, GraalVM native image, Jakarta EE</li>
                    <li><strong>Spring Boot 3.2+:</strong> Enhanced observability, improved performance</li>
                </ul>

                </section>

                <section id="project-setup" class="section">
                    <h2>Project Setup (Maven/Gradle)</h2>
                <pre><code>
// Maven - pom.xml
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;3.2.0&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.h2database&lt;/groupId&gt;
        &lt;artifactId&gt;h2&lt;/artifactId&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

// Gradle - build.gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
}
                </code></pre>

                </section>

                <section id="main-application" class="section">
                    <h2>Main Application Class</h2>
                <pre><code>
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication  // Combines @Configuration, @EnableAutoConfiguration, @ComponentScan
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// Customizing Spring Application
public class Application {
    public static void main(String[] args) {
        SpringApplication app = new SpringApplication(Application.class);
        app.setAdditionalProperties("server.port", "8081");
        app.run(args);
    }
}
                </code></pre>

                </section>

                <section id="rest-controllers" class="section">
                    <h2>REST Controllers</h2>
                <pre><code>
import org.springframework.web.bind.annotation.*;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.findAll();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User created = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(created);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, @RequestBody User user) {
        return userService.update(id, user)
            .map(ResponseEntity::ok)
            .orElseGet(() -> ResponseEntity.notFound().build());
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.delete(id);
        return ResponseEntity.noContent().build();
    }
    
    // Query parameters
    @GetMapping("/search")
    public List<User> searchUsers(@RequestParam String name, @RequestParam(required = false) Integer age) {
        return userService.search(name, age);
    }
    
    // Path variables
    @GetMapping("/department/{deptId}/users/{userId}")
    public User getUserByDepartment(@PathVariable Long deptId, @PathVariable Long userId) {
        return userService.getUserByDepartment(deptId, userId);
    }
}
                </code></pre>

                </section>

                <section id="jpa-data" class="section">
                    <h2>JPA & Data Access</h2>
                <pre><code>
import javax.persistence.*;
import lombok.*;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String username;
    
    @Column(nullable = false)
    private String email;
    
    @Enumerated(EnumType.STRING)
    private UserRole role;
    
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
    
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL)
    private List<Post> posts = new ArrayList<>();
}

// Repository - automatic CRUD + query methods
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    List<User> findByEmailContainingIgnoreCase(String email);
    List<User> findByRoleOrderByUsernameAsc(UserRole role);
    
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmailCustom(@Param("email") String email);
    
    @Query(nativeQuery = true, value = "SELECT * FROM users WHERE department_id = ?1")
    List<User> findByDepartmentNative(Long deptId);
}

// Service layer
@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Transactional(readOnly = true)
    public List<User> findAll() {
        return userRepository.findAll();
    }
    
    @Transactional
    public User save(User user) {
        return userRepository.save(user);
    }
    
    @Transactional
    public void deleteById(Long id) {
        userRepository.deleteById(id);
    }
}
                </code></pre>

                </section>

                <section id="dependency-injection" class="section">
                    <h2>Dependency Injection & Beans</h2>
                <pre><code>
// Bean creation
@Configuration
public class AppConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        return mapper;
    }
}

// Component scanning annotations
@Component          // Generic component
@Service           // Service layer
@Repository        // Data access layer
@Controller        // Web controller
@RestController    // REST API endpoint

// Dependency injection
@Service
public class UserService {
    
    // Constructor injection (preferred)
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    // Field injection (avoid if possible)
    @Autowired
    private UserRepository repo;
    
    // Setter injection
    @Autowired
    public void setRepository(UserRepository repository) {
        this.userRepository = repository;
    }
    
    // Autowiring by type or name
    @Autowired(required = false)  // Optional dependency
    private OptionalComponent component;
    
    // Qualifier - specify which bean to inject
    @Autowired
    @Qualifier("primaryDataSource")
    private DataSource dataSource;
}

// Conditional beans
@Configuration
public class ConditionalBeanConfig {
    
    @Bean
    @ConditionalOnProperty(name = "feature.enabled", havingValue = "true")
    public Feature enabledFeature() {
        return new Feature();
    }
    
    @Bean
    @ConditionalOnMissingBean
    public Service defaultService() {
        return new DefaultService();
    }
}
                </code></pre>

                </section>

                <section id="configuration" class="section">
                    <h2>Configuration & Properties</h2>
                <pre><code>
# application.properties
server.port=8080
server.servlet.context-path=/api
spring.application.name=my-app

# Database
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

# Logging
logging.level.root=INFO
logging.level.com.myapp=DEBUG

# YAML - application.yml
server:
  port: 8080
  servlet:
    context-path: /api

spring:
  application:
    name: my-app
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true

// Configuration class
@Configuration
@ConfigurationProperties(prefix = "app")
@Data
public class AppProperties {
    private String name;
    private String version;
    private Database database;
    
    @Data
    public static class Database {
        private String host;
        private Integer port;
    }
}

// Using configuration
@Component
public class AppRunner {
    @Autowired
    private AppProperties appProperties;
    
    public void run() {
        System.out.println(appProperties.getName());
    }
}
                </code></pre>

                </section>

                <section id="exception-handling" class="section">
                    <h2>Exception Handling</h2>
                <pre><code>
// Custom exception
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}

// Global exception handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            HttpStatus.NOT_FOUND.value(),
            ex.getMessage(),
            LocalDateTime.now()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidation(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
            errors.put(error.getField(), error.getDefaultMessage())
        );
        ErrorResponse response = new ErrorResponse(400, "Validation failed", LocalDateTime.now());
        return ResponseEntity.badRequest().body(response);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        ErrorResponse error = new ErrorResponse(500, "Internal server error", LocalDateTime.now());
        return ResponseEntity.status(500).body(error);
    }
}

@Data
@AllArgsConstructor
public class ErrorResponse {
    private int status;
    private String message;
    private LocalDateTime timestamp;
}
                </code></pre>

                </section>

                <section id="validation" class="section">
                    <h2>Validation</h2>
                <pre><code>
import javax.validation.constraints.*;

@Data
public class UserDTO {
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50)
    private String username;
    
    @Email(message = "Valid email required")
    private String email;
    
    @NotNull
    @Min(18)
    @Max(100)
    private Integer age;
    
    @Pattern(regexp = "^[0-9]{10}$", message = "Phone must be 10 digits")
    private String phone;
}

// Using validation in controller
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody UserDTO dto) {
        // Validation happens automatically
        User user = userService.createFromDTO(dto);
        return ResponseEntity.status(201).body(user);
    }
}

// Custom validation
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueUsernameValidator.class)
public @interface UniqueUsername {
    String message() default "Username already exists";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class UniqueUsernameValidator implements ConstraintValidator<UniqueUsername, String> {
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public boolean isValid(String username, ConstraintValidatorContext context) {
        return userRepository.findByUsername(username).isEmpty();
    }
}
                </code></pre>

                </section>

                <section id="transactions" class="section">
                    <h2>Transactions</h2>
                <pre><code>
@Service
public class UserService {
    
    // Transaction with rollback on exception
    @Transactional
    public User transferUser(Long fromDeptId, Long toDeptId, Long userId) {
        User user = userRepository.findById(userId).orElseThrow();
        
        Department fromDept = departmentRepository.findById(fromDeptId).orElseThrow();
        Department toDept = departmentRepository.findById(toDeptId).orElseThrow();
        
        fromDept.removeUser(user);
        toDept.addUser(user);
        
        userRepository.save(user);
        departmentRepository.save(fromDept);
        departmentRepository.save(toDept);
        
        return user;
    }
    
    // Read-only transaction (optimized)
    @Transactional(readOnly = true)
    public List<User> findActiveUsers() {
        return userRepository.findByActiveTrue();
    }
    
    // Propagation control
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void logAction(String action) {
        // Executes in new transaction
    }
    
    // Isolation levels
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public User getUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
                </code></pre>

                </section>

                <section id="caching" class="section">
                    <h2>Caching</h2>
                <pre><code>
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        return new ConcurrentMapCacheManager("users", "departments");
    }
}

@Service
public class UserService {
    
    @Cacheable(value = "users", key = "#id")
    public User getUser(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    @CachePut(value = "users", key = "#user.id")
    public User updateUser(User user) {
        return userRepository.save(user);
    }
    
    @CacheEvict(value = "users", key = "#id")
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
    
    @CacheEvict(value = "users", allEntries = true)
    public void clearCache() {
        // Clears all entries
    }
}
                </code></pre>

                </section>

                <section id="async-scheduling" class="section">
                    <h2>Async & Scheduling</h2>
                <pre><code>
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setQueueCapacity(100);
        executor.initialize();
        return executor;
    }
}

@Service
public class EmailService {
    
    @Async
    public void sendEmailAsync(String to, String subject, String body) {
        // Runs in thread pool
        System.out.println("Email sent");
    }
    
    @Async("taskExecutor")
    public CompletableFuture<String> processData(String data) {
        // Return result asynchronously
        return CompletableFuture.completedFuture("Processed: " + data);
    }
}

// Scheduling
@Configuration
@EnableScheduling
public class SchedulingConfig {}

@Service
public class ScheduledTasks {
    
    @Scheduled(fixedDelay = 5000)  // 5 seconds delay between executions
    public void reportCurrentTime() {
        System.out.println("Scheduled task running");
    }
    
    @Scheduled(cron = "0 0 * * * *")  // Every hour
    public void cleanupExpiredSessions() {
        // Cleanup logic
    }
    
    @Scheduled(fixedRate = 60000)  // Every 60 seconds
    public void fetchNewData() {
        // Data fetching logic
    }
}
                </code></pre>

                </section>

                <section id="testing" class="section">
                    <h2>Testing</h2>
                <pre><code>
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
public class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private UserRepository userRepository;
    
    @BeforeEach
    public void setup() {
        userRepository.deleteAll();
    }
    
    @Test
    public void testGetAllUsers() throws Exception {
        User user = new User(1L, "john", "john@test.com");
        userRepository.save(user);
        
        mockMvc.perform(get("/api/users"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$[0].username").value("john"));
    }
    
    @Test
    public void testCreateUser() throws Exception {
        UserDTO dto = new UserDTO("jane", "jane@test.com");
        
        mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(dto)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.username").value("jane"));
    }
}

// Unit testing with mocks
@ExtendWith(MockitoExtension.class)
public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    public void testFindUser() {
        User user = new User(1L, "john", "john@test.com");
        when(userRepository.findById(1L)).thenReturn(Optional.of(user));
        
        User result = userService.findById(1L);
        
        assertEquals("john", result.getUsername());
        verify(userRepository, times(1)).findById(1L);
    }
}
                </code></pre>

                </section>

                <section id="interview-topics" class="section">
                    <h2>Common Interview Topics</h2>
                <ul>
                    <li><strong>Auto-Configuration:</strong> How @SpringBootApplication works</li>
                    <li><strong>Starters:</strong> spring-boot-starter-web, spring-boot-starter-data-jpa</li>
                    <li><strong>Embedded Servers:</strong> Tomcat, Jetty, Undertow</li>
                    <li><strong>Actuator:</strong> Health checks, metrics, monitoring</li>
                    <li><strong>Profiles:</strong> dev, test, prod environments</li>
                    <li><strong>Properties:</strong> Externalized configuration</li>
                    <li><strong>Exception Handling:</strong> @ControllerAdvice, @ExceptionHandler</li>
                    <li><strong>Transaction Management:</strong> @Transactional, propagation</li>
                    <li><strong>Testing:</strong> @SpringBootTest, @DataJpaTest, mocking</li>
                    <li><strong>Performance:</strong> Caching, async, lazy initialization</li>
                </ul>

                </section>

                <section id="microservices" class="section">
                    <h2>Microservices Patterns</h2>
                <ul>
                    <li><strong>Service Discovery:</strong> Eureka, Consul</li>
                    <li><strong>Load Balancing:</strong> Ribbon, LoadBalancer</li>
                    <li><strong>Circuit Breaker:</strong> Hystrix, Resilience4j</li>
                    <li><strong>API Gateway:</strong> Spring Cloud Gateway</li>
                    <li><strong>Message Queue:</strong> Kafka, RabbitMQ</li>
                    <li><strong>Distributed Tracing:</strong> Sleuth, Jaeger</li>
                    <li><strong>Configuration Server:</strong> Spring Cloud Config</li>
                </ul>

                    <h3>Key Interview Questions</h3>
                    <ul>
                        <li>How does Spring Boot auto-configuration work?</li>
                        <li>Difference between @Component, @Service, @Repository</li>
                        <li>Explain dependency injection and its benefits</li>
                        <li>What is @Transactional and how does it work?</li>
                        <li>How to handle exceptions globally in Spring Boot?</li>
                        <li>Explain JPA relationships (OneToOne, OneToMany, ManyToMany)</li>
                        <li>What are Spring Boot starters?</li>
                        <li>How to secure Spring Boot application?</li>
                        <li>Difference between @PathVariable and @RequestParam</li>
                        <li>How does Spring Boot handle database migrations?</li>
                    </ul>
                </section>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <div class="container">
            <p>&copy; 2025 Sonu Kumar - Senior Full Stack Developer | Java Spring Boot Angular React Expert | Available for remote work, enterprise consulting, and full-time opportunities | Contact: <a href="mailto:skrdeveloper1@gmail.com">skrdeveloper1@gmail.com</a> | LinkedIn: <a href="https://www.linkedin.com/in/sonuskr">linkedin.com/in/sonuskr</a></p>
        </div>
    </footer>
</body>
</html>