<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Spring Core Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-spring">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Spring Core Framework</h1>
                <p>Master Dependency Injection & IoC Container for Enterprise Applications</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'spring';</script>
    <script src="../menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightJava(block);
            });
        });
        
        function highlightJava(element) {
            let code = element.textContent;
            
            code = code.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert|@Component|@Service|@Repository|@Controller|@Autowired|@Qualifier|@Value|@Configuration|@Bean|@ComponentScan|@Profile|@Scope)\b/g, '<span class="keyword">$1</span>');
            
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');
            code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            code = code.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span class="number">$&</span>');
            
            code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="method">$1</span>(');
            
            code = code.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span class="class">$&</span>');
            
            element.innerHTML = code;
        }
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Spring Core Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Spring Overview</a></li>
                        <li><a href="#ioc-container">IoC Container</a></li>
                        <li><a href="#dependency-injection">Dependency Injection</a></li>
                        <li><a href="#bean-lifecycle">Bean Lifecycle</a></li>
                        <li><a href="#configuration">Configuration</a></li>
                        <li><a href="#annotations">Annotations</a></li>
                        <li><a href="#aop">Aspect-Oriented Programming</a></li>
                        <li><a href="#profiles">Profiles & Environment</a></li>
                        <li><a href="#events">Event Handling</a></li>
                        <li><a href="#testing">Testing</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="overview" class="section">
                    <h2>üöÄ Spring Framework Overview</h2>
                    
                    <div class="subsection">
                        <h3>What is Spring Framework?</h3>
                        <p><strong>Definition:</strong> Spring is a comprehensive framework for enterprise Java development that provides infrastructure support for developing Java applications. It focuses on dependency injection, aspect-oriented programming, and declarative programming.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>Inversion of Control (IoC):</strong> Container manages object creation and dependencies</li>
                            <li><strong>Dependency Injection (DI):</strong> Objects receive dependencies rather than creating them</li>
                            <li><strong>Aspect-Oriented Programming (AOP):</strong> Cross-cutting concerns separation</li>
                            <li><strong>Lightweight:</strong> Minimal overhead and non-invasive</li>
                            <li><strong>Modular:</strong> Use only what you need</li>
                            <li><strong>Integration:</strong> Excellent integration with other frameworks</li>
                        </ul>
                        
                        <h4>Spring Framework Architecture:</h4>
                        <div class="code-block">
                            <pre><code>Spring Framework Modules
‚îú‚îÄ‚îÄ Core Container
‚îÇ   ‚îú‚îÄ‚îÄ Core (IoC, DI)
‚îÇ   ‚îú‚îÄ‚îÄ Beans (Bean Factory)
‚îÇ   ‚îú‚îÄ‚îÄ Context (Application Context)
‚îÇ   ‚îî‚îÄ‚îÄ Expression Language (SpEL)
‚îú‚îÄ‚îÄ Data Access/Integration
‚îÇ   ‚îú‚îÄ‚îÄ JDBC
‚îÇ   ‚îú‚îÄ‚îÄ ORM (Hibernate, JPA)
‚îÇ   ‚îú‚îÄ‚îÄ OXM (Object/XML Mapping)
‚îÇ   ‚îú‚îÄ‚îÄ JMS (Java Message Service)
‚îÇ   ‚îî‚îÄ‚îÄ Transactions
‚îú‚îÄ‚îÄ Web
‚îÇ   ‚îú‚îÄ‚îÄ Web (Basic web support)
‚îÇ   ‚îú‚îÄ‚îÄ Web-MVC (Spring MVC)
‚îÇ   ‚îú‚îÄ‚îÄ Web-Socket
‚îÇ   ‚îî‚îÄ‚îÄ Web-Portlet
‚îú‚îÄ‚îÄ AOP (Aspect-Oriented Programming)
‚îú‚îÄ‚îÄ Aspects (AspectJ integration)
‚îú‚îÄ‚îÄ Instrumentation
‚îî‚îÄ‚îÄ Test (Testing support)</code></pre>
                        </div>
                        
                        <h4>Benefits of Spring Framework:</h4>
                        <ul>
                            <li><strong>Loose Coupling:</strong> Reduces dependencies between components</li>
                            <li><strong>Easy Testing:</strong> Dependency injection makes unit testing easier</li>
                            <li><strong>Flexible Configuration:</strong> XML, annotations, or Java-based configuration</li>
                            <li><strong>Enterprise Ready:</strong> Production-ready features out of the box</li>
                            <li><strong>Community Support:</strong> Large community and extensive documentation</li>
                        </ul>
                    </div>
                </section>

                <section id="ioc-container" class="section">
                    <h2>üèóÔ∏è IoC Container</h2>
                    
                    <div class="subsection">
                        <h3>Understanding IoC Container</h3>
                        <p><strong>Inversion of Control:</strong> The container controls the creation and management of objects, inverting the traditional control flow where objects create their own dependencies.</p>
                        
                        <h4>Container Types:</h4>
                        <div class="code-block">
                            <pre><code>// 1. BeanFactory - Basic container
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.xml.XmlBeanFactory;
import org.springframework.core.io.ClassPathResource;

public class BeanFactoryExample {
    public static void main(String[] args) {
        // Create BeanFactory
        BeanFactory factory = new XmlBeanFactory(
            new ClassPathResource("applicationContext.xml")
        );
        
        // Get bean from container
        UserService userService = (UserService) factory.getBean("userService");
        userService.processUser();
    }
}

// 2. ApplicationContext - Advanced container (Recommended)
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ApplicationContextExample {
    public static void main(String[] args) {
        // XML-based configuration
        ApplicationContext context = new ClassPathXmlApplicationContext(
            "applicationContext.xml"
        );
        
        // Annotation-based configuration
        ApplicationContext annotationContext = 
            new AnnotationConfigApplicationContext(AppConfig.class);
        
        // Get beans
        UserService userService = context.getBean("userService", UserService.class);
        UserRepository userRepository = context.getBean(UserRepository.class);
        
        userService.processUser();
    }
}</code></pre>
                        </div>
                        
                        <h4>Container Configuration Methods:</h4>
                        <div class="code-block">
                            <pre><code>// 1. XML Configuration (applicationContext.xml)
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Bean definitions -->
    <bean id="userRepository" class="com.example.UserRepositoryImpl"/>
    
    <bean id="userService" class="com.example.UserServiceImpl">
        <property name="userRepository" ref="userRepository"/>
    </bean>
    
    <!-- Constructor injection -->
    <bean id="orderService" class="com.example.OrderService">
        <constructor-arg ref="userService"/>
        <constructor-arg value="Premium"/>
    </bean>
</beans>

// 2. Java Configuration
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    
    @Bean
    public UserRepository userRepository() {
        return new UserRepositoryImpl();
    }
    
    @Bean
    public UserService userService() {
        UserServiceImpl service = new UserServiceImpl();
        service.setUserRepository(userRepository());
        return service;
    }
    
    @Bean
    @Scope("prototype")
    public OrderService orderService() {
        return new OrderService(userService(), "Premium");
    }
}

// 3. Annotation-based Configuration
@Component
public class UserRepositoryImpl implements UserRepository {
    // Implementation
}

@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    public void processUser() {
        // Business logic
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="dependency-injection" class="section">
                    <h2>üíâ Dependency Injection</h2>
                    
                    <div class="subsection">
                        <h3>Types of Dependency Injection</h3>
                        
                        <h4>1. Constructor Injection (Recommended)</h4>
                        <div class="code-block">
                            <pre><code>@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // Constructor injection - ensures immutability and required dependencies
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public User createUser(String name, String email) {
        User user = new User(name, email);
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser);
        return savedUser;
    }
}

// XML Configuration for Constructor Injection
<bean id="userService" class="com.example.UserService">
    <constructor-arg ref="userRepository"/>
    <constructor-arg ref="emailService"/>
</bean>

// Java Configuration
@Configuration
public class AppConfig {
    
    @Bean
    public UserService userService(UserRepository userRepository, 
                                  EmailService emailService) {
        return new UserService(userRepository, emailService);
    }
}</code></pre>
                        </div>
                        
                        <h4>2. Setter Injection</h4>
                        <div class="code-block">
                            <pre><code>@Service
public class OrderService {
    private UserService userService;
    private PaymentService paymentService;
    
    // Setter injection - allows optional dependencies
    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
    
    public Order processOrder(Long userId, List<Item> items) {
        User user = userService.findById(userId);
        Order order = new Order(user, items);
        paymentService.processPayment(order);
        return order;
    }
}

// XML Configuration for Setter Injection
<bean id="orderService" class="com.example.OrderService">
    <property name="userService" ref="userService"/>
    <property name="paymentService" ref="paymentService"/>
</bean></code></pre>
                        </div>
                        
                        <h4>3. Field Injection (Not Recommended)</h4>
                        <div class="code-block">
                            <pre><code>@Service
public class NotificationService {
    
    @Autowired
    private EmailService emailService;  // Field injection
    
    @Autowired
    private SmsService smsService;
    
    public void sendNotification(User user, String message) {
        emailService.sendEmail(user.getEmail(), message);
        smsService.sendSms(user.getPhone(), message);
    }
}

// Problems with Field Injection:
// 1. Cannot create immutable fields (final)
// 2. Harder to test (requires reflection)
// 3. Hidden dependencies
// 4. Circular dependency issues</code></pre>
                        </div>
                        
                        <h3>Advanced Dependency Injection</h3>
                        <div class="code-block">
                            <pre><code>// Qualifier for multiple implementations
public interface NotificationService {
    void sendNotification(String message);
}

@Component
@Qualifier("email")
public class EmailNotificationService implements NotificationService {
    public void sendNotification(String message) {
        // Send email
    }
}

@Component
@Qualifier("sms")
public class SmsNotificationService implements NotificationService {
    public void sendNotification(String message) {
        // Send SMS
    }
}

@Service
public class UserService {
    private final NotificationService emailService;
    private final NotificationService smsService;
    
    public UserService(@Qualifier("email") NotificationService emailService,
                      @Qualifier("sms") NotificationService smsService) {
        this.emailService = emailService;
        this.smsService = smsService;
    }
}

// Primary annotation
@Component
@Primary
public class DefaultNotificationService implements NotificationService {
    public void sendNotification(String message) {
        // Default implementation
    }
}

// Value injection
@Component
public class DatabaseConfig {
    
    @Value("${database.url}")
    private String databaseUrl;
    
    @Value("${database.username:admin}")  // Default value
    private String username;
    
    @Value("#{systemProperties['java.home']}")  // SpEL expression
    private String javaHome;
    
    @Value("#{T(java.lang.Math).random() * 100}")
    private double randomNumber;
}

// Collection injection
@Configuration
public class CollectionConfig {
    
    @Bean
    public List<NotificationService> notificationServices(
            @Qualifier("email") NotificationService emailService,
            @Qualifier("sms") NotificationService smsService) {
        return Arrays.asList(emailService, smsService);
    }
}

@Service
public class BulkNotificationService {
    
    @Autowired
    private List<NotificationService> notificationServices;
    
    public void sendBulkNotification(String message) {
        notificationServices.forEach(service -> 
            service.sendNotification(message));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="bean-lifecycle" class="section">
                    <h2>üîÑ Bean Lifecycle</h2>
                    
                    <div class="subsection">
                        <h3>Bean Lifecycle Phases</h3>
                        <div class="code-block">
                            <pre><code>// Bean Lifecycle Order:
// 1. Bean Instantiation
// 2. Dependency Injection
// 3. BeanNameAware.setBeanName()
// 4. BeanFactoryAware.setBeanFactory()
// 5. ApplicationContextAware.setApplicationContext()
// 6. BeanPostProcessor.postProcessBeforeInitialization()
// 7. @PostConstruct / InitializingBean.afterPropertiesSet() / init-method
// 8. BeanPostProcessor.postProcessAfterInitialization()
// 9. Bean Ready for Use
// 10. @PreDestroy / DisposableBean.destroy() / destroy-method

@Component
public class UserService implements BeanNameAware, BeanFactoryAware, 
                                   ApplicationContextAware, InitializingBean, DisposableBean {
    
    private String beanName;
    private BeanFactory beanFactory;
    private ApplicationContext applicationContext;
    
    @Autowired
    private UserRepository userRepository;
    
    // Constructor
    public UserService() {
        System.out.println("1. UserService Constructor called");
    }
    
    // Dependency Injection happens here
    
    // Aware interfaces
    @Override
    public void setBeanName(String name) {
        this.beanName = name;
        System.out.println("3. setBeanName: " + name);
    }
    
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
        System.out.println("4. setBeanFactory called");
    }
    
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
        System.out.println("5. setApplicationContext called");
    }
    
    // Initialization
    @PostConstruct
    public void postConstruct() {
        System.out.println("7a. @PostConstruct called");
    }
    
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("7b. afterPropertiesSet called");
    }
    
    // Custom init method (configured in XML or @Bean)
    public void customInit() {
        System.out.println("7c. customInit called");
    }
    
    // Destruction
    @PreDestroy
    public void preDestroy() {
        System.out.println("10a. @PreDestroy called");
    }
    
    @Override
    public void destroy() throws Exception {
        System.out.println("10b. destroy called");
    }
    
    // Custom destroy method
    public void customDestroy() {
        System.out.println("10c. customDestroy called");
    }
}</code></pre>
                        </div>
                        
                        <h3>Bean Post Processors</h3>
                        <div class="code-block">
                            <pre><code>// Custom Bean Post Processor
@Component
public class CustomBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) 
            throws BeansException {
        System.out.println("6. Before Initialization: " + beanName);
        
        // Custom logic before initialization
        if (bean instanceof UserService) {
            // Perform some setup
        }
        
        return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) 
            throws BeansException {
        System.out.println("8. After Initialization: " + beanName);
        
        // Custom logic after initialization
        if (bean instanceof UserService) {
            // Wrap with proxy, add monitoring, etc.
        }
        
        return bean;
    }
}

// Configuration with lifecycle methods
@Configuration
public class LifecycleConfig {
    
    @Bean(initMethod = "customInit", destroyMethod = "customDestroy")
    public UserService userService() {
        return new UserService();
    }
}

// XML Configuration with lifecycle
<bean id="userService" class="com.example.UserService" 
      init-method="customInit" 
      destroy-method="customDestroy"/>

// Lifecycle callbacks with @Bean
@Configuration
public class AppConfig {
    
    @Bean
    public DataSource dataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/mydb");
        return dataSource;
    }
    
    @Bean(destroyMethod = "close")  // Call close() on shutdown
    public Connection connection() {
        try {
            return dataSource().getConnection();
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="configuration" class="section">
                    <h2>‚öôÔ∏è Configuration</h2>
                    
                    <div class="subsection">
                        <h3>Java-based Configuration</h3>
                        <div class="code-block">
                            <pre><code>@Configuration
@ComponentScan(basePackages = {"com.example.service", "com.example.repository"})
@PropertySource("classpath:application.properties")
@EnableAspectJAutoProxy
public class AppConfig {
    
    @Value("${database.url}")
    private String databaseUrl;
    
    @Value("${database.username}")
    private String username;
    
    @Value("${database.password}")
    private String password;
    
    @Bean
    @Primary
    public DataSource primaryDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(databaseUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setMaximumPoolSize(20);
        return dataSource;
    }
    
    @Bean
    @Qualifier("readOnly")
    public DataSource readOnlyDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(databaseUrl + "?readOnly=true");
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setMaximumPoolSize(10);
        return dataSource;
    }
    
    @Bean
    @Scope("prototype")
    public UserService userService() {
        return new UserService();
    }
    
    @Bean
    @Conditional(DatabaseCondition.class)
    public DatabaseHealthCheck databaseHealthCheck() {
        return new DatabaseHealthCheck();
    }
}

// Custom Condition
public class DatabaseCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        Environment env = context.getEnvironment();
        return env.getProperty("database.enabled", Boolean.class, false);
    }
}

// Configuration Properties
@ConfigurationProperties(prefix = "app.database")
@Component
public class DatabaseProperties {
    private String url;
    private String username;
    private String password;
    private int maxConnections = 10;
    private boolean ssl = false;
    
    // Getters and setters
    public String getUrl() { return url; }
    public void setUrl(String url) { this.url = url; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public int getMaxConnections() { return maxConnections; }
    public void setMaxConnections(int maxConnections) { this.maxConnections = maxConnections; }
    
    public boolean isSsl() { return ssl; }
    public void setSsl(boolean ssl) { this.ssl = ssl; }
}</code></pre>
                        </div>
                        
                        <h3>Profile-based Configuration</h3>
                        <div class="code-block">
                            <pre><code>// Profile-specific configurations
@Configuration
@Profile("development")
public class DevelopmentConfig {
    
    @Bean
    public DataSource dataSource() {
        // H2 in-memory database for development
        return new EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.H2)
                .addScript("schema.sql")
                .addScript("test-data.sql")
                .build();
    }
    
    @Bean
    public EmailService emailService() {
        return new MockEmailService(); // Mock for development
    }
}

@Configuration
@Profile("production")
public class ProductionConfig {
    
    @Bean
    public DataSource dataSource() {
        // Production database configuration
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://prod-server:3306/myapp");
        dataSource.setUsername("prod_user");
        dataSource.setPassword("secure_password");
        return dataSource;
    }
    
    @Bean
    public EmailService emailService() {
        return new SmtpEmailService(); // Real email service
    }
}

@Configuration
@Profile({"staging", "production"})
public class NonDevConfig {
    
    @Bean
    public SecurityConfig securityConfig() {
        return new SecurityConfig(true); // Enable security
    }
}

// Component with profile
@Component
@Profile("!production")  // Active in all profiles except production
public class DebugService {
    
    public void logDebugInfo(String message) {
        System.out.println("DEBUG: " + message);
    }
}

// Activating profiles
// 1. Programmatically
public class ProfileExample {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = 
            new AnnotationConfigApplicationContext();
        
        context.getEnvironment().setActiveProfiles("development", "debug");
        context.register(AppConfig.class);
        context.refresh();
    }
}

// 2. JVM arguments
// -Dspring.profiles.active=production,monitoring

// 3. Environment variable
// SPRING_PROFILES_ACTIVE=production,monitoring

// 4. application.properties
// spring.profiles.active=production,monitoring</code></pre>
                        </div>
                    </div>
                </section>

                <section id="aop" class="section">
                    <h2>üéØ Aspect-Oriented Programming</h2>
                    
                    <div class="subsection">
                        <h3>AOP Concepts and Implementation</h3>
                        <div class="code-block">
                            <pre><code>// Enable AOP
@Configuration
@EnableAspectJAutoProxy
public class AopConfig {
}

// Logging Aspect
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
    
    // Pointcut definitions
    @Pointcut("execution(* com.example.service.*.*(..))")
    public void serviceLayer() {}
    
    @Pointcut("@annotation(com.example.annotation.Loggable)")
    public void loggableMethod() {}
    
    @Pointcut("within(com.example.repository.*)")
    public void repositoryLayer() {}
    
    // Before advice
    @Before("serviceLayer()")
    public void logBefore(JoinPoint joinPoint) {
        logger.info("Entering method: {} with arguments: {}", 
                   joinPoint.getSignature().getName(), 
                   Arrays.toString(joinPoint.getArgs()));
    }
    
    // After returning advice
    @AfterReturning(pointcut = "serviceLayer()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        logger.info("Method {} returned: {}", 
                   joinPoint.getSignature().getName(), result);
    }
    
    // After throwing advice
    @AfterThrowing(pointcut = "serviceLayer()", throwing = "exception")
    public void logAfterThrowing(JoinPoint joinPoint, Exception exception) {
        logger.error("Method {} threw exception: {}", 
                    joinPoint.getSignature().getName(), 
                    exception.getMessage());
    }
    
    // Around advice
    @Around("loggableMethod()")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        try {
            Object result = joinPoint.proceed();
            long endTime = System.currentTimeMillis();
            
            logger.info("Method {} executed in {} ms", 
                       joinPoint.getSignature().getName(), 
                       (endTime - startTime));
            
            return result;
        } catch (Exception e) {
            logger.error("Method {} failed after {} ms", 
                        joinPoint.getSignature().getName(), 
                        (System.currentTimeMillis() - startTime));
            throw e;
        }
    }
}

// Custom annotation for AOP
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
    String value() default "";
}

// Security Aspect
@Aspect
@Component
public class SecurityAspect {
    
    @Autowired
    private SecurityService securityService;
    
    @Before("@annotation(secured)")
    public void checkSecurity(JoinPoint joinPoint, Secured secured) {
        String requiredRole = secured.value();
        
        if (!securityService.hasRole(requiredRole)) {
            throw new SecurityException("Access denied. Required role: " + requiredRole);
        }
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Secured {
    String value();
}

// Using AOP annotations
@Service
public class UserService {
    
    @Loggable("User creation")
    @Secured("ADMIN")
    public User createUser(String name, String email) {
        // Business logic
        return new User(name, email);
    }
    
    @Cacheable("users")
    public User findById(Long id) {
        // Database call
        return userRepository.findById(id);
    }
}</code></pre>
                        </div>
                        
                        <h3>Transaction Management with AOP</h3>
                        <div class="code-block">
                            <pre><code>// Enable transaction management
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}

// Transactional service
@Service
@Transactional(readOnly = true)  // Default for all methods
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    // Override default with write transaction
    @Transactional(readOnly = false, rollbackFor = Exception.class)
    public User createUser(String name, String email) {
        User user = new User(name, email);
        User savedUser = userRepository.save(user);
        
        // This will be rolled back if email sending fails
        emailService.sendWelcomeEmail(savedUser);
        
        return savedUser;
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void auditUserCreation(User user) {
        // This runs in a separate transaction
        auditRepository.save(new AuditLog("User created: " + user.getId()));
    }
    
    @Transactional(isolation = Isolation.READ_COMMITTED, timeout = 30)
    public List<User> findActiveUsers() {
        return userRepository.findByStatus("ACTIVE");
    }
}

// Custom Transaction Aspect
@Aspect
@Component
public class TransactionAspect {
    
    @Around("@annotation(transactional)")
    public Object manageTransaction(ProceedingJoinPoint joinPoint, 
                                   Transactional transactional) throws Throwable {
        
        TransactionStatus status = transactionManager.getTransaction(
            new DefaultTransactionDefinition());
        
        try {
            Object result = joinPoint.proceed();
            transactionManager.commit(status);
            return result;
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw e;
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="interview" class="section">
                    <h2>üíº Interview Questions</h2>
                    
                    <div class="subsection">
                        <h3>Frequently Asked Questions</h3>
                        
                        <div class="question-block">
                            <h4>Q1: What is Inversion of Control (IoC) and Dependency Injection?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>IoC:</strong> Design principle where control of object creation is inverted from application to container</li>
                                <li><strong>DI:</strong> Implementation of IoC where dependencies are injected rather than created by objects</li>
                                <li><strong>Benefits:</strong> Loose coupling, easier testing, better maintainability</li>
                                <li><strong>Types:</strong> Constructor, setter, and field injection</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q2: Explain the difference between BeanFactory and ApplicationContext</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>BeanFactory:</strong> Basic container, lazy initialization, minimal features</li>
                                <li><strong>ApplicationContext:</strong> Advanced container, eager initialization, additional features</li>
                                <li><strong>ApplicationContext features:</strong> Event handling, internationalization, AOP support</li>
                                <li><strong>Recommendation:</strong> Use ApplicationContext for enterprise applications</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q3: What are the different bean scopes in Spring?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Singleton:</strong> One instance per container (default)</li>
                                <li><strong>Prototype:</strong> New instance for each request</li>
                                <li><strong>Request:</strong> One instance per HTTP request (web)</li>
                                <li><strong>Session:</strong> One instance per HTTP session (web)</li>
                                <li><strong>Application:</strong> One instance per ServletContext (web)</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q4: Explain Spring AOP and its key concepts</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Aspect:</strong> Cross-cutting concern implementation</li>
                                <li><strong>Join Point:</strong> Point in program execution where aspect can be applied</li>
                                <li><strong>Pointcut:</strong> Expression that selects join points</li>
                                <li><strong>Advice:</strong> Action taken at join point (Before, After, Around)</li>
                                <li><strong>Weaving:</strong> Process of applying aspects to target objects</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q5: What is the Spring Bean lifecycle?</h4>
                            <p><strong>Answer:</strong> Bean instantiation ‚Üí Dependency injection ‚Üí Aware interfaces ‚Üí BeanPostProcessor (before) ‚Üí Initialization methods ‚Üí BeanPostProcessor (after) ‚Üí Bean ready ‚Üí Destruction methods</p>
                        </div>
                    </div>
                </section>

            </div>
            </div>
        </div>
    </div>
    
    <footer></footer>
    <script src="footer.js"></script>
</body>
</html>