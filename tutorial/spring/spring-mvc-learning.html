<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Spring MVC Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-spring">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Spring MVC Framework</h1>
                <p>Master Model-View-Controller Pattern for Web Applications</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'spring';</script>
    <script src="../menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightJava(block);
            });
            updateActiveNav();
        });
        
        function highlightJava(element) {
            let code = element.textContent;
            
            code = code.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert|@Controller|@RestController|@RequestMapping|@GetMapping|@PostMapping|@PutMapping|@DeleteMapping|@PathVariable|@RequestParam|@RequestBody|@ResponseBody|@ModelAttribute|@Valid|@Autowired)\b/g, '<span class="keyword">$1</span>');
            
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');
            code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            code = code.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span class="number">$&</span>');
            
            code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="method">$1</span>(');
            
            code = code.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span class="class">$&</span>');
            
            element.innerHTML = code;
        }
        
        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.toc-nav a');
            
            let currentSection = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentSection = section.id;
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateActiveNav);
        updateActiveNav();
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Spring MVC Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Spring MVC Overview</a></li>
                        <li><a href="#architecture">MVC Architecture</a></li>
                        <li><a href="#controllers">Controllers</a></li>
                        <li><a href="#request-mapping">Request Mapping</a></li>
                        <li><a href="#data-binding">Data Binding</a></li>
                        <li><a href="#validation">Validation</a></li>
                        <li><a href="#exception-handling">Exception Handling</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="overview" class="section">
                    <h2>üöÄ Spring MVC Overview</h2>
                    
                    <div class="subsection">
                        <h3>What is Spring MVC?</h3>
                        <p><strong>Definition:</strong> Spring MVC is a web framework built on the Model-View-Controller design pattern. It provides a clean separation of concerns and flexible configuration for building web applications and RESTful services.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>MVC Pattern:</strong> Clear separation between Model, View, and Controller</li>
                            <li><strong>Flexible Configuration:</strong> Annotation-based and XML configuration</li>
                            <li><strong>RESTful Support:</strong> Built-in support for REST APIs</li>
                            <li><strong>Data Binding:</strong> Automatic binding of request parameters to objects</li>
                            <li><strong>Validation:</strong> Integrated validation framework</li>
                            <li><strong>View Technologies:</strong> Support for JSP, Thymeleaf, JSON, XML</li>
                        </ul>
                        
                        <h4>Spring MVC Configuration:</h4>
                        <div class="code-block">
                            <pre><code>// Java Configuration
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.example")
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public ViewResolver viewResolver() {
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }
    
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/resources/**")
                .addResourceLocations("/resources/");
    }
}

// Web Application Initializer
public class WebAppInitializer implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext servletContext) throws ServletException {
        AnnotationConfigWebApplicationContext context = 
            new AnnotationConfigWebApplicationContext();
        context.register(WebConfig.class);
        
        DispatcherServlet servlet = new DispatcherServlet(context);
        ServletRegistration.Dynamic registration = 
            servletContext.addServlet("dispatcher", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/");
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="architecture" class="section">
                    <h2>üèóÔ∏è MVC Architecture</h2>
                    
                    <div class="subsection">
                        <h3>Spring MVC Request Flow</h3>
                        <div class="code-block">
                            <pre><code>Request Flow:
1. Client Request ‚Üí DispatcherServlet
2. DispatcherServlet ‚Üí HandlerMapping (find controller)
3. HandlerMapping ‚Üí Controller
4. Controller ‚Üí Business Logic ‚Üí Model
5. Controller ‚Üí ViewName
6. DispatcherServlet ‚Üí ViewResolver
7. ViewResolver ‚Üí View
8. View ‚Üí Response to Client

Components:
‚îú‚îÄ‚îÄ DispatcherServlet (Front Controller)
‚îú‚îÄ‚îÄ HandlerMapping (URL to Controller mapping)
‚îú‚îÄ‚îÄ Controller (Handle requests)
‚îú‚îÄ‚îÄ ModelAndView (Data and view name)
‚îú‚îÄ‚îÄ ViewResolver (Resolve view names)
‚îî‚îÄ‚îÄ View (Render response)</code></pre>
                        </div>
                        
                        <h3>Core Components</h3>
                        <div class="code-block">
                            <pre><code>// DispatcherServlet Configuration
public class MyWebAppInitializer implements WebApplicationInitializer {
    
    @Override
    public void onStartup(ServletContext container) {
        // Create the 'root' Spring application context
        AnnotationConfigWebApplicationContext rootContext = 
            new AnnotationConfigWebApplicationContext();
        rootContext.register(RootConfig.class);
        
        // Manage the lifecycle of the root application context
        container.addListener(new ContextLoaderListener(rootContext));
        
        // Create the dispatcher servlet's Spring application context
        AnnotationConfigWebApplicationContext dispatcherContext = 
            new AnnotationConfigWebApplicationContext();
        dispatcherContext.register(WebConfig.class);
        
        // Register and map the dispatcher servlet
        ServletRegistration.Dynamic dispatcher = 
            container.addServlet("dispatcher", new DispatcherServlet(dispatcherContext));
        dispatcher.setLoadOnStartup(1);
        dispatcher.addMapping("/");
    }
}

// Handler Mapping Configuration
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public HandlerMapping handlerMapping() {
        RequestMappingHandlerMapping mapping = new RequestMappingHandlerMapping();
        mapping.setOrder(0);
        return mapping;
    }
    
    @Bean
    public HandlerAdapter handlerAdapter() {
        RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter();
        return adapter;
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="controllers" class="section">
                    <h2>üéÆ Controllers</h2>
                    
                    <div class="subsection">
                        <h3>Basic Controllers</h3>
                        <div class="code-block">
                            <pre><code>// Traditional MVC Controller
@Controller
@RequestMapping("/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Display user list
    @GetMapping
    public String listUsers(Model model) {
        List<User> users = userService.findAll();
        model.addAttribute("users", users);
        return "users/list"; // Returns view name
    }
    
    // Show user details
    @GetMapping("/{id}")
    public String showUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "users/detail";
    }
    
    // Show create form
    @GetMapping("/new")
    public String newUserForm(Model model) {
        model.addAttribute("user", new User());
        return "users/form";
    }
    
    // Handle form submission
    @PostMapping
    public String createUser(@Valid @ModelAttribute User user, 
                           BindingResult result, 
                           RedirectAttributes redirectAttributes) {
        if (result.hasErrors()) {
            return "users/form";
        }
        
        User savedUser = userService.save(user);
        redirectAttributes.addFlashAttribute("message", "User created successfully!");
        return "redirect:/users/" + savedUser.getId();
    }
    
    // Show edit form
    @GetMapping("/{id}/edit")
    public String editUserForm(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "users/form";
    }
    
    // Handle update
    @PutMapping("/{id}")
    public String updateUser(@PathVariable Long id, 
                           @Valid @ModelAttribute User user,
                           BindingResult result) {
        if (result.hasErrors()) {
            return "users/form";
        }
        
        user.setId(id);
        userService.save(user);
        return "redirect:/users/" + id;
    }
    
    // Handle delete
    @DeleteMapping("/{id}")
    public String deleteUser(@PathVariable Long id) {
        userService.deleteById(id);
        return "redirect:/users";
    }
}</code></pre>
                        </div>
                        
                        <h3>REST Controllers</h3>
                        <div class="code-block">
                            <pre><code>// REST API Controller
@RestController
@RequestMapping("/api/users")
@CrossOrigin(origins = "http://localhost:3000")
public class UserRestController {
    
    @Autowired
    private UserService userService;
    
    // Get all users
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(defaultValue = "id") String sortBy) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by(sortBy));
        Page<User> users = userService.findAll(pageable);
        
        return ResponseEntity.ok()
                .header("X-Total-Count", String.valueOf(users.getTotalElements()))
                .body(users.getContent());
    }
    
    // Get user by ID
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        return userService.findById(id)
                .map(user -> ResponseEntity.ok().body(user))
                .orElse(ResponseEntity.notFound().build());
    }
    
    // Create new user
    @PostMapping
    public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
        User savedUser = userService.save(user);
        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{id}")
                .buildAndExpand(savedUser.getId())
                .toUri();
        
        return ResponseEntity.created(location).body(savedUser);
    }
    
    // Update user
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                         @Valid @RequestBody User user) {
        return userService.findById(id)
                .map(existingUser -> {
                    user.setId(id);
                    User updatedUser = userService.save(user);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }
    
    // Partial update
    @PatchMapping("/{id}")
    public ResponseEntity<User> partialUpdateUser(@PathVariable Long id,
                                                @RequestBody Map<String, Object> updates) {
        return userService.findById(id)
                .map(user -> {
                    updates.forEach((key, value) -> {
                        switch (key) {
                            case "name":
                                user.setName((String) value);
                                break;
                            case "email":
                                user.setEmail((String) value);
                                break;
                            // Add more fields as needed
                        }
                    });
                    User updatedUser = userService.save(user);
                    return ResponseEntity.ok(updatedUser);
                })
                .orElse(ResponseEntity.notFound().build());
    }
    
    // Delete user
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable Long id) {
        return userService.findById(id)
                .map(user -> {
                    userService.deleteById(id);
                    return ResponseEntity.ok().build();
                })
                .orElse(ResponseEntity.notFound().build());
    }
    
    // Search users
    @GetMapping("/search")
    public ResponseEntity<List<User>> searchUsers(
            @RequestParam String query,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        Pageable pageable = PageRequest.of(page, size);
        List<User> users = userService.searchUsers(query, pageable);
        return ResponseEntity.ok(users);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="request-mapping" class="section">
                    <h2>üó∫Ô∏è Request Mapping</h2>
                    
                    <div class="subsection">
                        <h3>Mapping Annotations</h3>
                        <div class="code-block">
                            <pre><code>@Controller
@RequestMapping("/api/products")
public class ProductController {
    
    // Basic mapping
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    public String listProducts() {
        return "products/list";
    }
    
    // HTTP method specific mappings
    @GetMapping("/")
    public String getAllProducts() { return "products/list"; }
    
    @PostMapping("/")
    public String createProduct() { return "redirect:/products"; }
    
    @PutMapping("/{id}")
    public String updateProduct(@PathVariable Long id) { 
        return "redirect:/products/" + id; 
    }
    
    @DeleteMapping("/{id}")
    public String deleteProduct(@PathVariable Long id) { 
        return "redirect:/products"; 
    }
    
    @PatchMapping("/{id}")
    public String partialUpdate(@PathVariable Long id) { 
        return "redirect:/products/" + id; 
    }
    
    // Path variables
    @GetMapping("/{id}")
    public String getProduct(@PathVariable Long id, Model model) {
        // id is automatically converted to Long
        return "products/detail";
    }
    
    @GetMapping("/{category}/{id}")
    public String getProductByCategory(@PathVariable String category,
                                     @PathVariable Long id) {
        return "products/detail";
    }
    
    // Optional path variables
    @GetMapping({"/", "/{category}"})
    public String getProducts(@PathVariable(required = false) String category) {
        if (category != null) {
            // Filter by category
        }
        return "products/list";
    }
    
    // Request parameters
    @GetMapping("/search")
    public String searchProducts(@RequestParam String query,
                               @RequestParam(defaultValue = "0") int page,
                               @RequestParam(defaultValue = "10") int size,
                               @RequestParam(required = false) String category) {
        return "products/search";
    }
    
    // Multiple request parameters
    @GetMapping("/filter")
    public String filterProducts(@RequestParam Map<String, String> params) {
        // Access all parameters as a map
        return "products/list";
    }
    
    // Headers and content type
    @PostMapping(value = "/upload", 
                consumes = "multipart/form-data",
                produces = "application/json")
    @ResponseBody
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) {
        return ResponseEntity.ok("File uploaded successfully");
    }
    
    // Custom headers
    @GetMapping(value = "/download/{id}", 
                headers = "Accept=application/pdf")
    public ResponseEntity<byte[]> downloadPdf(@PathVariable Long id) {
        // Return PDF content
        return ResponseEntity.ok()
                .header("Content-Type", "application/pdf")
                .body(new byte[0]);
    }
}</code></pre>
                        </div>
                        
                        <h3>Advanced Request Mapping</h3>
                        <div class="code-block">
                            <pre><code>@RestController
@RequestMapping("/api/advanced")
public class AdvancedMappingController {
    
    // Regex in path variables
    @GetMapping("/users/{id:[0-9]+}")
    public User getUserById(@PathVariable Long id) {
        // id must be numeric
        return userService.findById(id);
    }
    
    // Matrix variables
    @GetMapping("/products/{category};color={color};size={size}")
    public List<Product> getProducts(@PathVariable String category,
                                   @MatrixVariable String color,
                                   @MatrixVariable String size) {
        return productService.findByCategoryAndColorAndSize(category, color, size);
    }
    
    // Request mapping with conditions
    @GetMapping(value = "/data", 
                params = "version=1")
    public String getDataV1() {
        return "Version 1 data";
    }
    
    @GetMapping(value = "/data", 
                params = "version=2")
    public String getDataV2() {
        return "Version 2 data";
    }
    
    // Content negotiation
    @GetMapping(value = "/user/{id}", 
                produces = "application/json")
    public User getUserAsJson(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @GetMapping(value = "/user/{id}", 
                produces = "application/xml")
    public User getUserAsXml(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    // Custom request mapping annotation
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @RequestMapping(method = RequestMethod.GET, produces = "application/json")
    public @interface JsonGetMapping {
        String value() default "";
    }
    
    @JsonGetMapping("/custom")
    public Map<String, Object> customMapping() {
        return Map.of("message", "Custom mapping works!");
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="data-binding" class="section">
                    <h2>üîó Data Binding</h2>
                    
                    <div class="subsection">
                        <h3>Request Data Binding</h3>
                        <div class="code-block">
                            <pre><code>// Model for data binding
public class User {
    private Long id;
    private String name;
    private String email;
    private LocalDate birthDate;
    private Address address;
    private List<String> hobbies;
    
    // Constructors, getters, setters
}

public class Address {
    private String street;
    private String city;
    private String zipCode;
    // Getters and setters
}

@Controller
@RequestMapping("/users")
public class UserController {
    
    // Form data binding
    @PostMapping
    public String createUser(@ModelAttribute User user, 
                           BindingResult result,
                           Model model) {
        if (result.hasErrors()) {
            return "users/form";
        }
        userService.save(user);
        return "redirect:/users";
    }
    
    // JSON data binding
    @PostMapping("/api")
    @ResponseBody
    public ResponseEntity<User> createUserApi(@RequestBody User user) {
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
    
    // Request parameter binding
    @GetMapping("/search")
    public String searchUsers(@RequestParam String name,
                            @RequestParam(required = false) String email,
                            @RequestParam(defaultValue = "0") int page,
                            Model model) {
        List<User> users = userService.search(name, email, page);
        model.addAttribute("users", users);
        return "users/search";
    }
    
    // Path variable binding
    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id);
        model.addAttribute("user", user);
        return "users/detail";
    }
    
    // Header binding
    @GetMapping("/profile")
    public String getUserProfile(@RequestHeader("User-Agent") String userAgent,
                               @RequestHeader(value = "Accept-Language", 
                                            defaultValue = "en") String language,
                               Model model) {
        // Use headers for processing
        return "users/profile";
    }
    
    // Cookie binding
    @GetMapping("/preferences")
    public String getUserPreferences(@CookieValue(value = "theme", 
                                                defaultValue = "light") String theme,
                                   Model model) {
        model.addAttribute("theme", theme);
        return "users/preferences";
    }
}</code></pre>
                        </div>
                        
                        <h3>Custom Data Binding</h3>
                        <div class="code-block">
                            <pre><code>// Custom Property Editor
public class CustomDateEditor extends PropertyEditorSupport {
    
    private final DateTimeFormatter formatter;
    
    public CustomDateEditor(String pattern) {
        this.formatter = DateTimeFormatter.ofPattern(pattern);
    }
    
    @Override
    public void setAsText(String text) throws IllegalArgumentException {
        try {
            LocalDate date = LocalDate.parse(text, formatter);
            setValue(date);
        } catch (DateTimeParseException e) {
            throw new IllegalArgumentException("Invalid date format: " + text);
        }
    }
    
    @Override
    public String getAsText() {
        LocalDate date = (LocalDate) getValue();
        return date != null ? date.format(formatter) : "";
    }
}

// Register custom editors
@ControllerAdvice
public class GlobalControllerAdvice {
    
    @InitBinder
    public void initBinder(WebDataBinder binder) {
        binder.registerCustomEditor(LocalDate.class, 
                                   new CustomDateEditor("yyyy-MM-dd"));
    }
}

// Custom Converter
@Component
public class StringToUserConverter implements Converter<String, User> {
    
    @Autowired
    private UserService userService;
    
    @Override
    public User convert(String id) {
        try {
            Long userId = Long.parseLong(id);
            return userService.findById(userId);
        } catch (NumberFormatException e) {
            return null;
        }
    }
}

// Register converter
@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    @Autowired
    private StringToUserConverter stringToUserConverter;
    
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverter(stringToUserConverter);
    }
}

// Custom Formatter
@Component
public class LocalDateFormatter implements Formatter<LocalDate> {
    
    @Override
    public LocalDate parse(String text, Locale locale) throws ParseException {
        return LocalDate.parse(text, DateTimeFormatter.ofPattern("dd/MM/yyyy"));
    }
    
    @Override
    public String print(LocalDate date, Locale locale) {
        return date.format(DateTimeFormatter.ofPattern("dd/MM/yyyy"));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="validation" class="section">
                    <h2>‚úÖ Validation</h2>
                    
                    <div class="subsection">
                        <h3>Bean Validation</h3>
                        <div class="code-block">
                            <pre><code>// User model with validation annotations
public class User {
    
    @NotNull(message = "ID cannot be null")
    private Long id;
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @Past(message = "Birth date must be in the past")
    private LocalDate birthDate;
    
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 100, message = "Age must not exceed 100")
    private Integer age;
    
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Invalid phone number")
    private String phoneNumber;
    
    @Valid
    @NotNull(message = "Address is required")
    private Address address;
    
    @Size(max = 5, message = "Maximum 5 hobbies allowed")
    private List<@NotBlank(message = "Hobby cannot be blank") String> hobbies;
    
    // Constructors, getters, setters
}

public class Address {
    
    @NotBlank(message = "Street is required")
    private String street;
    
    @NotBlank(message = "City is required")
    private String city;
    
    @Pattern(regexp = "\\d{5}", message = "ZIP code must be 5 digits")
    private String zipCode;
    
    // Getters and setters
}

// Controller with validation
@Controller
@RequestMapping("/users")
public class UserController {
    
    @PostMapping
    public String createUser(@Valid @ModelAttribute User user,
                           BindingResult result,
                           Model model) {
        
        // Check for validation errors
        if (result.hasErrors()) {
            model.addAttribute("user", user);
            return "users/form";
        }
        
        userService.save(user);
        return "redirect:/users";
    }
    
    @PostMapping("/api")
    @ResponseBody
    public ResponseEntity<?> createUserApi(@Valid @RequestBody User user,
                                         BindingResult result) {
        
        if (result.hasErrors()) {
            Map<String, String> errors = new HashMap<>();
            result.getFieldErrors().forEach(error -> 
                errors.put(error.getField(), error.getDefaultMessage())
            );
            return ResponseEntity.badRequest().body(errors);
        }
        
        User savedUser = userService.save(user);
        return ResponseEntity.ok(savedUser);
    }
}</code></pre>
                        </div>
                        
                        <h3>Custom Validation</h3>
                        <div class="code-block">
                            <pre><code>// Custom validation annotation
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = UniqueEmailValidator.class)
public @interface UniqueEmail {
    String message() default "Email already exists";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

// Custom validator implementation
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    
    @Autowired
    private UserService userService;
    
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        if (email == null) {
            return true; // Let @NotNull handle null values
        }
        return !userService.existsByEmail(email);
    }
}

// Class-level validation
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = PasswordMatchValidator.class)
public @interface PasswordMatch {
    String message() default "Passwords do not match";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

public class PasswordMatchValidator implements ConstraintValidator<PasswordMatch, Object> {
    
    @Override
    public boolean isValid(Object obj, ConstraintValidatorContext context) {
        if (obj instanceof UserRegistrationForm) {
            UserRegistrationForm form = (UserRegistrationForm) obj;
            return Objects.equals(form.getPassword(), form.getConfirmPassword());
        }
        return true;
    }
}

// Using custom validation
@PasswordMatch
public class UserRegistrationForm {
    
    @NotBlank
    @UniqueEmail
    private String email;
    
    @NotBlank
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;
    
    @NotBlank
    private String confirmPassword;
    
    // Getters and setters
}

// Validation groups
public interface CreateGroup {}
public interface UpdateGroup {}

public class User {
    
    @NotNull(groups = UpdateGroup.class)
    private Long id;
    
    @NotBlank(groups = {CreateGroup.class, UpdateGroup.class})
    private String name;
    
    @UniqueEmail(groups = CreateGroup.class)
    private String email;
    
    // Other fields
}

// Controller with validation groups
@PostMapping
public String createUser(@Validated(CreateGroup.class) @ModelAttribute User user,
                       BindingResult result) {
    // Validation logic
    return "redirect:/users";
}

@PutMapping("/{id}")
public String updateUser(@Validated(UpdateGroup.class) @ModelAttribute User user,
                       BindingResult result) {
    // Validation logic
    return "redirect:/users/" + user.getId();
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="exception-handling" class="section">
                    <h2>üö® Exception Handling</h2>
                    
                    <div class="subsection">
                        <h3>Global Exception Handling</h3>
                        <div class="code-block">
                            <pre><code>// Global exception handler
@ControllerAdvice
public class GlobalExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // Handle validation errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ResponseBody
    public Map<String, String> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error -> 
            errors.put(error.getField(), error.getDefaultMessage())
        );
        return errors;
    }
    
    // Handle custom business exceptions
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public ModelAndView handleUserNotFound(UserNotFoundException ex, HttpServletRequest request) {
        logger.error("User not found: {}", ex.getMessage());
        
        ModelAndView mav = new ModelAndView("error/404");
        mav.addObject("message", ex.getMessage());
        mav.addObject("url", request.getRequestURL());
        return mav;
    }
    
    // Handle REST API exceptions
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseBody
    public ResponseEntity<ErrorResponse> handleUserNotFoundApi(UserNotFoundException ex) {
        ErrorResponse error = new ErrorResponse(
            "USER_NOT_FOUND",
            ex.getMessage(),
            System.currentTimeMillis()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    // Handle access denied
    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public String handleAccessDenied(AccessDeniedException ex, Model model) {
        model.addAttribute("message", "Access denied: " + ex.getMessage());
        return "error/403";
    }
    
    // Handle general exceptions
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ModelAndView handleGeneral(Exception ex, HttpServletRequest request) {
        logger.error("Unexpected error occurred", ex);
        
        ModelAndView mav = new ModelAndView("error/500");
        mav.addObject("message", "An unexpected error occurred");
        mav.addObject("url", request.getRequestURL());
        return mav;
    }
}

// Custom exception classes
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(Long id) {
        super("User not found with id: " + id);
    }
}

public class EmailAlreadyExistsException extends RuntimeException {
    public EmailAlreadyExistsException(String email) {
        super("Email already exists: " + email);
    }
}

// Error response DTO
public class ErrorResponse {
    private String code;
    private String message;
    private long timestamp;
    
    // Constructors, getters, setters
}

// Controller-specific exception handling
@Controller
@RequestMapping("/users")
public class UserController {
    
    @ExceptionHandler(UserNotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public String handleUserNotFound(UserNotFoundException ex, Model model) {
        model.addAttribute("error", ex.getMessage());
        return "users/not-found";
    }
    
    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        User user = userService.findById(id)
                .orElseThrow(() -> new UserNotFoundException(id));
        model.addAttribute("user", user);
        return "users/detail";
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="interview" class="section">
                    <h2>üíº Interview Questions</h2>
                    
                    <div class="subsection">
                        <h3>Frequently Asked Questions</h3>
                        
                        <div class="question-block">
                            <h4>Q1: Explain the Spring MVC request flow</h4>
                            <p><strong>Answer:</strong> Request ‚Üí DispatcherServlet ‚Üí HandlerMapping ‚Üí Controller ‚Üí ModelAndView ‚Üí ViewResolver ‚Üí View ‚Üí Response. DispatcherServlet acts as front controller coordinating the entire process.</p>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q2: What's the difference between @Controller and @RestController?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>@Controller:</strong> Returns view names, used for traditional MVC</li>
                                <li><strong>@RestController:</strong> Combines @Controller + @ResponseBody, returns data directly</li>
                                <li><strong>Usage:</strong> @Controller for web pages, @RestController for APIs</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q3: How does data binding work in Spring MVC?</h4>
                            <p><strong>Answer:</strong> Spring MVC automatically binds request parameters to method parameters or model objects using WebDataBinder. Supports form data, JSON, path variables, and request parameters with type conversion.</p>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q4: What are the different ways to handle exceptions in Spring MVC?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>@ExceptionHandler:</strong> Method-level exception handling</li>
                                <li><strong>@ControllerAdvice:</strong> Global exception handling</li>
                                <li><strong>HandlerExceptionResolver:</strong> Custom exception resolution</li>
                                <li><strong>@ResponseStatus:</strong> Map exceptions to HTTP status codes</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q5: Explain validation in Spring MVC</h4>
                            <p><strong>Answer:</strong> Spring MVC integrates with Bean Validation (JSR-303/380) using @Valid annotation. Supports field-level, class-level, and custom validation with BindingResult for error handling.</p>
                        </div>
                    </div>
                </section>

            </div>
            </div>
        </div>
    </div>
    
    <script src="../footer.js"></script>
</body>
</html>