<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />
    <title>JavaScript Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="tutorial-styles.css" />
  </head>
  <body class="page-javascript">
    <header>
      <div class="container">
        <div class="hero">
          <h1>JavaScript Learning Tutorial</h1>
          <p>Master Modern JavaScript Development</p>
        </div>
      </div>
    </header>
    <nav></nav>
    <script>
      window.activePage = "javascript";
    </script>
    <script src="menu.js"></script>

    <script>
      // Syntax highlighting
      document.addEventListener("DOMContentLoaded", function () {
        const codeBlocks = document.querySelectorAll("pre code");
        codeBlocks.forEach((block) => {
          highlightJavaScript(block);
        });
      });

      function highlightJavaScript(element) {
        let code = element.textContent;

        // Keywords
        code = code.replace(
          /\b(const|let|var|function|return|if|else|for|while|do|switch|case|break|continue|try|catch|finally|throw|new|this|class|extends|super|static|async|await|import|export|from|default|typeof|instanceof)\b/g,
          '<span class="keyword">$1</span>'
        );

        // Strings
        code = code.replace(
          /(['"`])((?:\\.|(?!\1)[^\\\r\n])*?)\1/g,
          '<span class="string">$1$2$1</span>'
        );

        // Template literals
        code = code.replace(
          /(`)([^`]*?)(`)/g,
          '<span class="string">$1$2$3</span>'
        );

        // Numbers
        code = code.replace(
          /\b(\d+(?:\.\d+)?)\b/g,
          '<span class="number">$1</span>'
        );

        // Comments
        code = code.replace(
          /\/\*[\s\S]*?\*\//g,
          '<span class="comment">$&</span>'
        );
        code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');

        // Built-in objects and methods
        code = code.replace(
          /\b(console|document|window|Array|Object|String|Number|Boolean|Date|Math|JSON|Promise|Set|Map|WeakMap|WeakSet|RegExp|Error|setTimeout|setInterval|fetch|localStorage|sessionStorage)\b/g,
          '<span class="builtin">$1</span>'
        );

        // Method calls
        code = code.replace(
          /\.(\w+)\s*\(/g,
          '.<span class="method">$1</span>('
        );

        element.innerHTML = code;
      }
    </script>
    <div class="container">
      <div class="content-with-sidebar">
        <div class="sidebar-toc">
          <div class="toc-header">
            <h2>üìö Table of Contents</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#what-is-js">What is JavaScript?</a></li>
              <li><a href="#data-types">Data Types</a></li>
              <li><a href="#variables">Variables & Scope</a></li>
              <li><a href="#functions">Functions & Context</a></li>
              <li><a href="#strings">Strings & Templates</a></li>
              <li><a href="#objects">Objects & Prototypes</a></li>
              <li><a href="#arrays">Arrays & Methods</a></li>
              <li><a href="#promises">Promises & Async/Await</a></li>
              <li><a href="#dom">DOM Manipulation</a></li>
              <li><a href="#closures">Closures & Higher-Order</a></li>
              <li><a href="#errors">Error Handling</a></li>
              <li><a href="#regex">Regular Expressions</a></li>
              <li><a href="#es6">Modern ES6+ Features</a></li>
              <li><a href="#performance">Performance & Best Practices</a></li>
              <li><a href="#nodejs">Node.js Basics</a></li>
              <li><a href="#interview">Interview Questions</a></li>
            </ul>
          </nav>
        </div>
        <div class="main-content">
          <div class="topic">
            <h1>JavaScript Fundamentals Refresher</h1>

            <section id="what-is-js" class="section">
              <h2>üöÄ What is JavaScript?</h2>
              <p><strong>What it is:</strong> JavaScript is a versatile, high-level programming language that runs in browsers and servers (Node.js) for creating interactive web applications.</p>
              <p><strong>How it works:</strong> Interpreted language with dynamic typing, event-driven execution, and single-threaded with asynchronous capabilities through event loop.</p>
              <p><strong>Why use it:</strong> Only language that runs natively in browsers, huge ecosystem, supports multiple programming paradigms, and essential for modern web development.</p>
              
              <div class="subsection">
                <h3>Key Characteristics</h3>
                <ul>
                  <li><strong>Dynamic Typing:</strong> Variables can hold any type of value</li>
                  <li><strong>Event-Driven:</strong> Responds to user interactions and system events</li>
                  <li><strong>Prototype-Based:</strong> Object inheritance through prototypes</li>
                  <li><strong>First-Class Functions:</strong> Functions are values that can be passed around</li>
                  <li><strong>Asynchronous:</strong> Non-blocking operations with callbacks, promises, async/await</li>
                </ul>
              </div>
            </section>

            <section id="data-types" class="section">
              <h2>üìä JavaScript Data Types</h2>
              <p><strong>What it covers:</strong> JavaScript has two categories of data types that behave differently in memory and assignment.</p>
              <p><strong>How they differ:</strong> Primitives are stored by value and immutable, while reference types are stored by reference and mutable.</p>
              
              <div class="subsection">
                <h3>Primitive Types (Stored by Value)</h3>
                <ul>
                  <li><strong>string:</strong> Text data - 'hello', "world", `template`</li>
                  <li><strong>number:</strong> Integers and floats - 42, 3.14, NaN, Infinity</li>
                  <li><strong>boolean:</strong> true or false</li>
                  <li><strong>null:</strong> Intentional absence of value</li>
                  <li><strong>undefined:</strong> Variable declared but not assigned</li>
                  <li><strong>symbol:</strong> Unique identifier (ES6+)</li>
                  <li><strong>bigint:</strong> Large integers beyond Number.MAX_SAFE_INTEGER</li>
                </ul>
              </div>
              
              <div class="subsection">
                <h3>Reference Types (Stored by Reference)</h3>
                <ul>
                  <li><strong>object:</strong> Key-value pairs - {name: 'John'}</li>
                  <li><strong>array:</strong> Ordered list - [1, 2, 3]</li>
                  <li><strong>function:</strong> Reusable code blocks</li>
                  <li><strong>Date, RegExp, Map, Set:</strong> Built-in objects</li>
                </ul>
              </div>
            </section>

            <section id="variables" class="section">
              <h2>üîß Variables & Scope</h2>
              <p><strong>What it does:</strong> Variables store data values and scope determines where variables can be accessed in your code.</p>
              <p><strong>How it works:</strong> JavaScript has function scope (var) and block scope (let/const), with lexical scoping and closure behavior.</p>
              <p><strong>Best Practice:</strong> Use const by default, let when you need to reassign, avoid var completely in modern JavaScript.</p>

              <div class="subsection">
                <h3>Variable Declarations</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// var - function scoped (avoid, legacy)
var x = 5;

// let - block scoped, reassignable (use this)
let count = 0;
if (true) {
    let count = 10;  // Different scope
}
console.log(count);  // 0

// const - block scoped, not reassignable
const PI = 3.14159;
const obj = { name: 'John' };
obj.name = 'Jane';  // OK - modifying object
// obj = {};  // ERROR - can't reassign

// Scope chain & closure
function outer() {
    let a = 5;
    return function inner() {
        return a + 10;  // Access outer 'a'
    };
}
const fn = outer();
console.log(fn());  // 15
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="functions" class="section">
              <h2>‚ö° Functions & Context (this)</h2>
              <p><strong>What it does:</strong> Functions are reusable blocks of code that can accept parameters and return values, with different syntax options.</p>
              <p><strong>How it works:</strong> Regular functions have their own 'this' context, arrow functions inherit 'this' from parent scope.</p>
              <p><strong>Key Difference:</strong> Arrow functions are more concise but can't be used as constructors and don't have their own 'this'.</p>

              <div class="subsection">
                <h3>Function Syntax & Context</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Traditional function
function add(a, b) {
    return a + b;
}

// Arrow function - concise
const add = (a, b) => a + b;
const square = x => x * x;
const greet = () => 'Hello';

// Arrow functions inherit 'this' from parent scope
const person = {
    name: 'John',
    greeting: function() {
        // 'this' = person object
        console.log(this.name);
    },
    arrow: () => {
        // 'this' = window/global, NOT person
        console.log(this);
    }
};

// Default parameters & rest operator
const greet = (name = 'Guest', ...rest) => {
    console.log(name, rest);
};
greet('John', 'a', 'b');  // John ['a', 'b']

// Destructuring
const [a, b, c] = [1, 2, 3];
const { name, age } = { name: 'John', age: 30 };
const person = { name: 'Jane', details: { city: 'NYC' } };
const { details: { city } } = person;  // Nested destructuring
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="strings" class="section">
              <h2>üìù Strings & Template Literals</h2>
              <p><strong>What it does:</strong> Strings represent text data with various methods for manipulation and template literals for dynamic content.</p>
              <p><strong>How it works:</strong> Template literals use backticks and ${} for interpolation, string methods return new strings (immutable).</p>
              <p><strong>Modern Approach:</strong> Use template literals for string interpolation and multi-line strings instead of concatenation.</p>

              <div class="subsection">
                <h3>String Operations</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Template literals with interpolation
const name = 'John';
const age = 30;
const message = `Hello ${name}, you are ${age} years old`;

// Multi-line strings
const html = `
    <div>
        <p>Formatted text</p>
    </div>
`;

// Common string methods
const str = 'JavaScript';
str.charAt(0);           // 'J'
str.indexOf('Script');   // 4
str.includes('Script');  // true
str.slice(0, 4);         // 'Java'
str.substring(0, 4);     // 'Java'
str.toUpperCase();       // 'JAVASCRIPT'
str.split('');           // ['J','a','v','a','S','c','r','i','p','t']
str.replace('Java', 'Type');  // 'TypeScript'
str.trim();              // Remove whitespace
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="objects" class="section">
              <h2>üèóÔ∏è Objects & Prototypes</h2>
              <p><strong>What it does:</strong> Objects store key-value pairs and JavaScript uses prototype-based inheritance for sharing properties and methods.</p>
              <p><strong>How it works:</strong> Every object has a prototype chain, ES6 classes are syntactic sugar over prototype-based inheritance.</p>
              <p><strong>Key Concept:</strong> Understanding prototypes is crucial for JavaScript inheritance and how built-in methods work.</p>

              <div class="subsection">
                <h3>Object Creation & Inheritance</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Object creation
const obj = { name: 'John', age: 30 };
const person = new Object();
person.name = 'John';

// Object methods
Object.keys(obj);              // ['name', 'age']
Object.values(obj);            // ['John', 30]
Object.entries(obj);           // [['name','John'],['age',30]]
Object.assign({}, obj);        // Shallow copy
const copy = { ...obj };       // Spread operator

// Prototypes & Inheritance
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    return `Hello, ${this.name}`;
};

const john = new Person('John', 30);
console.log(john.greet());     // 'Hello, John'
console.log(john instanceof Person);  // true

// ES6 Classes (syntactic sugar over prototypes)
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes sound`;
    }
    
    static info() {
        return 'This is Animal class';
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    speak() {
        return `${this.name} barks`;
    }
}

const dog = new Dog('Buddy', 'Golden');
console.log(dog.speak());      // 'Buddy barks'
console.log(Animal.info());    // Static method
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="arrays" class="section">
              <h2>üìã Arrays & Functional Programming</h2>
              <p><strong>What it does:</strong> Arrays store ordered collections with powerful methods for data transformation and manipulation.</p>
              <p><strong>How it works:</strong> Higher-order methods like map, filter, reduce enable functional programming patterns for cleaner code.</p>
              <p><strong>Performance:</strong> Mutating methods modify original array, non-mutating methods return new arrays - choose based on needs.</p>

              <div class="subsection">
                <h3>Array Operations</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
const arr = [1, 2, 3, 4, 5];

// Mutating methods (modify original)
arr.push(6);                   // Add to end [1,2,3,4,5,6]
arr.unshift(0);                // Add to start [0,1,2,3,4,5,6]
arr.pop();                      // Remove from end
arr.shift();                    // Remove from start
arr.splice(2, 1, 10);          // Remove 1 at index 2, insert 10

// Non-mutating methods (return new array)
arr.slice(1, 3);               // [2, 3]
arr.concat([7, 8]);            // [1,2,3,4,5,7,8]
arr.reverse();                 // Reverse order

// Higher-order methods
arr.map(x => x * 2);           // [2,4,6,8,10]
arr.filter(x => x > 2);        // [3,4,5]
arr.reduce((sum, x) => sum + x, 0);  // 15 (sum)
arr.find(x => x > 3);          // 4 (first match)
arr.findIndex(x => x === 3);   // 2 (index)
arr.some(x => x > 4);          // true
arr.every(x => x > 0);         // true
arr.includes(3);               // true
arr.indexOf(3);                // 2

// Common patterns
const numbers = [1, 2, 3];
const squared = numbers.map(n => n * n);  // [1, 4, 9]

const users = [
    { name: 'John', age: 30 },
    { name: 'Jane', age: 25 }
];
const names = users.map(u => u.name);  // ['John', 'Jane']
const adults = users.filter(u => u.age >= 30);  // [user objects]
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="promises" class="section">
              <h2>üîÑ Asynchronous JavaScript</h2>
              <p><strong>What it does:</strong> Handles asynchronous operations like API calls, file operations, and timers without blocking the main thread.</p>
              <p><strong>How it works:</strong> Promises represent future values, async/await provides synchronous-looking syntax for asynchronous code.</p>
              <p><strong>Evolution:</strong> Callbacks ‚Üí Promises ‚Üí Async/Await, each solving callback hell and improving readability.</p>
              <div class="subsection">
                <h3>Promise Operations</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Promise - handle async operations
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('Success');
        // reject(new Error('Failed'));
    }, 1000);
});

promise
    .then(result => console.log(result))
    .catch(error => console.error(error))
    .finally(() => console.log('Complete'));

// Promise chaining
fetch('/api/users')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));

// Async/Await - cleaner syntax
async function getUsers() {
    try {
        const response = await fetch('/api/users');
        const data = await response.json();
        console.log(data);
        return data;
    } catch (error) {
        console.error('Error:', error);
    } finally {
        console.log('Request completed');
    }
}

// Promise.all - wait for all
const results = await Promise.all([
    fetch('/api/users'),
    fetch('/api/posts'),
    fetch('/api/comments')
]);

// Promise.race - first to complete
const result = await Promise.race([promise1, promise2]);

// Promise.any - first successful
const result = await Promise.any([promise1, promise2]);
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="dom" class="section">
              <h2>üåê DOM Manipulation & Events</h2>
              <p><strong>What it does:</strong> Provides JavaScript interface to interact with HTML elements, modify content, styles, and handle user events.</p>
              <p><strong>How it works:</strong> DOM is a tree structure representing HTML, JavaScript can query, modify, and listen to changes.</p>
              <p><strong>Best Practice:</strong> Use modern query methods, event delegation for dynamic content, and avoid direct style manipulation.</p>
              <div class="subsection">
                <h3>DOM Operations</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Selecting elements
const el = document.getElementById('myId');
const els = document.querySelectorAll('.myClass');
const el = document.querySelector('div > p');

// Modifying content
el.textContent = 'New text';          // Plain text
el.innerHTML = '<b>Bold text</b>';    // HTML
el.innerText = 'Visible text';        // Visible content

// Modifying attributes
el.setAttribute('data-value', '123');
el.getAttribute('data-value');
el.removeAttribute('disabled');
el.classList.add('active');
el.classList.remove('inactive');
el.classList.toggle('hidden');
el.classList.contains('active');      // true/false

// Styling
el.style.color = 'red';
el.style.backgroundColor = 'blue';

// Creating & removing elements
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello';
el.appendChild(newDiv);
el.removeChild(newDiv);
newDiv.remove();                       // Direct removal

// Event listeners
el.addEventListener('click', (e) => {
    console.log('Clicked', e.target);
});

el.addEventListener('click', handler);
el.removeEventListener('click', handler);

// Event delegation
document.addEventListener('click', (e) => {
    if (e.target.matches('.btn')) {
        console.log('Button clicked:', e.target);
    }
});
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="closures" class="section">
              <h2>üîí Closures & Advanced Functions</h2>
              <p><strong>What it does:</strong> Closures allow functions to access variables from outer scope even after outer function returns.</p>
              <p><strong>How it works:</strong> Inner functions maintain reference to outer scope variables, creating private variables and data encapsulation.</p>
              <p><strong>Use Cases:</strong> Module pattern, data privacy, function factories, and maintaining state in functional programming.</p>
              <div class="subsection">
                <h3>Closure Patterns</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Closure - function with access to outer scope
function makeCounter() {
    let count = 0;
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = makeCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getCount());   // 2

// Data privacy pattern
function createUser(name) {
    let _private = 'secret';  // Private variable
    
    return {
        getName: () => name,
        isPrivateAccessible: () => _private
    };
}

// Higher-order functions
const multiply = (factor) => (n) => n * factor;
const double = multiply(2);
const triple = multiply(3);
console.log(double(5));            // 10
console.log(triple(5));            // 15

// Function composition
const compose = (f, g) => (x) => f(g(x));
const add5 = x => x + 5;
const multiply2 = x => x * 2;
const addThenMultiply = compose(multiply2, add5);
console.log(addThenMultiply(3));   // (3+5)*2 = 16
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="errors" class="section">
              <h2>‚ö†Ô∏è Error Handling & Debugging</h2>
              <p><strong>What it does:</strong> Provides mechanisms to catch, handle, and debug errors gracefully without crashing the application.</p>
              <p><strong>How it works:</strong> Try-catch blocks handle synchronous errors, promise .catch() and async/await try-catch handle async errors.</p>
              <p><strong>Best Practice:</strong> Always handle errors appropriately, use specific error types, and provide meaningful error messages.</p>
              <div class="subsection">
                <h3>Error Management</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Try-catch-finally
try {
    const result = riskyOperation();
    console.log(result);
} catch (error) {
    console.error('Error message:', error.message);
    console.error('Stack:', error.stack);
} finally {
    console.log('Cleanup');
}

// Throwing errors
function validateEmail(email) {
    if (!email.includes('@')) {
        throw new Error('Invalid email');
    }
    return true;
}

// Custom error class
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

throw new ValidationError('Email is required');

// Debugging
console.log('Simple:', value);
console.warn('Warning:', issue);
console.error('Error:', problem);
console.table(data);               // Table format
console.group('Group');
    console.log('Item 1');
    console.log('Item 2');
console.groupEnd();
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="regex" class="section">
              <h2>üîç Regular Expressions</h2>
              <p><strong>What it does:</strong> Pattern matching tool for searching, validating, and manipulating strings using special syntax.</p>
              <p><strong>How it works:</strong> Uses metacharacters and quantifiers to define patterns, methods like test(), match(), replace() apply patterns.</p>
              <p><strong>Common Uses:</strong> Form validation, data extraction, string replacement, and input sanitization.</p>
              <div class="subsection">
                <h3>Regex Patterns</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Creating regex
const regex1 = /hello/i;                     // Literal, i=case insensitive
const regex2 = new RegExp('hello', 'i');     // Constructor

// Common patterns
/^[a-z0-9]+@[a-z]+\.[a-z]{2,}$/    // Email validation
/^\d{3}-\d{3}-\d{4}$/               // Phone: 123-456-7890
/^https?:\/\/.+/                   // URL
/^[A-Za-z\s]+$/                    // Only letters and spaces

// Methods
const email = 'john@example.com';
email.match(/[a-z]+/g);             // ['john', 'example', 'com']
email.replace(/@.*/, '');           // 'john'
email.search(/@/);                  // 4
/john/.test(email);                 // true

// Regex flags
/pattern/g                          // global - all matches
/pattern/i                          // case insensitive
/pattern/m                          // multiline
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="es6" class="section">
              <h2>‚ú® Modern ES6+ Features</h2>
              <p><strong>What it covers:</strong> Modern JavaScript features that improve code readability, performance, and developer experience.</p>
              <p><strong>How to adopt:</strong> These features are widely supported and should be used in modern JavaScript development for cleaner code.</p>
              <p><strong>Impact:</strong> Reduces boilerplate code, prevents common errors, and enables more functional programming patterns.</p>
              <div class="subsection">
                <h3>ES6+ Syntax</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Spread operator
const arr = [1, 2, 3];
const arr2 = [...arr, 4, 5];       // [1, 2, 3, 4, 5]
const obj2 = { ...obj1, name: 'Jane' };

// Optional chaining
const city = user?.address?.city;  // undefined if any is null

// Nullish coalescing
const name = user.name ?? 'Guest';  // Use default if null/undefined

// Nullish assignment
user.name ??= 'Anonymous';

// Logical assignment
obj.active ||= true;               // If falsy, assign true
obj.count &&= 5;                   // If truthy, assign 5

// for...of vs for...in
for (const value of arr) { }       // Values of iterable
for (const key in obj) { }         // Keys of object

// Sets & Maps
const uniqueNums = new Set([1, 2, 2, 3, 3, 3]);  // {1, 2, 3}
uniqueNums.add(4);
uniqueNums.has(2);                 // true
uniqueNums.delete(1);

const map = new Map();
map.set('key', 'value');
map.get('key');                    // 'value'
map.has('key');                    // true

// WeakMap & WeakSet (for garbage collection)
const wm = new WeakMap();
let obj = {};
wm.set(obj, 'private data');
                            </code></pre>
                </div>
              </div>
            </section>



            <section id="performance" class="section">
              <h2>‚ö° Performance & Best Practices</h2>
              <p><strong>What it covers:</strong> Techniques to write efficient JavaScript code that performs well and follows industry standards.</p>
              <p><strong>How to apply:</strong> Measure performance first, then optimize bottlenecks using appropriate techniques and patterns.</p>
              <p><strong>Key Principle:</strong> Premature optimization is the root of all evil - write clean code first, optimize when needed.</p>
              <div class="subsection">
                <h3>Optimization Techniques</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Avoid global variables
// ‚ùå BAD
var globalVar = 'bad';

// ‚úÖ GOOD
const local = 'good';
(function() {
    const scoped = 'better';
})();

// Cache DOM queries
// ‚ùå BAD
for (let i = 0; i < 1000; i++) {
    document.querySelector('.item').style.color = 'red';
}

// ‚úÖ GOOD
const element = document.querySelector('.item');
for (let i = 0; i < 1000; i++) {
    element.style.color = 'red';
}

// Debouncing & Throttling
function debounce(fn, delay) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), delay);
    };
}

function throttle(fn, limit) {
    let lastCall = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastCall >= limit) {
            fn(...args);
            lastCall = now;
        }
    };
}

// Memoization - cache function results
function memoize(fn) {
    const cache = {};
    return (arg) => {
        if (arg in cache) return cache[arg];
        cache[arg] = fn(arg);
        return cache[arg];
    };
}

const factorial = memoize((n) => n <= 1 ? 1 : n * factorial(n - 1));
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="nodejs" class="section">
              <h2>üñ•Ô∏è Node.js Basics</h2>
              <p><strong>What it is:</strong> JavaScript runtime built on Chrome's V8 engine that allows JavaScript to run on servers and build backend applications.</p>
              <p><strong>How it works:</strong> Uses event-driven, non-blocking I/O model making it efficient for data-intensive real-time applications.</p>
              <p><strong>Use Cases:</strong> Web servers, APIs, real-time applications, build tools, and command-line utilities.</p>
              <div class="subsection">
                <h3>Server-side JavaScript</h3>
                <div class="code-block">
                  <pre><code class="language-javascript">
// Importing modules
const fs = require('fs');
const express = require('express');

// ES6 imports
import { readFile } from 'fs/promises';
import express from 'express';

// File system operations
fs.readFile('file.txt', 'utf8', (err, data) => {
    if (err) throw err;
    console.log(data);
});

const data = fs.readFileSync('file.txt', 'utf8');

// Express.js - web framework
const app = express();

app.use(express.json());

app.get('/api/users', (req, res) => {
    res.json({ users: [] });
});

app.post('/api/users', (req, res) => {
    const user = req.body;
    res.status(201).json(user);
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});

// Environment variables
require('dotenv').config();
const dbUrl = process.env.DATABASE_URL;
                            </code></pre>
                </div>
              </div>
            </section>

            <section id="interview" class="section">
              <h2>üéØ JavaScript Interview Guide</h2>
              <p><strong>What to expect:</strong> JavaScript interviews focus on core concepts, problem-solving, and understanding of asynchronous programming.</p>
              <p><strong>How to prepare:</strong> Master fundamentals, practice coding problems, and understand how JavaScript works under the hood.</p>
              
              <div class="subsection">
                <h3>Core Concepts to Master</h3>
                <ul>
                  <li><strong>Event Loop:</strong> Call stack, task queue, microtask queue, and how async operations work</li>
                  <li><strong>this Context:</strong> How 'this' behaves in different contexts (methods, arrow functions, bind/call/apply)</li>
                  <li><strong>Type Coercion:</strong> == vs ===, implicit type conversions, and truthy/falsy values</li>
                  <li><strong>Hoisting:</strong> Variable and function hoisting behavior, temporal dead zone</li>
                  <li><strong>Scope & Closures:</strong> Lexical scoping, closure patterns, and memory implications</li>
                  <li><strong>Prototypes:</strong> Prototype chain, inheritance, and how built-in methods work</li>
                  <li><strong>Async Programming:</strong> Callbacks, promises, async/await, and error handling</li>
                </ul>
              </div>
              
              <div class="subsection">
                <h3>Most Asked Interview Questions</h3>
                <ul>
                  <li><strong>Variable Declarations:</strong> Difference between let, const, and var with examples</li>
                  <li><strong>Event Loop:</strong> Explain how JavaScript handles asynchronous operations</li>
                  <li><strong>Closures:</strong> What are closures and provide practical examples</li>
                  <li><strong>Equality:</strong> Difference between == and === with type coercion examples</li>
                  <li><strong>Hoisting:</strong> How hoisting works for variables and functions</li>
                  <li><strong>Array Methods:</strong> Difference between map, filter, reduce, and forEach</li>
                  <li><strong>Promises:</strong> How promises work compared to callbacks, promise chaining</li>
                  <li><strong>this Keyword:</strong> How 'this' works in different contexts</li>
                  <li><strong>Async/Await:</strong> Benefits over promises and error handling patterns</li>
                  <li><strong>Object Copying:</strong> Shallow vs deep copy and implementation methods</li>
                </ul>
              </div>
              
              <div class="subsection">
                <h3>Coding Challenges</h3>
                <p><strong>Common Problems:</strong><br>
                ‚Ä¢ Implement debounce/throttle functions<br>
                ‚Ä¢ Create a deep clone function<br>
                ‚Ä¢ Build a simple promise implementation<br>
                ‚Ä¢ Solve array manipulation problems<br>
                ‚Ä¢ Implement function currying<br>
                ‚Ä¢ Create a module pattern with closures</p>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>
    <script src="footer.js"></script>
  </body>
</html>
