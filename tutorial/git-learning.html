<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Git Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="tutorial-styles.css">
</head>
<body class="page-git">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Git Version Control</h1>
                <p>Master Git for Professional Software Development</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'git';</script>
    <script src="menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightGit(block);
                        updateActiveNav();
        });
                    updateActiveNav();
        });
        
        function highlightGit(element) {
            let code = element.textContent;
            
            code = code.replace(/\b(git|add|commit|push|pull|clone|branch|checkout|merge|rebase|status|log|diff|reset|revert|stash|fetch|remote|init|config)\b/g, '<span class="keyword">$1</span>');
            
            code = code.replace(/--?[a-zA-Z-]+/g, '<span class="method">$&</span>');
            
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            code = code.replace(/#.*$/gm, '<span class="comment">$&</span>');
            
            element.innerHTML = code;
        }
        
        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.toc-nav a');
            
            let currentSection = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentSection = section.id;
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateActiveNav);
        updateActiveNav();
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Git Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Git Overview</a></li>
                        <li><a href="#setup">Setup & Configuration</a></li>
                        <li><a href="#basics">Basic Commands</a></li>
                        <li><a href="#branching">Branching & Merging</a></li>
                        <li><a href="#remote">Remote Repositories</a></li>
                        <li><a href="#advanced">Advanced Features</a></li>
                        <li><a href="#workflows">Git Workflows</a></li>
                        <li><a href="#troubleshooting">Troubleshooting</a></li>
                        <li><a href="#github">GitHub Integration</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="overview" class="section">
                    <h2>üöÄ Git Overview</h2>
                    
                    <div class="subsection">
                        <h3>What is Git?</h3>
                        <p><strong>Definition:</strong> Git is a distributed version control system that tracks changes in source code during software development. It allows multiple developers to work on the same project efficiently and maintains a complete history of all changes.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>Distributed:</strong> Every developer has a complete copy of the project history</li>
                            <li><strong>Branching:</strong> Lightweight branches for parallel development</li>
                            <li><strong>Merging:</strong> Intelligent merge algorithms for combining changes</li>
                            <li><strong>Speed:</strong> Fast operations for most commands</li>
                            <li><strong>Data Integrity:</strong> Cryptographic hashing ensures data integrity</li>
                            <li><strong>Non-linear Development:</strong> Support for complex development workflows</li>
                        </ul>
                        
                        <h4>Git vs Other VCS:</h4>
                        <div class="code-block">
                            <pre><code>Aspect          | Git (Distributed)     | SVN (Centralized)
----------------|------------------------|--------------------
Repository      | Full copy on each dev  | Central server only
Offline Work    | Full functionality     | Limited operations
Branching       | Lightweight & fast     | Heavy operations
Merging         | Advanced algorithms    | Basic merge support
Performance     | Fast local operations  | Network dependent
Backup          | Multiple full copies   | Single point failure</code></pre>
                        </div>
                        
                        <h4>Git Architecture:</h4>
                        <div class="code-block">
                            <pre><code>Working Directory (Your files)
        ‚Üì git add
Staging Area (Index)
        ‚Üì git commit
Local Repository (.git folder)
        ‚Üì git push
Remote Repository (GitHub, GitLab, etc.)</code></pre>
                        </div>
                        
                        <h4>Git States:</h4>
                        <ul>
                            <li><strong>Modified:</strong> Files changed but not staged</li>
                            <li><strong>Staged:</strong> Files marked for next commit</li>
                            <li><strong>Committed:</strong> Files safely stored in local repository</li>
                            <li><strong>Untracked:</strong> Files not under version control</li>
                        </ul>
                    </div>
                </section>

                <section id="setup" class="section">
                    <h2>‚öôÔ∏è Setup & Configuration</h2>
                    
                    <div class="subsection">
                        <h3>Installation and Initial Setup</h3>
                        <div class="code-block">
                            <pre><code># Install Git (varies by OS)
# Windows: Download from git-scm.com
# macOS: brew install git
# Ubuntu: sudo apt install git
# CentOS: sudo yum install git

# Check Git version
git --version

# Global configuration (required for first use)
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"

# Set default branch name
git config --global init.defaultBranch main

# Set default editor
git config --global core.editor "code --wait"  # VS Code
git config --global core.editor "vim"          # Vim
git config --global core.editor "nano"         # Nano

# Configure line endings
git config --global core.autocrlf true    # Windows
git config --global core.autocrlf input   # macOS/Linux

# Set up credential helper
git config --global credential.helper store    # Store credentials
git config --global credential.helper cache    # Cache for 15 minutes

# View all configurations
git config --list
git config --global --list
git config --local --list

# View specific configuration
git config user.name
git config user.email</code></pre>
                        </div>
                        
                        <h3>SSH Key Setup</h3>
                        <div class="code-block">
                            <pre><code># Generate SSH key pair
ssh-keygen -t ed25519 -C "your.email@example.com"
# Or for older systems:
ssh-keygen -t rsa -b 4096 -C "your.email@example.com"

# Start SSH agent
eval "$(ssh-agent -s)"

# Add SSH key to agent
ssh-add ~/.ssh/id_ed25519

# Copy public key to clipboard
# macOS:
pbcopy < ~/.ssh/id_ed25519.pub
# Linux:
xclip -selection clipboard < ~/.ssh/id_ed25519.pub
# Windows:
clip < ~/.ssh/id_ed25519.pub

# Test SSH connection to GitHub
ssh -T git@github.com

# Add SSH key to GitHub:
# 1. Go to GitHub Settings > SSH and GPG keys
# 2. Click "New SSH key"
# 3. Paste your public key</code></pre>
                        </div>
                        
                        <h3>Git Aliases and Advanced Configuration</h3>
                        <div class="code-block">
                            <pre><code># Useful Git aliases
git config --global alias.st status
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.unstage 'reset HEAD --'
git config --global alias.last 'log -1 HEAD'
git config --global alias.visual '!gitk'

# Advanced aliases
git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
git config --global alias.adog "log --all --decorate --oneline --graph"
git config --global alias.plog "log --graph --pretty='format:%C(red)%d%C(reset) %C(yellow)%h%C(reset) %ar %C(green)%aN%C(reset) %s'"

# Configure diff and merge tools
git config --global merge.tool vimdiff
git config --global diff.tool vimdiff

# Configure push behavior
git config --global push.default simple

# Configure pull behavior
git config --global pull.rebase false  # merge (default)
git config --global pull.rebase true   # rebase
git config --global pull.ff only       # fast-forward only

# Ignore file permissions (useful on Windows)
git config --global core.filemode false

# Configure whitespace handling
git config --global core.whitespace trailing-space,space-before-tab
git config --global apply.whitespace fix</code></pre>
                        </div>
                    </div>
                </section>

                <section id="basics" class="section">
                    <h2>üìù Basic Commands</h2>
                    
                    <div class="subsection">
                        <h3>Repository Initialization and Basic Operations</h3>
                        <div class="code-block">
                            <pre><code># Initialize a new Git repository
git init
git init my-project

# Clone an existing repository
git clone https://github.com/user/repo.git
git clone https://github.com/user/repo.git my-folder
git clone --depth 1 https://github.com/user/repo.git  # Shallow clone

# Check repository status
git status
git status -s  # Short format
git status -b  # Show branch info

# Add files to staging area
git add file.txt                    # Add specific file
git add .                          # Add all files in current directory
git add -A                         # Add all files in repository
git add *.js                       # Add all JavaScript files
git add -p                         # Interactive staging (patch mode)

# Remove files from staging area
git reset file.txt                 # Unstage specific file
git reset                          # Unstage all files

# Commit changes
git commit -m "Add new feature"
git commit -am "Add and commit all tracked files"
git commit --amend -m "Updated commit message"
git commit --amend --no-edit       # Amend without changing message

# View commit history
git log
git log --oneline                  # Compact format
git log --graph                    # Show branch graph
git log --stat                     # Show file statistics
git log -p                         # Show patch (diff)
git log -n 5                       # Show last 5 commits
git log --since="2 weeks ago"      # Commits from last 2 weeks
git log --author="John Doe"        # Commits by specific author
git log --grep="bug fix"           # Search commit messages

# View differences
git diff                           # Working directory vs staging area
git diff --staged                  # Staging area vs last commit
git diff HEAD                      # Working directory vs last commit
git diff commit1 commit2           # Between two commits
git diff branch1 branch2           # Between two branches</code></pre>
                        </div>
                        
                        <h3>File Operations and Tracking</h3>
                        <div class="code-block">
                            <pre><code># Remove files
git rm file.txt                    # Remove file and stage deletion
git rm --cached file.txt           # Remove from Git but keep in working directory
git rm -r directory/               # Remove directory recursively

# Move/rename files
git mv old-name.txt new-name.txt
git mv file.txt directory/

# Ignore files (.gitignore)
# Create .gitignore file with patterns:
*.log                              # Ignore all .log files
node_modules/                      # Ignore node_modules directory
.env                              # Ignore environment files
!important.log                     # Don't ignore this specific file

# Global gitignore
git config --global core.excludesfile ~/.gitignore_global

# Track empty directories (Git doesn't track empty directories)
# Create .gitkeep file in empty directory
touch empty-directory/.gitkeep

# View file history
git log --follow file.txt          # Follow file through renames
git log -p file.txt                # Show changes to specific file
git blame file.txt                 # Show who changed each line
git show commit-hash:file.txt      # Show file content at specific commit

# Restore files
git checkout -- file.txt           # Restore file from last commit
git checkout commit-hash -- file.txt # Restore file from specific commit
git restore file.txt               # New syntax (Git 2.23+)
git restore --staged file.txt      # Unstage file
git restore --source=HEAD~1 file.txt # Restore from specific commit</code></pre>
                        </div>
                        
                        <h3>Viewing and Searching</h3>
                        <div class="code-block">
                            <pre><code># Show commit details
git show                           # Show last commit
git show commit-hash               # Show specific commit
git show HEAD~2                    # Show commit 2 steps back
git show branch-name               # Show last commit on branch

# Search in repository
git grep "search term"             # Search in working directory
git grep "search term" commit-hash # Search in specific commit
git grep -n "search term"          # Show line numbers
git grep -i "search term"          # Case insensitive search

# Find commits that introduced/removed text
git log -S "function name"         # Pickaxe search
git log -G "regex pattern"         # Regex search in changes

# Show references
git show-ref                       # Show all references
git ls-remote origin               # Show remote references

# Show repository information
git remote -v                      # Show remote URLs
git branch -a                      # Show all branches
git tag                           # Show all tags

# File content at different points
git show HEAD:file.txt             # File content at HEAD
git show branch:file.txt           # File content on branch
git show tag:file.txt              # File content at tag

# Compare file between commits
git diff HEAD~1 HEAD file.txt      # Compare file between commits
git diff branch1:file.txt branch2:file.txt # Compare file between branches</code></pre>
                        </div>
                    </div>
                </section>

                <section id="branching" class="section">
                    <h2>üåø Branching & Merging</h2>
                    
                    <div class="subsection">
                        <h3>Branch Management</h3>
                        <div class="code-block">
                            <pre><code># Create and manage branches
git branch                         # List local branches
git branch -a                      # List all branches (local + remote)
git branch -r                      # List remote branches
git branch new-feature             # Create new branch
git branch -d feature-branch       # Delete merged branch
git branch -D feature-branch       # Force delete branch
git branch -m old-name new-name    # Rename branch

# Switch between branches
git checkout branch-name           # Switch to existing branch
git checkout -b new-branch         # Create and switch to new branch
git checkout -b new-branch origin/remote-branch # Create branch from remote

# New syntax (Git 2.23+)
git switch branch-name             # Switch to existing branch
git switch -c new-branch           # Create and switch to new branch
git switch -                       # Switch to previous branch

# Track remote branches
git branch -u origin/main          # Set upstream for current branch
git branch --set-upstream-to=origin/main main
git checkout -b local-branch origin/remote-branch # Create tracking branch

# Branch information
git branch -v                      # Show last commit on each branch
git branch --merged                # Show merged branches
git branch --no-merged             # Show unmerged branches
git branch --contains commit-hash  # Branches containing specific commit</code></pre>
                        </div>
                        
                        <h3>Merging Strategies</h3>
                        <div class="code-block">
                            <pre><code># Basic merging
git checkout main                  # Switch to target branch
git merge feature-branch           # Merge feature branch into main

# Merge strategies
git merge --no-ff feature-branch   # Force merge commit (no fast-forward)
git merge --ff-only feature-branch # Only if fast-forward possible
git merge --squash feature-branch  # Squash all commits into one

# Merge with custom message
git merge feature-branch -m "Merge feature: Add user authentication"

# Abort merge if conflicts
git merge --abort

# Continue merge after resolving conflicts
git merge --continue

# Three-way merge example
# When branches have diverged:
#     A---B---C feature
#    /
# D---E---F---G main
# 
# Result after merge:
#     A---B---C feature
#    /         \
# D---E---F---G---H main (H is merge commit)

# Fast-forward merge example
# When target branch hasn't changed:
# D---E---F main
#         \
#          G---H feature
#
# Result after fast-forward:
# D---E---F---G---H main (no merge commit)</code></pre>
                        </div>
                        
                        <h3>Rebasing</h3>
                        <div class="code-block">
                            <pre><code># Basic rebase
git checkout feature-branch
git rebase main                    # Rebase feature branch onto main

# Interactive rebase
git rebase -i HEAD~3               # Rebase last 3 commits interactively
git rebase -i main                 # Interactive rebase onto main

# Interactive rebase options:
# pick = use commit as-is
# reword = use commit, but edit message
# edit = use commit, but stop for amending
# squash = use commit, but meld into previous commit
# fixup = like squash, but discard commit message
# drop = remove commit

# Example interactive rebase:
pick f7f3f6d Add feature A
squash 310154e Fix typo in feature A
reword a5f4a0d Add feature B
drop c3d2c1b Temporary debug code

# Rebase vs Merge comparison:
# Rebase: Creates linear history, rewrites commits
# Before rebase:
#     A---B---C feature
#    /
# D---E---F main
#
# After rebase:
# D---E---F---A'---B'---C' main (linear history)

# Merge: Preserves history, creates merge commit
# After merge:
#     A---B---C feature
#    /         \
# D---E---F-----M main (M is merge commit)

# Abort rebase
git rebase --abort

# Continue rebase after resolving conflicts
git add resolved-file.txt
git rebase --continue

# Skip problematic commit during rebase
git rebase --skip</code></pre>
                        </div>
                        
                        <h3>Conflict Resolution</h3>
                        <div class="code-block">
                            <pre><code># When conflicts occur during merge/rebase:
# Git marks conflicts in files like this:
<<<<<<< HEAD
Current branch content
=======
Incoming branch content
>>>>>>> feature-branch

# Steps to resolve conflicts:
1. git status                      # See conflicted files
2. # Edit files to resolve conflicts
3. git add resolved-file.txt       # Stage resolved files
4. git commit                      # Complete merge (or git rebase --continue)

# Merge tools for conflict resolution
git mergetool                      # Launch configured merge tool
git mergetool --tool=vimdiff       # Use specific tool

# View conflict details
git diff                           # Show current conflicts
git log --merge                    # Show commits that caused conflicts
git show :1:file.txt               # Common ancestor version
git show :2:file.txt               # Current branch version (HEAD)
git show :3:file.txt               # Incoming branch version

# Checkout specific version during conflict
git checkout --ours file.txt       # Keep current branch version
git checkout --theirs file.txt     # Keep incoming branch version

# Prevent conflicts with merge strategies
git merge -X ours feature-branch   # Prefer current branch in conflicts
git merge -X theirs feature-branch # Prefer incoming branch in conflicts
git merge -X ignore-space-change feature-branch # Ignore whitespace changes</code></pre>
                        </div>
                    </div>
                </section>

                <section id="remote" class="section">
                    <h2>üåê Remote Repositories</h2>
                    
                    <div class="subsection">
                        <h3>Remote Management</h3>
                        <div class="code-block">
                            <pre><code># Add remote repositories
git remote add origin https://github.com/user/repo.git
git remote add upstream https://github.com/original/repo.git

# View remotes
git remote                         # List remote names
git remote -v                      # List remotes with URLs
git remote show origin             # Detailed info about remote

# Change remote URL
git remote set-url origin https://github.com/user/new-repo.git
git remote set-url origin git@github.com:user/repo.git  # Switch to SSH

# Remove remote
git remote remove origin
git remote rm origin

# Rename remote
git remote rename origin upstream

# Fetch from remotes
git fetch                          # Fetch from default remote (origin)
git fetch origin                   # Fetch from specific remote
git fetch --all                    # Fetch from all remotes
git fetch origin branch-name       # Fetch specific branch

# Pull changes (fetch + merge)
git pull                           # Pull from tracking branch
git pull origin main               # Pull specific branch
git pull --rebase                  # Pull with rebase instead of merge
git pull --ff-only                 # Only fast-forward pulls

# Push changes
git push                           # Push to tracking branch
git push origin main               # Push to specific branch
git push -u origin feature-branch  # Push and set upstream
git push --all                     # Push all branches
git push --tags                    # Push all tags
git push origin --delete branch-name # Delete remote branch</code></pre>
                        </div>
                        
                        <h3>Tracking Branches</h3>
                        <div class="code-block">
                            <pre><code># Set up tracking branches
git branch -u origin/main          # Set upstream for current branch
git branch --set-upstream-to=origin/main main
git checkout -b local-branch origin/remote-branch # Create tracking branch

# View tracking information
git branch -vv                     # Show tracking info for all branches
git status                         # Shows ahead/behind info

# Push new branch and set upstream
git push -u origin new-feature     # Push and track
git push --set-upstream origin new-feature

# Sync with remote changes
git fetch origin
git reset --hard origin/main       # Reset local branch to match remote
git pull --rebase origin main      # Rebase local changes on top of remote

# Prune deleted remote branches
git remote prune origin            # Remove stale remote-tracking branches
git fetch --prune                  # Fetch and prune in one command

# Working with forks (common in open source)
git remote add upstream https://github.com/original/repo.git
git fetch upstream
git checkout main
git merge upstream/main            # Sync with original repository
git push origin main               # Update your fork</code></pre>
                        </div>
                    </div>
                </section>

                <section id="advanced" class="section">
                    <h2>üîß Advanced Features</h2>
                    
                    <div class="subsection">
                        <h3>Stashing</h3>
                        <div class="code-block">
                            <pre><code># Basic stashing
git stash                          # Stash current changes
git stash push -m "Work in progress on feature X"
git stash list                     # List all stashes
git stash show                     # Show stash contents
git stash show -p                  # Show stash diff

# Apply stashes
git stash pop                      # Apply and remove latest stash
git stash apply                    # Apply latest stash (keep in stash list)
git stash apply stash@{2}          # Apply specific stash
git stash drop                     # Delete latest stash
git stash drop stash@{1}           # Delete specific stash
git stash clear                    # Delete all stashes

# Advanced stashing
git stash push -u                  # Include untracked files
git stash push --include-untracked # Include untracked files
git stash push --keep-index        # Stash but keep staged changes
git stash push -- file1.txt file2.txt # Stash specific files

# Create branch from stash
git stash branch new-branch-name   # Create branch and apply stash</code></pre>
                        </div>
                        
                        <h3>Reset and Revert</h3>
                        <div class="code-block">
                            <pre><code># Reset types
git reset --soft HEAD~1           # Move HEAD, keep staging area and working directory
git reset --mixed HEAD~1          # Move HEAD, reset staging area (default)
git reset --hard HEAD~1           # Move HEAD, reset staging area and working directory

# Reset examples
git reset HEAD~2                   # Undo last 2 commits, keep changes in working directory
git reset --hard HEAD~2           # Undo last 2 commits, discard all changes
git reset commit-hash              # Reset to specific commit

# Reset specific files
git reset HEAD file.txt            # Unstage file
git reset commit-hash file.txt     # Reset file to specific commit

# Revert commits (safe for shared repositories)
git revert HEAD                    # Create new commit that undoes last commit
git revert HEAD~2                  # Revert commit 2 steps back
git revert commit-hash             # Revert specific commit
git revert --no-commit HEAD~3..HEAD # Revert range of commits without auto-commit

# Difference between reset and revert:
# Reset: Moves branch pointer, rewrites history (dangerous for shared repos)
# Revert: Creates new commit that undoes changes (safe for shared repos)

# Reflog - recover "lost" commits
git reflog                         # Show reference log
git reflog show HEAD               # Show HEAD movements
git reset --hard HEAD@{2}         # Reset to previous HEAD position
git cherry-pick commit-hash       # Apply specific commit</code></pre>
                        </div>
                        
                        <h3>Tags</h3>
                        <div class="code-block">
                            <pre><code># Create tags
git tag v1.0.0                     # Lightweight tag
git tag -a v1.0.0 -m "Version 1.0.0 release" # Annotated tag (recommended)
git tag -a v1.0.0 commit-hash -m "Tag specific commit"

# List tags
git tag                            # List all tags
git tag -l "v1.*"                  # List tags matching pattern
git show v1.0.0                    # Show tag information

# Push tags
git push origin v1.0.0             # Push specific tag
git push origin --tags             # Push all tags
git push --follow-tags             # Push commits and reachable tags

# Delete tags
git tag -d v1.0.0                  # Delete local tag
git push origin --delete v1.0.0    # Delete remote tag
git push origin :refs/tags/v1.0.0  # Alternative delete syntax

# Checkout tags
git checkout v1.0.0                # Checkout specific tag (detached HEAD)
git checkout -b hotfix-1.0.1 v1.0.0 # Create branch from tag

# Semantic versioning with tags
git tag -a v1.2.3 -m "Release version 1.2.3"
# v1.2.3 = MAJOR.MINOR.PATCH
# MAJOR: incompatible API changes
# MINOR: backwards-compatible functionality
# PATCH: backwards-compatible bug fixes</code></pre>
                        </div>
                        
                        <h3>Cherry-picking and Bisect</h3>
                        <div class="code-block">
                            <pre><code># Cherry-pick commits
git cherry-pick commit-hash        # Apply specific commit to current branch
git cherry-pick commit1 commit2    # Apply multiple commits
git cherry-pick commit1..commit3   # Apply range of commits
git cherry-pick --no-commit commit-hash # Apply without committing

# Cherry-pick with conflicts
git cherry-pick commit-hash
# Resolve conflicts, then:
git add resolved-files
git cherry-pick --continue
# Or abort:
git cherry-pick --abort

# Binary search for bugs (git bisect)
git bisect start                   # Start bisect session
git bisect bad                     # Mark current commit as bad
git bisect good v1.0.0             # Mark known good commit
# Git will checkout middle commit
# Test the commit, then mark as good or bad:
git bisect good                    # If commit is good
git bisect bad                     # If commit is bad
# Repeat until Git finds the problematic commit
git bisect reset                   # End bisect session

# Automated bisect
git bisect start HEAD v1.0.0
git bisect run ./test-script.sh    # Run script to test each commit
# Script should exit with 0 for good, non-zero for bad

# Worktrees (multiple working directories)
git worktree add ../feature-branch feature-branch
git worktree list                  # List all worktrees
git worktree remove ../feature-branch</code></pre>
                        </div>
                    </div>
                </section>

                <section id="workflows" class="section">
                    <h2>üîÑ Git Workflows</h2>
                    
                    <div class="subsection">
                        <h3>Centralized Workflow</h3>
                        <div class="code-block">
                            <pre><code># Simple workflow for small teams
# Everyone works on main branch

# Developer workflow:
git clone https://github.com/team/project.git
cd project

# Make changes
git add .
git commit -m "Add new feature"

# Before pushing, sync with remote
git pull origin main               # Get latest changes
# Resolve conflicts if any
git push origin main               # Push changes

# If push is rejected due to conflicts:
git pull --rebase origin main     # Rebase local commits
# Resolve conflicts, then:
git rebase --continue
git push origin main</code></pre>
                        </div>
                        
                        <h3>Feature Branch Workflow</h3>
                        <div class="code-block">
                            <pre><code># Each feature developed in separate branch
# Main branch always stable

# Start new feature
git checkout main
git pull origin main
git checkout -b feature/user-authentication

# Develop feature
git add .
git commit -m "Add login form"
git commit -m "Add password validation"
git commit -m "Add user session management"

# Push feature branch
git push -u origin feature/user-authentication

# Create Pull Request on GitHub/GitLab
# After review and approval, merge to main

# Clean up after merge
git checkout main
git pull origin main
git branch -d feature/user-authentication
git push origin --delete feature/user-authentication</code></pre>
                        </div>
                        
                        <h3>Gitflow Workflow</h3>
                        <div class="code-block">
                            <pre><code># Structured workflow with specific branch types
# Branches: main, develop, feature/*, release/*, hotfix/*

# Initialize gitflow
git flow init

# Feature development
git flow feature start new-feature
# Work on feature...
git add .
git commit -m "Implement new feature"
git flow feature finish new-feature  # Merges to develop

# Release preparation
git flow release start 1.2.0
# Bug fixes and version updates...
git commit -m "Bump version to 1.2.0"
git flow release finish 1.2.0        # Merges to main and develop, creates tag

# Hotfix for production
git flow hotfix start critical-bug
# Fix the bug...
git commit -m "Fix critical security issue"
git flow hotfix finish critical-bug  # Merges to main and develop

# Manual gitflow (without git-flow extension)
# Feature branch
git checkout develop
git checkout -b feature/new-feature
# Work and commit...
git checkout develop
git merge --no-ff feature/new-feature
git branch -d feature/new-feature

# Release branch
git checkout develop
git checkout -b release/1.2.0
# Prepare release...
git checkout main
git merge --no-ff release/1.2.0
git tag -a v1.2.0 -m "Release version 1.2.0"
git checkout develop
git merge --no-ff release/1.2.0
git branch -d release/1.2.0</code></pre>
                        </div>
                        
                        <h3>Forking Workflow</h3>
                        <div class="code-block">
                            <pre><code># Common in open source projects
# Each developer has their own fork

# Fork repository on GitHub, then clone your fork
git clone https://github.com/yourusername/project.git
cd project

# Add upstream remote (original repository)
git remote add upstream https://github.com/original/project.git

# Create feature branch
git checkout -b feature/awesome-feature

# Make changes and commit
git add .
git commit -m "Add awesome feature"

# Push to your fork
git push origin feature/awesome-feature

# Create Pull Request from your fork to upstream

# Keep your fork synced with upstream
git fetch upstream
git checkout main
git merge upstream/main
git push origin main

# Alternative: rebase your feature branch
git checkout feature/awesome-feature
git rebase upstream/main
git push --force-with-lease origin feature/awesome-feature</code></pre>
                        </div>
                    </div>
                </section>

                <section id="troubleshooting" class="section">
                    <h2>üîß Troubleshooting</h2>
                    
                    <div class="subsection">
                        <h3>Common Issues and Solutions</h3>
                        <div class="code-block">
                            <pre><code># Undo last commit (not pushed yet)
git reset --soft HEAD~1            # Keep changes staged
git reset HEAD~1                   # Keep changes in working directory
git reset --hard HEAD~1            # Discard all changes

# Undo last commit (already pushed)
git revert HEAD                    # Create new commit that undoes last commit

# Fix commit message
git commit --amend -m "Corrected commit message"

# Add forgotten files to last commit
git add forgotten-file.txt
git commit --amend --no-edit

# Recover deleted branch
git reflog                         # Find commit hash of deleted branch
git checkout -b recovered-branch commit-hash

# Recover deleted commits
git reflog                         # Find lost commit
git cherry-pick commit-hash        # Apply lost commit
# Or create branch from lost commit:
git checkout -b recovery commit-hash

# Fix "detached HEAD" state
git checkout main                  # Switch to a branch
# Or create new branch from current state:
git checkout -b new-branch-name

# Remove file from Git but keep locally
git rm --cached file.txt
echo "file.txt" >> .gitignore
git add .gitignore
git commit -m "Remove file.txt from tracking"

# Clean up repository
git clean -n                       # Show what would be deleted (dry run)
git clean -f                       # Delete untracked files
git clean -fd                      # Delete untracked files and directories
git clean -fx                      # Delete untracked and ignored files

# Fix line ending issues
git config core.autocrlf true      # Windows
git config core.autocrlf input     # macOS/Linux
git add --renormalize .            # Renormalize all files
git commit -m "Fix line endings"</code></pre>
                        </div>
                        
                        <h3>Merge Conflicts</h3>
                        <div class="code-block">
                            <pre><code># When merge conflicts occur:
# 1. Git marks conflicts in files:
<<<<<<< HEAD
Your changes
=======
Incoming changes
>>>>>>> branch-name

# 2. Resolve conflicts manually or use merge tool
git mergetool

# 3. Stage resolved files
git add resolved-file.txt

# 4. Complete merge
git commit

# Prevent conflicts:
# - Pull frequently
# - Use smaller, focused commits
# - Communicate with team about file changes
# - Use .gitattributes for merge strategies

# Example .gitattributes:
*.generated merge=ours             # Always use our version
*.config merge=union               # Combine both versions
database.xml merge=ours            # Always use our version for database config

# Abort merge if too complex
git merge --abort
git reset --hard HEAD              # Reset to pre-merge state</code></pre>
                        </div>
                        
                        <h3>Performance and Maintenance</h3>
                        <div class="code-block">
                            <pre><code># Repository maintenance
git gc                             # Garbage collection
git gc --aggressive                # More thorough cleanup
git prune                          # Remove unreachable objects
git fsck                           # Check repository integrity

# Reduce repository size
git count-objects -vH              # Show repository size
git clean -fd                      # Remove untracked files
git filter-branch --tree-filter 'rm -rf large-directory' HEAD # Remove directory from history
git filter-repo --path large-file.zip --invert-paths # Remove file from history (requires git-filter-repo)

# Speed up operations
git config core.preloadindex true
git config core.fscache true       # Windows only
git config gc.auto 256

# Shallow clone for faster downloads
git clone --depth 1 https://github.com/user/repo.git
git fetch --unshallow              # Convert to full repository later

# Partial clone (Git 2.19+)
git clone --filter=blob:none https://github.com/user/repo.git # No blobs
git clone --filter=tree:0 https://github.com/user/repo.git    # No trees or blobs</code></pre>
                        </div>
                    </div>
                </section>

                <section id="interview" class="section">
                    <h2>üíº Interview Questions</h2>
                    
                    <div class="subsection">
                        <h3>Frequently Asked Questions</h3>
                        
                        <div class="question-block">
                            <h4>Q1: What is Git and how does it differ from other version control systems?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Git:</strong> Distributed version control system with complete local repositories</li>
                                <li><strong>Key differences:</strong> Distributed vs centralized, branching model, performance</li>
                                <li><strong>Benefits:</strong> Offline work, fast operations, flexible workflows</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q2: Explain the difference between git merge and git rebase</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Merge:</strong> Creates merge commit, preserves history, shows when branches were integrated</li>
                                <li><strong>Rebase:</strong> Rewrites history, creates linear timeline, cleaner history</li>
                                <li><strong>Use merge:</strong> For feature integration, when history context matters</li>
                                <li><strong>Use rebase:</strong> For cleaning up local commits, maintaining linear history</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q3: What are the three states of files in Git?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Modified:</strong> Files changed but not staged for commit</li>
                                <li><strong>Staged:</strong> Files marked for inclusion in next commit</li>
                                <li><strong>Committed:</strong> Files safely stored in local repository</li>
                                <li><strong>Additional:</strong> Untracked files not under version control</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q4: How do you undo the last commit?</h4>
                            <p><strong>Answer:</strong> Depends on whether it's been pushed:</p>
                            <ul>
                                <li><strong>Not pushed:</strong> git reset --soft HEAD~1 (keep changes) or git reset --hard HEAD~1 (discard changes)</li>
                                <li><strong>Already pushed:</strong> git revert HEAD (creates new commit that undoes changes)</li>
                                <li><strong>Amend:</strong> git commit --amend for fixing last commit message/content</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q5: Explain Git workflow strategies</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>Centralized:</strong> Everyone works on main branch, simple but limited</li>
                                <li><strong>Feature Branch:</strong> Each feature in separate branch, good for teams</li>
                                <li><strong>Gitflow:</strong> Structured with main/develop/feature/release/hotfix branches</li>
                                <li><strong>Forking:</strong> Each developer has own fork, common in open source</li>
                            </ul>
                        </div>
                    </div>
                </section>

            </div>
            </div>
        </div>
    </div>
    
    <script src="footer.js"></script>
</body>
</html>