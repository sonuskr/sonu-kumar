<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Java Collections Framework - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-java">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Java Collections Framework</h1>
                <p>Master Data Structures & Collection APIs for Professional Development</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'java';</script>
    <script src="../menu.js"></script>
    
    <script>
        // Syntax highlighting for Java code
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightJava(block);
            });
        });
        
        function highlightJava(element) {
            let code = element.textContent;
            
            // Java keywords
            code = code.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert)\b/g, '<span class="keyword">$1</span>');
            
            // Strings
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            // Comments
            code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');
            code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            // Numbers
            code = code.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span class="number">$&</span>');
            
            // Method calls
            code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="method">$1</span>(');
            
            // Class names (capitalized words)
            code = code.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span class="class">$&</span>');
            
            element.innerHTML = code;
        }
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Collections Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Collections Overview</a></li>
                        <li><a href="#list">List Interface</a></li>
                        <li><a href="#set">Set Interface</a></li>
                        <li><a href="#map">Map Interface</a></li>
                        <li><a href="#queue">Queue & Deque</a></li>
                        <li><a href="#iterators">Iterators</a></li>
                        <li><a href="#algorithms">Collections Algorithms</a></li>
                        <li><a href="#generics">Generics</a></li>
                        <li><a href="#concurrent">Concurrent Collections</a></li>
                        <li><a href="#performance">Performance Comparison</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="overview" class="section">
                    <h2>üèóÔ∏è Collections Framework Overview</h2>
                    
                    <div class="subsection">
                        <h3>What is Collections Framework?</h3>
                        <p><strong>Definition:</strong> A unified architecture for representing and manipulating collections of objects. It provides interfaces, implementations, and algorithms to work with groups of objects.</p>
                        
                        <h4>Why Collections Framework?</h4>
                        <ul>
                            <li><strong>Consistency:</strong> Common interface for all collection types</li>
                            <li><strong>Performance:</strong> Optimized implementations for different use cases</li>
                            <li><strong>Interoperability:</strong> Collections can work together seamlessly</li>
                            <li><strong>Reusability:</strong> Standard algorithms work on all collections</li>
                        </ul>
                        
                        <h4>Core Interfaces Hierarchy:</h4>
                        <div class="code-block">
                            <pre><code>Collection (interface)
‚îú‚îÄ‚îÄ List (interface) - Ordered, allows duplicates
‚îÇ   ‚îú‚îÄ‚îÄ ArrayList (class)
‚îÇ   ‚îú‚îÄ‚îÄ LinkedList (class)
‚îÇ   ‚îî‚îÄ‚îÄ Vector (class)
‚îú‚îÄ‚îÄ Set (interface) - No duplicates
‚îÇ   ‚îú‚îÄ‚îÄ HashSet (class)
‚îÇ   ‚îú‚îÄ‚îÄ LinkedHashSet (class)
‚îÇ   ‚îî‚îÄ‚îÄ TreeSet (class)
‚îî‚îÄ‚îÄ Queue (interface) - FIFO operations
    ‚îú‚îÄ‚îÄ LinkedList (class)
    ‚îú‚îÄ‚îÄ PriorityQueue (class)
    ‚îî‚îÄ‚îÄ ArrayDeque (class)

Map (interface) - Key-value pairs
‚îú‚îÄ‚îÄ HashMap (class)
‚îú‚îÄ‚îÄ LinkedHashMap (class)
‚îú‚îÄ‚îÄ TreeMap (class)
‚îî‚îÄ‚îÄ Hashtable (class)</code></pre>
                        </div>
                        
                        <h4>Key Characteristics:</h4>
                        <ul>
                            <li><strong>Generic:</strong> Type-safe collections using generics</li>
                            <li><strong>Fail-fast:</strong> Iterators detect concurrent modifications</li>
                            <li><strong>Serializable:</strong> Most collections implement Serializable</li>
                            <li><strong>Thread-safety:</strong> Some collections are thread-safe, others are not</li>
                        </ul>
                    </div>
                </section>

                <section id="list" class="section">
                    <h2>üìã List Interface</h2>
                    
                    <div class="subsection">
                        <h3>What is List?</h3>
                        <p><strong>Definition:</strong> An ordered collection that allows duplicate elements. Elements can be accessed by index and inserted at specific positions.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>Indexed Access:</strong> Elements accessible by index (0-based)</li>
                            <li><strong>Ordered:</strong> Maintains insertion order</li>
                            <li><strong>Duplicates Allowed:</strong> Same element can appear multiple times</li>
                            <li><strong>Dynamic Size:</strong> Can grow and shrink during runtime</li>
                        </ul>
                        
                        <h3>ArrayList - Dynamic Array</h3>
                        <p><strong>When to use:</strong> When you need fast random access and frequent read operations.</p>
                        <p><strong>Performance:</strong> O(1) for get/set, O(n) for add/remove in middle.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class ArrayListDemo {
    public static void main(String[] args) {
        // Creating ArrayList
        List<String> fruits = new ArrayList<>();
        
        // Adding elements
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Orange");
        fruits.add(1, "Mango");  // Insert at index 1
        
        // Accessing elements
        String first = fruits.get(0);        // "Apple"
        int size = fruits.size();            // 4
        boolean hasApple = fruits.contains("Apple");  // true
        
        // Modifying elements
        fruits.set(0, "Grapes");            // Replace at index 0
        fruits.remove("Banana");            // Remove by value
        fruits.remove(1);                   // Remove by index
        
        // Iterating
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // Using Iterator
        Iterator<String> it = fruits.iterator();
        while (it.hasNext()) {
            String fruit = it.next();
            if (fruit.equals("Orange")) {
                it.remove();  // Safe removal during iteration
            }
        }
        
        // Bulk operations
        List<String> moreFruits = Arrays.asList("Kiwi", "Pear");
        fruits.addAll(moreFruits);          // Add all elements
        fruits.removeAll(moreFruits);       // Remove all elements
        
        // Searching
        int index = fruits.indexOf("Apple");     // First occurrence
        int lastIndex = fruits.lastIndexOf("Apple");  // Last occurrence
        
        // Sublist
        List<String> subList = fruits.subList(1, 3);  // Elements 1 to 2
        
        // Converting to array
        String[] array = fruits.toArray(new String[0]);
        
        System.out.println("Final list: " + fruits);
    }
}</code></pre>
                        </div>
                        
                        <h3>LinkedList - Doubly Linked List</h3>
                        <p><strong>When to use:</strong> When you need frequent insertions/deletions at beginning or middle.</p>
                        <p><strong>Performance:</strong> O(1) for add/remove at ends, O(n) for random access.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class LinkedListDemo {
    public static void main(String[] args) {
        LinkedList<Integer> numbers = new LinkedList<>();
        
        // Adding elements
        numbers.add(10);
        numbers.add(20);
        numbers.addFirst(5);     // Add at beginning
        numbers.addLast(30);     // Add at end
        
        // Accessing elements
        int first = numbers.getFirst();    // 5
        int last = numbers.getLast();      // 30
        int second = numbers.get(1);       // 10
        
        // Removing elements
        int removedFirst = numbers.removeFirst();  // 5
        int removedLast = numbers.removeLast();    // 30
        
        // Queue operations (LinkedList implements Queue)
        numbers.offer(40);       // Add to end (same as add)
        int head = numbers.poll();  // Remove and return first element
        int peek = numbers.peek();  // Return first element without removing
        
        // Stack operations (LinkedList implements Deque)
        numbers.push(50);        // Add to beginning
        int popped = numbers.pop();  // Remove from beginning
        
        System.out.println("LinkedList: " + numbers);
    }
}</code></pre>
                        </div>
                        
                        <h3>Vector - Synchronized ArrayList</h3>
                        <p><strong>When to use:</strong> Legacy code or when you need thread-safe list (prefer Collections.synchronizedList()).</p>
                        <p><strong>Note:</strong> Vector is synchronized but has performance overhead. Use ArrayList with external synchronization instead.</p>
                    </div>
                </section>

                <section id="set" class="section">
                    <h2>üéØ Set Interface</h2>
                    
                    <div class="subsection">
                        <h3>What is Set?</h3>
                        <p><strong>Definition:</strong> A collection that contains no duplicate elements. It models the mathematical set abstraction.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>No Duplicates:</strong> Each element can appear only once</li>
                            <li><strong>Uniqueness:</strong> Based on equals() and hashCode() methods</li>
                            <li><strong>Mathematical Operations:</strong> Union, intersection, difference</li>
                        </ul>
                        
                        <h3>HashSet - Hash Table Implementation</h3>
                        <p><strong>When to use:</strong> When you need fast lookups and don't care about order.</p>
                        <p><strong>Performance:</strong> O(1) average for add, remove, contains operations.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class HashSetDemo {
    public static void main(String[] args) {
        Set<String> colors = new HashSet<>();
        
        // Adding elements
        colors.add("Red");
        colors.add("Blue");
        colors.add("Green");
        colors.add("Red");      // Duplicate - won't be added
        
        System.out.println("Size: " + colors.size());  // 3, not 4
        
        // Checking membership
        boolean hasRed = colors.contains("Red");    // true
        boolean hasYellow = colors.contains("Yellow");  // false
        
        // Removing elements
        boolean removed = colors.remove("Blue");    // true
        
        // Iterating (no guaranteed order)
        for (String color : colors) {
            System.out.println(color);
        }
        
        // Set operations
        Set<String> primaryColors = new HashSet<>(Arrays.asList("Red", "Blue", "Yellow"));
        Set<String> warmColors = new HashSet<>(Arrays.asList("Red", "Orange", "Yellow"));
        
        // Union
        Set<String> allColors = new HashSet<>(primaryColors);
        allColors.addAll(warmColors);
        System.out.println("Union: " + allColors);
        
        // Intersection
        Set<String> commonColors = new HashSet<>(primaryColors);
        commonColors.retainAll(warmColors);
        System.out.println("Intersection: " + commonColors);
        
        // Difference
        Set<String> difference = new HashSet<>(primaryColors);
        difference.removeAll(warmColors);
        System.out.println("Difference: " + difference);
    }
}</code></pre>
                        </div>
                        
                        <h3>LinkedHashSet - Maintains Insertion Order</h3>
                        <p><strong>When to use:</strong> When you need Set behavior with predictable iteration order.</p>
                        <p><strong>Performance:</strong> Slightly slower than HashSet due to maintaining linked list.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class LinkedHashSetDemo {
    public static void main(String[] args) {
        Set<String> orderedSet = new LinkedHashSet<>();
        
        orderedSet.add("First");
        orderedSet.add("Second");
        orderedSet.add("Third");
        orderedSet.add("First");  // Duplicate ignored
        
        // Iteration maintains insertion order
        for (String item : orderedSet) {
            System.out.println(item);  // First, Second, Third
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>TreeSet - Sorted Set Implementation</h3>
                        <p><strong>When to use:</strong> When you need elements in sorted order.</p>
                        <p><strong>Performance:</strong> O(log n) for add, remove, contains operations.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class TreeSetDemo {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();
        
        // Adding elements (automatically sorted)
        numbers.add(5);
        numbers.add(2);
        numbers.add(8);
        numbers.add(1);
        
        System.out.println(numbers);  // [1, 2, 5, 8] - sorted order
        
        // Navigation methods
        Integer first = numbers.first();        // 1
        Integer last = numbers.last();          // 8
        Integer lower = numbers.lower(5);       // 2 (largest < 5)
        Integer higher = numbers.higher(5);     // 8 (smallest > 5)
        Integer floor = numbers.floor(4);       // 2 (largest <= 4)
        Integer ceiling = numbers.ceiling(4);   // 5 (smallest >= 4)
        
        // Subset operations
        SortedSet<Integer> headSet = numbers.headSet(5);    // [1, 2]
        SortedSet<Integer> tailSet = numbers.tailSet(5);    // [5, 8]
        SortedSet<Integer> subSet = numbers.subSet(2, 8);   // [2, 5]
        
        // Custom sorting with Comparator
        TreeSet<String> words = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
        words.add("apple");
        words.add("Banana");
        words.add("cherry");
        
        System.out.println(words);  // Case-insensitive sorting
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="map" class="section">
                    <h2>üó∫Ô∏è Map Interface</h2>
                    
                    <div class="subsection">
                        <h3>What is Map?</h3>
                        <p><strong>Definition:</strong> An object that maps keys to values. Cannot contain duplicate keys; each key can map to at most one value.</p>
                        
                        <h4>Key Features:</h4>
                        <ul>
                            <li><strong>Key-Value Pairs:</strong> Associates keys with values</li>
                            <li><strong>Unique Keys:</strong> No duplicate keys allowed</li>
                            <li><strong>Null Values:</strong> Most implementations allow null values and keys</li>
                            <li><strong>Not a Collection:</strong> Map is separate from Collection hierarchy</li>
                        </ul>
                        
                        <h3>HashMap - Hash Table Implementation</h3>
                        <p><strong>When to use:</strong> When you need fast key-based lookups and don't care about order.</p>
                        <p><strong>Performance:</strong> O(1) average for get, put, remove operations.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class HashMapDemo {
    public static void main(String[] args) {
        Map<String, Integer> ages = new HashMap<>();
        
        // Adding key-value pairs
        ages.put("Alice", 25);
        ages.put("Bob", 30);
        ages.put("Charlie", 35);
        ages.put("Alice", 26);    // Updates existing key
        
        // Accessing values
        Integer aliceAge = ages.get("Alice");        // 26
        Integer defaultAge = ages.getOrDefault("David", 0);  // 0
        
        // Checking keys and values
        boolean hasAlice = ages.containsKey("Alice");     // true
        boolean hasAge30 = ages.containsValue(30);        // true
        
        // Removing entries
        Integer removed = ages.remove("Bob");             // 30
        boolean removedPair = ages.remove("Charlie", 35); // true
        
        // Iterating over entries
        for (Map.Entry<String, Integer> entry : ages.entrySet()) {
            String name = entry.getKey();
            Integer age = entry.getValue();
            System.out.println(name + " is " + age + " years old");
        }
        
        // Iterating over keys
        for (String name : ages.keySet()) {
            System.out.println("Name: " + name);
        }
        
        // Iterating over values
        for (Integer age : ages.values()) {
            System.out.println("Age: " + age);
        }
        
        // Bulk operations
        Map<String, Integer> moreAges = Map.of("David", 28, "Eve", 32);
        ages.putAll(moreAges);
        
        // Compute operations (Java 8+)
        ages.putIfAbsent("Frank", 40);
        ages.computeIfAbsent("Grace", k -> k.length() * 5);
        ages.computeIfPresent("Alice", (k, v) -> v + 1);
        ages.compute("Bob", (k, v) -> v == null ? 1 : v + 1);
        
        // Merge operation
        ages.merge("Alice", 5, Integer::sum);  // Add 5 to existing value
        
        System.out.println("Final ages: " + ages);
    }
}</code></pre>
                        </div>
                        
                        <h3>LinkedHashMap - Maintains Insertion Order</h3>
                        <p><strong>When to use:</strong> When you need Map behavior with predictable iteration order.</p>
                        <p><strong>Access Order:</strong> Can maintain access order instead of insertion order.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class LinkedHashMapDemo {
    public static void main(String[] args) {
        // Insertion order
        Map<String, String> insertionOrder = new LinkedHashMap<>();
        insertionOrder.put("first", "1st");
        insertionOrder.put("second", "2nd");
        insertionOrder.put("third", "3rd");
        
        // Access order (LRU cache behavior)
        Map<String, String> accessOrder = new LinkedHashMap<>(16, 0.75f, true);
        accessOrder.put("A", "Apple");
        accessOrder.put("B", "Banana");
        accessOrder.put("C", "Cherry");
        
        accessOrder.get("A");  // A becomes most recently used
        
        System.out.println("Insertion order: " + insertionOrder);
        System.out.println("Access order: " + accessOrder);
    }
}</code></pre>
                        </div>
                        
                        <h3>TreeMap - Sorted Map Implementation</h3>
                        <p><strong>When to use:</strong> When you need keys in sorted order.</p>
                        <p><strong>Performance:</strong> O(log n) for get, put, remove operations.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class TreeMapDemo {
    public static void main(String[] args) {
        TreeMap<String, Integer> scores = new TreeMap<>();
        
        scores.put("Charlie", 85);
        scores.put("Alice", 92);
        scores.put("Bob", 78);
        
        System.out.println(scores);  // Sorted by keys: {Alice=92, Bob=78, Charlie=85}
        
        // Navigation methods
        String firstKey = scores.firstKey();        // "Alice"
        String lastKey = scores.lastKey();          // "Charlie"
        String lowerKey = scores.lowerKey("Bob");   // "Alice"
        String higherKey = scores.higherKey("Bob"); // "Charlie"
        
        // Subset operations
        SortedMap<String, Integer> headMap = scores.headMap("Charlie");  // Alice, Bob
        SortedMap<String, Integer> tailMap = scores.tailMap("Bob");      // Bob, Charlie
        SortedMap<String, Integer> subMap = scores.subMap("Alice", "Charlie");  // Alice, Bob
        
        // Entry navigation
        Map.Entry<String, Integer> firstEntry = scores.firstEntry();
        Map.Entry<String, Integer> lastEntry = scores.lastEntry();
        Map.Entry<String, Integer> pollFirst = scores.pollFirstEntry();  // Remove and return first
        
        System.out.println("After poll first: " + scores);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="queue" class="section">
                    <h2>üö∂ Queue & Deque</h2>
                    
                    <div class="subsection">
                        <h3>What is Queue?</h3>
                        <p><strong>Definition:</strong> A collection designed for holding elements prior to processing. Follows FIFO (First-In-First-Out) principle.</p>
                        
                        <h4>Key Operations:</h4>
                        <ul>
                            <li><strong>offer()/add():</strong> Insert element at rear</li>
                            <li><strong>poll()/remove():</strong> Remove element from front</li>
                            <li><strong>peek()/element():</strong> Examine front element without removing</li>
                        </ul>
                        
                        <h3>PriorityQueue - Heap Implementation</h3>
                        <p><strong>When to use:</strong> When you need elements processed in priority order, not FIFO.</p>
                        <p><strong>Performance:</strong> O(log n) for offer/poll, O(1) for peek.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class PriorityQueueDemo {
    public static void main(String[] args) {
        // Natural ordering (min-heap)
        PriorityQueue<Integer> minHeap = new PriorityQueue<>();
        minHeap.offer(5);
        minHeap.offer(2);
        minHeap.offer(8);
        minHeap.offer(1);
        
        while (!minHeap.isEmpty()) {
            System.out.println(minHeap.poll());  // 1, 2, 5, 8
        }
        
        // Custom comparator (max-heap)
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
        maxHeap.offer(5);
        maxHeap.offer(2);
        maxHeap.offer(8);
        maxHeap.offer(1);
        
        while (!maxHeap.isEmpty()) {
            System.out.println(maxHeap.poll());  // 8, 5, 2, 1
        }
        
        // Custom objects with priority
        PriorityQueue<Task> taskQueue = new PriorityQueue<>(
            Comparator.comparing(Task::getPriority)
        );
        
        taskQueue.offer(new Task("Low priority", 3));
        taskQueue.offer(new Task("High priority", 1));
        taskQueue.offer(new Task("Medium priority", 2));
        
        while (!taskQueue.isEmpty()) {
            System.out.println(taskQueue.poll());
        }
    }
}

class Task {
    private String name;
    private int priority;
    
    public Task(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }
    
    public int getPriority() { return priority; }
    
    @Override
    public String toString() {
        return name + " (priority: " + priority + ")";
    }
}</code></pre>
                        </div>
                        
                        <h3>ArrayDeque - Double-Ended Queue</h3>
                        <p><strong>When to use:</strong> When you need efficient insertion/removal at both ends.</p>
                        <p><strong>Performance:</strong> O(1) for operations at both ends, better than LinkedList.</p>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class ArrayDequeDemo {
    public static void main(String[] args) {
        Deque<String> deque = new ArrayDeque<>();
        
        // Adding elements
        deque.addFirst("First");
        deque.addLast("Last");
        deque.offerFirst("New First");
        deque.offerLast("New Last");
        
        System.out.println(deque);  // [New First, First, Last, New Last]
        
        // Removing elements
        String first = deque.removeFirst();     // "New First"
        String last = deque.removeLast();       // "New Last"
        String pollFirst = deque.pollFirst();   // "First"
        String pollLast = deque.pollLast();     // "Last"
        
        // Using as Stack (LIFO)
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());  // 3, 2, 1
        }
        
        // Using as Queue (FIFO)
        Deque<String> queue = new ArrayDeque<>();
        queue.offer("A");
        queue.offer("B");
        queue.offer("C");
        
        while (!queue.isEmpty()) {
            System.out.println(queue.poll());  // A, B, C
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="iterators" class="section">
                    <h2>üîÑ Iterators</h2>
                    
                    <div class="subsection">
                        <h3>What are Iterators?</h3>
                        <p><strong>Definition:</strong> Objects that provide a way to traverse collections sequentially without exposing underlying structure.</p>
                        
                        <h4>Types of Iterators:</h4>
                        <ul>
                            <li><strong>Iterator:</strong> Forward-only traversal with remove capability</li>
                            <li><strong>ListIterator:</strong> Bidirectional traversal for Lists with add/set capability</li>
                            <li><strong>Spliterator:</strong> Parallel iteration support (Java 8+)</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class IteratorDemo {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D"));
        
        // Basic Iterator
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String element = iterator.next();
            if (element.equals("B")) {
                iterator.remove();  // Safe removal during iteration
            }
        }
        
        // ListIterator - bidirectional
        ListIterator<String> listIterator = list.listIterator();
        
        // Forward iteration
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String element = listIterator.next();
            System.out.println("Index " + index + ": " + element);
            
            if (element.equals("C")) {
                listIterator.set("Modified C");  // Modify current element
                listIterator.add("New Element"); // Add after current
            }
        }
        
        // Backward iteration
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String element = listIterator.previous();
            System.out.println("Backward - Index " + index + ": " + element);
        }
        
        // Enhanced for loop (uses iterator internally)
        for (String item : list) {
            System.out.println(item);
        }
        
        // Fail-fast behavior demonstration
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Iterator<Integer> it = numbers.iterator();
        
        try {
            while (it.hasNext()) {
                Integer num = it.next();
                if (num == 3) {
                    numbers.add(6);  // Concurrent modification
                }
            }
        } catch (ConcurrentModificationException e) {
            System.out.println("Concurrent modification detected!");
        }
        
        System.out.println("Final list: " + list);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="algorithms" class="section">
                    <h2>üßÆ Collections Algorithms</h2>
                    
                    <div class="subsection">
                        <h3>What are Collections Algorithms?</h3>
                        <p><strong>Definition:</strong> Static methods in Collections class that operate on collections to perform common tasks like sorting, searching, and manipulation.</p>
                        
                        <h4>Categories:</h4>
                        <ul>
                            <li><strong>Sorting:</strong> sort(), reverse()</li>
                            <li><strong>Searching:</strong> binarySearch(), min(), max()</li>
                            <li><strong>Manipulation:</strong> shuffle(), rotate(), swap()</li>
                            <li><strong>Composition:</strong> frequency(), disjoint()</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class CollectionsAlgorithmsDemo {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1, 9, 3));
        
        // Sorting
        Collections.sort(numbers);
        System.out.println("Sorted: " + numbers);  // [1, 2, 3, 5, 8, 9]
        
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("Reverse sorted: " + numbers);  // [9, 8, 5, 3, 2, 1]
        
        // Searching (requires sorted list)
        Collections.sort(numbers);
        int index = Collections.binarySearch(numbers, 5);
        System.out.println("Index of 5: " + index);
        
        // Min and Max
        Integer min = Collections.min(numbers);
        Integer max = Collections.max(numbers);
        System.out.println("Min: " + min + ", Max: " + max);
        
        // Shuffling
        Collections.shuffle(numbers);
        System.out.println("Shuffled: " + numbers);
        
        // Reversing
        Collections.reverse(numbers);
        System.out.println("Reversed: " + numbers);
        
        // Rotating
        Collections.rotate(numbers, 2);  // Rotate right by 2 positions
        System.out.println("Rotated: " + numbers);
        
        // Swapping
        Collections.swap(numbers, 0, numbers.size() - 1);
        System.out.println("After swap: " + numbers);
        
        // Filling
        Collections.fill(numbers, 0);
        System.out.println("Filled with 0: " + numbers);
        
        // Frequency
        List<String> words = Arrays.asList("apple", "banana", "apple", "cherry", "apple");
        int frequency = Collections.frequency(words, "apple");
        System.out.println("Frequency of 'apple': " + frequency);
        
        // Disjoint (no common elements)
        List<Integer> list1 = Arrays.asList(1, 2, 3);
        List<Integer> list2 = Arrays.asList(4, 5, 6);
        boolean disjoint = Collections.disjoint(list1, list2);
        System.out.println("Lists are disjoint: " + disjoint);
        
        // Creating immutable collections
        List<String> immutableList = Collections.unmodifiableList(
            new ArrayList<>(Arrays.asList("A", "B", "C"))
        );
        
        // Creating synchronized collections
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        
        // Creating singleton collections
        Set<String> singletonSet = Collections.singleton("OnlyElement");
        List<String> singletonList = Collections.singletonList("OnlyElement");
        Map<String, String> singletonMap = Collections.singletonMap("key", "value");
        
        System.out.println("Singleton set: " + singletonSet);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="generics" class="section">
                    <h2>üîß Generics</h2>
                    
                    <div class="subsection">
                        <h3>What are Generics?</h3>
                        <p><strong>Definition:</strong> A feature that allows you to write type-safe code by parameterizing types. Provides compile-time type checking and eliminates need for casting.</p>
                        
                        <h4>Benefits:</h4>
                        <ul>
                            <li><strong>Type Safety:</strong> Compile-time error detection</li>
                            <li><strong>Elimination of Casts:</strong> No need for explicit casting</li>
                            <li><strong>Generic Algorithms:</strong> Write algorithms that work on different types</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class GenericsDemo {
    public static void main(String[] args) {
        // Without generics (raw types) - NOT recommended
        List rawList = new ArrayList();
        rawList.add("String");
        rawList.add(123);  // Different types allowed
        String str = (String) rawList.get(0);  // Casting required
        
        // With generics - type safe
        List<String> stringList = new ArrayList<>();
        stringList.add("Hello");
        // stringList.add(123);  // Compile error
        String value = stringList.get(0);  // No casting needed
        
        // Generic methods
        String[] stringArray = {"A", "B", "C"};
        Integer[] intArray = {1, 2, 3};
        
        printArray(stringArray);
        printArray(intArray);
        
        // Bounded type parameters
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        double average = calculateAverage(numbers);
        System.out.println("Average: " + average);
        
        // Wildcards
        List<Integer> intList = Arrays.asList(1, 2, 3);
        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);
        
        printNumbers(intList);
        printNumbers(doubleList);
        
        // Upper bounded wildcard
        List<Circle> circles = Arrays.asList(new Circle(5), new Circle(10));
        double totalArea = calculateTotalArea(circles);
        System.out.println("Total area: " + totalArea);
        
        // Lower bounded wildcard
        List<Object> objects = new ArrayList<>();
        addNumbers(objects);
        System.out.println("Objects: " + objects);
    }
    
    // Generic method
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
    
    // Bounded type parameter
    public static <T extends Number> double calculateAverage(List<T> numbers) {
        double sum = 0.0;
        for (T number : numbers) {
            sum += number.doubleValue();
        }
        return sum / numbers.size();
    }
    
    // Upper bounded wildcard (? extends)
    public static void printNumbers(List<? extends Number> numbers) {
        for (Number number : numbers) {
            System.out.print(number + " ");
        }
        System.out.println();
    }
    
    public static double calculateTotalArea(List<? extends Shape> shapes) {
        double total = 0.0;
        for (Shape shape : shapes) {
            total += shape.getArea();
        }
        return total;
    }
    
    // Lower bounded wildcard (? super)
    public static void addNumbers(List<? super Integer> numbers) {
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
    }
}

// Example classes for generics
abstract class Shape {
    public abstract double getArea();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="concurrent" class="section">
                    <h2>üîí Concurrent Collections</h2>
                    
                    <div class="subsection">
                        <h3>What are Concurrent Collections?</h3>
                        <p><strong>Definition:</strong> Thread-safe collections designed for concurrent access by multiple threads without external synchronization.</p>
                        
                        <h4>Why Concurrent Collections?</h4>
                        <ul>
                            <li><strong>Performance:</strong> Better than synchronized collections</li>
                            <li><strong>Scalability:</strong> Designed for high concurrency</li>
                            <li><strong>Safety:</strong> Thread-safe without explicit locking</li>
                            <li><strong>Non-blocking:</strong> Many operations are lock-free</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.concurrent.*;
import java.util.*;

public class ConcurrentCollectionsDemo {
    public static void main(String[] args) throws InterruptedException {
        // ConcurrentHashMap - thread-safe HashMap
        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
        
        // Atomic operations
        concurrentMap.put("count", 0);
        concurrentMap.compute("count", (key, val) -> val == null ? 1 : val + 1);
        concurrentMap.computeIfAbsent("newKey", key -> key.length());
        concurrentMap.merge("count", 5, Integer::sum);
        
        // CopyOnWriteArrayList - thread-safe ArrayList
        CopyOnWriteArrayList<String> cowList = new CopyOnWriteArrayList<>();
        cowList.add("A");
        cowList.add("B");
        cowList.add("C");
        
        // Safe iteration even during modification
        for (String item : cowList) {
            System.out.println(item);
            // Another thread can modify cowList safely during this iteration
        }
        
        // BlockingQueue - producer-consumer pattern
        BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    queue.put("Item " + i);
                    System.out.println("Produced: Item " + i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    String item = queue.take();
                    System.out.println("Consumed: " + item);
                    Thread.sleep(150);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
        
        producer.join();
        consumer.join();
        
        // ConcurrentSkipListMap - thread-safe TreeMap
        ConcurrentSkipListMap<String, Integer> skipListMap = new ConcurrentSkipListMap<>();
        skipListMap.put("C", 3);
        skipListMap.put("A", 1);
        skipListMap.put("B", 2);
        
        System.out.println("Sorted concurrent map: " + skipListMap);
        
        // ConcurrentLinkedQueue - thread-safe queue
        ConcurrentLinkedQueue<String> concurrentQueue = new ConcurrentLinkedQueue<>();
        concurrentQueue.offer("First");
        concurrentQueue.offer("Second");
        
        String polled = concurrentQueue.poll();
        System.out.println("Polled: " + polled);
        
        System.out.println("Final concurrent map: " + concurrentMap);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="performance" class="section">
                    <h2>‚ö° Performance Comparison</h2>
                    
                    <div class="subsection">
                        <h3>Time Complexity Comparison</h3>
                        
                        <h4>List Implementations:</h4>
                        <div class="code-block">
                            <pre><code>Operation       | ArrayList | LinkedList | Vector
----------------|-----------|------------|--------
get(index)      | O(1)      | O(n)       | O(1)
add(element)    | O(1)*     | O(1)       | O(1)*
add(index, e)   | O(n)      | O(n)       | O(n)
remove(index)   | O(n)      | O(n)       | O(n)
contains(e)     | O(n)      | O(n)       | O(n)
size()          | O(1)      | O(1)       | O(1)

* Amortized time complexity</code></pre>
                        </div>
                        
                        <h4>Set Implementations:</h4>
                        <div class="code-block">
                            <pre><code>Operation    | HashSet | LinkedHashSet | TreeSet
-------------|---------|---------------|--------
add(e)       | O(1)    | O(1)          | O(log n)
remove(e)    | O(1)    | O(1)          | O(log n)
contains(e)  | O(1)    | O(1)          | O(log n)
Ordering     | None    | Insertion     | Sorted</code></pre>
                        </div>
                        
                        <h4>Map Implementations:</h4>
                        <div class="code-block">
                            <pre><code>Operation    | HashMap | LinkedHashMap | TreeMap
-------------|---------|---------------|--------
get(key)     | O(1)    | O(1)          | O(log n)
put(k,v)     | O(1)    | O(1)          | O(log n)
remove(key)  | O(1)    | O(1)          | O(log n)
Ordering     | None    | Insertion     | Sorted</code></pre>
                        </div>
                        
                        <h3>Memory Usage Guidelines</h3>
                        <ul>
                            <li><strong>ArrayList:</strong> Lower memory overhead, good for frequent access</li>
                            <li><strong>LinkedList:</strong> Higher memory overhead due to node pointers</li>
                            <li><strong>HashMap:</strong> Additional memory for hash table structure</li>
                            <li><strong>TreeMap:</strong> Additional memory for tree structure</li>
                        </ul>
                        
                        <h3>When to Use Which Collection</h3>
                        <div class="code-block">
                            <pre><code>// Use ArrayList when:
// - Frequent random access by index
// - More reads than writes
// - Memory efficiency is important
List<String> frequentReads = new ArrayList<>();

// Use LinkedList when:
// - Frequent insertions/deletions at beginning/middle
// - Implementing queue/deque operations
List<String> frequentInsertions = new LinkedList<>();

// Use HashSet when:
// - Need unique elements
// - Fast lookups are important
// - Order doesn't matter
Set<String> uniqueItems = new HashSet<>();

// Use TreeSet when:
// - Need unique elements in sorted order
// - Need range operations
Set<String> sortedUniqueItems = new TreeSet<>();

// Use HashMap when:
// - Need key-value mapping
// - Fast lookups by key
// - Order doesn't matter
Map<String, Integer> fastLookup = new HashMap<>();

// Use TreeMap when:
// - Need key-value mapping in sorted order
// - Need range operations on keys
Map<String, Integer> sortedMapping = new TreeMap<>();</code></pre>
                        </div>
                    </div>
                </section>

                <section id="best-practices" class="section">
                    <h2>üí° Best Practices</h2>
                    
                    <div class="subsection">
                        <h3>Collection Best Practices</h3>
                        
                        <h4>1. Use Interface Types for Declarations</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Use interface type
List<String> names = new ArrayList<>();
Set<Integer> numbers = new HashSet<>();
Map<String, Object> data = new HashMap<>();

// ‚ùå BAD - Use concrete type
ArrayList<String> names = new ArrayList<>();
HashSet<Integer> numbers = new HashSet<>();
HashMap<String, Object> data = new HashMap<>();</code></pre>
                        </div>
                        
                        <h4>2. Initialize with Capacity When Size is Known</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Avoid resizing
List<String> largeList = new ArrayList<>(1000);
Map<String, Object> largeMap = new HashMap<>(1000);

// ‚ùå BAD - Multiple resizing operations
List<String> list = new ArrayList<>();  // Default capacity 10</code></pre>
                        </div>
                        
                        <h4>3. Use Appropriate Collection for Use Case</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Choose based on operations
List<String> orderedItems = new ArrayList<>();  // Frequent access by index
Set<String> uniqueItems = new HashSet<>();      // Uniqueness check
Queue<Task> taskQueue = new ArrayDeque<>();     // FIFO processing

// ‚ùå BAD - Wrong choice for use case
List<String> uniqueCheck = new ArrayList<>();   // Use Set instead
Map<Integer, String> orderedAccess = new HashMap<>();  // Use List instead</code></pre>
                        </div>
                        
                        <h4>4. Prefer Immutable Collections When Possible</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Immutable collections
List<String> immutableList = List.of("A", "B", "C");
Set<Integer> immutableSet = Set.of(1, 2, 3);
Map<String, Integer> immutableMap = Map.of("A", 1, "B", 2);

// For larger collections
List<String> unmodifiableList = Collections.unmodifiableList(mutableList);</code></pre>
                        </div>
                        
                        <h4>5. Handle Null Values Properly</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Check for null
Map<String, String> map = new HashMap<>();
String value = map.get("key");
if (value != null) {
    // Process value
}

// Or use getOrDefault
String value = map.getOrDefault("key", "defaultValue");

// ‚ùå BAD - Potential NullPointerException
String value = map.get("key");
int length = value.length();  // NPE if value is null</code></pre>
                        </div>
                        
                        <h4>6. Use Enhanced For Loop When Possible</h4>
                        <div class="code-block">
                            <pre><code>// ‚úÖ GOOD - Enhanced for loop
for (String item : list) {
    System.out.println(item);
}

// ‚úÖ GOOD - Iterator when modification needed
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (shouldRemove(item)) {
        it.remove();
    }
}

// ‚ùå BAD - Index-based loop for LinkedList
for (int i = 0; i < linkedList.size(); i++) {
    String item = linkedList.get(i);  // O(n) operation
}</code></pre>
                        </div>
                        
                        <h4>7. Override equals() and hashCode() for Custom Objects</h4>
                        <div class="code-block">
                            <pre><code>public class Person {
    private String name;
    private int age;
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="interview" class="section">
                    <h2>üéØ Interview Questions</h2>
                    
                    <div class="subsection">
                        <h3>Most Asked Collections Interview Questions</h3>
                        
                        <h4>1. What is the difference between ArrayList and LinkedList?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>ArrayList:</strong> Dynamic array, O(1) random access, O(n) insertion/deletion in middle</li>
                            <li><strong>LinkedList:</strong> Doubly linked list, O(n) random access, O(1) insertion/deletion at ends</li>
                            <li><strong>Use ArrayList for:</strong> Frequent reads, random access</li>
                            <li><strong>Use LinkedList for:</strong> Frequent insertions/deletions, queue operations</li>
                        </ul>
                        
                        <h4>2. How does HashMap work internally?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li>Uses hash table with buckets (array of linked lists/trees)</li>
                            <li>Hash function determines bucket index: <code>index = hash(key) % capacity</code></li>
                            <li>Collisions handled by chaining (linked list) or tree (Java 8+)</li>
                            <li>Load factor (0.75) triggers resizing when exceeded</li>
                            <li>Java 8+ converts linked list to tree when bucket size > 8</li>
                        </ul>
                        
                        <h4>3. What is the difference between HashMap and ConcurrentHashMap?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>HashMap:</strong> Not thread-safe, allows null keys/values, better performance</li>
                            <li><strong>ConcurrentHashMap:</strong> Thread-safe, doesn't allow null keys/values, segment-based locking</li>
                            <li><strong>Synchronization:</strong> ConcurrentHashMap uses lock striping for better concurrency</li>
                        </ul>
                        
                        <h4>4. What is the difference between Set and List?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>List:</strong> Ordered collection, allows duplicates, indexed access</li>
                            <li><strong>Set:</strong> No duplicates, may or may not be ordered, no indexed access</li>
                            <li><strong>Uniqueness:</strong> Set uses equals() and hashCode() to ensure uniqueness</li>
                        </ul>
                        
                        <h4>5. Explain the contract between equals() and hashCode()</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li>If two objects are equal (equals() returns true), they must have same hashCode()</li>
                            <li>If two objects have same hashCode(), they may or may not be equal</li>
                            <li>If you override equals(), you must override hashCode()</li>
                            <li>Used by HashMap, HashSet for efficient storage and retrieval</li>
                        </ul>
                        
                        <h4>6. What is fail-fast behavior in collections?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li>Iterator throws ConcurrentModificationException if collection is modified during iteration</li>
                            <li>Detected using modCount field that tracks structural modifications</li>
                            <li>Use Iterator.remove() for safe removal during iteration</li>
                            <li>ConcurrentHashMap and CopyOnWriteArrayList are fail-safe</li>
                        </ul>
                        
                        <h4>7. When to use TreeMap vs HashMap?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>HashMap:</strong> O(1) operations, no ordering, allows null key</li>
                            <li><strong>TreeMap:</strong> O(log n) operations, sorted order, doesn't allow null key</li>
                            <li><strong>Use TreeMap when:</strong> Need sorted keys, range operations</li>
                            <li><strong>Use HashMap when:</strong> Need fast lookups, order doesn't matter</li>
                        </ul>
                        
                        <h4>8. What are the differences between Iterator and ListIterator?</h4>
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li><strong>Iterator:</strong> Forward-only, works on all collections, has remove()</li>
                            <li><strong>ListIterator:</strong> Bidirectional, only for Lists, has add(), set(), remove()</li>
                            <li><strong>Navigation:</strong> ListIterator can go backward using hasPrevious(), previous()</li>
                        </ul>
                        
                        <h3>Coding Questions</h3>
                        <p><strong>Common Problems:</strong></p>
                        <ul>
                            <li>Find duplicate elements in an array using Set</li>
                            <li>Implement LRU cache using LinkedHashMap</li>
                            <li>Sort Map by values</li>
                            <li>Find intersection of two lists</li>
                            <li>Group anagrams using HashMap</li>
                            <li>Implement custom ArrayList</li>
                        </ul>
                    </div>
                </section>

            </div>
            </div>
        </div>
    </div>

    <script src="../footer.js"></script>
</body>
</html>