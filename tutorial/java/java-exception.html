<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Java Exception Handling - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-java">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Java Exception Handling</h1>
                <p>Master Error Management & Robust Application Development</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'java-exception';</script>
    <script src="../menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightJava(block);
            });
            updateActiveNav();
        });
        
        function highlightJava(element) {
            let code = element.textContent;
            
            code = code.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert)\b/g, '<span class="keyword">$1</span>');
            
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');
            code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            code = code.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span class="number">$&</span>');
            
            code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="method">$1</span>(');
            
            code = code.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span class="class">$&</span>');
            
            element.innerHTML = code;
        }
        
        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.toc-nav a');
            
            let currentSection = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentSection = section.id;
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateActiveNav);
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Exception Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Exception Overview</a></li>
                        <li><a href="#hierarchy">Exception Hierarchy</a></li>
                        <li><a href="#try-catch">Try-Catch Blocks</a></li>
                        <li><a href="#finally">Finally Block</a></li>
                        <li><a href="#throw-throws">Throw vs Throws</a></li>
                        <li><a href="#custom-exceptions">Custom Exceptions</a></li>
                        <li><a href="#checked-unchecked">Checked vs Unchecked</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                        <li><a href="#common-exceptions">Common Exceptions</a></li>
                        <li><a href="#interview">Interview Questions</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="overview" class="section">
                    <h2>üöÄ Exception Handling Overview</h2>
                    
                    <div class="subsection">
                        <h3>What is Exception Handling?</h3>
                        <p><strong>Definition:</strong> Exception handling is a programming mechanism that allows applications to respond to exceptional circumstances during execution, ensuring graceful error management and application stability.</p>
                        
                        <h4>Why Exception Handling?</h4>
                        <ul>
                            <li><strong>Robustness:</strong> Prevents application crashes from unexpected errors</li>
                            <li><strong>User Experience:</strong> Provides meaningful error messages to users</li>
                            <li><strong>Debugging:</strong> Helps identify and fix issues during development</li>
                            <li><strong>Resource Management:</strong> Ensures proper cleanup of resources</li>
                            <li><strong>Flow Control:</strong> Separates error handling from normal program logic</li>
                        </ul>
                        
                        <h4>Exception vs Error:</h4>
                        <div class="code-block">
                            <pre><code>Type        | Description                    | Recoverable | Examples
------------|--------------------------------|-------------|------------------
Exception   | Abnormal condition in program  | Yes         | IOException, SQLException
Error       | Serious system-level problems  | No          | OutOfMemoryError, StackOverflowError
Runtime     | Programming mistakes           | Sometimes   | NullPointerException, ArrayIndexOutOfBoundsException</code></pre>
                        </div>
                    </div>
                </section>

                <section id="hierarchy" class="section">
                    <h2>üèóÔ∏è Exception Hierarchy</h2>
                    
                    <div class="subsection">
                        <h3>Java Exception Class Hierarchy</h3>
                        <div class="code-block">
                            <pre><code>                    Throwable
                   /           \
              Exception        Error
             /         \         \
    RuntimeException  IOException  OutOfMemoryError
    /       |      \      |           |
   NPE    AIOOBE   CCE   FileNFE   StackOverflowError
   
NPE = NullPointerException
AIOOBE = ArrayIndexOutOfBoundsException  
CCE = ClassCastException
FileNFE = FileNotFoundException</code></pre>
                        </div>
                        
                        <h4>Key Classes in Hierarchy:</h4>
                        <div class="code-block">
                            <pre><code>// Base class for all exceptions and errors
public class Throwable {
    private String message;
    private Throwable cause;
    
    public Throwable() {}
    public Throwable(String message) { this.message = message; }
    public Throwable(String message, Throwable cause) {
        this.message = message;
        this.cause = cause;
    }
    
    public String getMessage() { return message; }
    public Throwable getCause() { return cause; }
    public void printStackTrace() { /* prints stack trace */ }
}

// Checked exceptions - must be handled or declared
public class Exception extends Throwable {
    // IOException, SQLException, ClassNotFoundException
}

// Unchecked exceptions - runtime exceptions
public class RuntimeException extends Exception {
    // NullPointerException, IllegalArgumentException
}

// System errors - not recoverable
public class Error extends Throwable {
    // OutOfMemoryError, StackOverflowError
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="try-catch" class="section">
                    <h2>üéØ Try-Catch Blocks</h2>
                    
                    <div class="subsection">
                        <h3>Basic Try-Catch Syntax</h3>
                        <div class="code-block">
                            <pre><code>public class TryCatchExample {
    
    public static void basicTryCatch() {
        try {
            // Code that might throw an exception
            int result = 10 / 0; // ArithmeticException
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            // Handle specific exception
            System.out.println("Cannot divide by zero: " + e.getMessage());
        }
        System.out.println("Program continues...");
    }
    
    // Multiple catch blocks
    public static void multipleCatch() {
        try {
            String str = null;
            int length = str.length(); // NullPointerException
            
            int[] arr = new int[5];
            arr[10] = 100; // ArrayIndexOutOfBoundsException
            
        } catch (NullPointerException e) {
            System.out.println("Null pointer error: " + e.getMessage());
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
        } catch (Exception e) {
            // Generic catch - should be last
            System.out.println("General error: " + e.getMessage());
        }
    }
    
    // Multi-catch (Java 7+)
    public static void multiCatch() {
        try {
            // Some risky operations
            performRiskyOperation();
        } catch (IOException | SQLException e) {
            // Handle multiple exception types together
            System.out.println("IO or SQL error: " + e.getMessage());
            logError(e);
        } catch (Exception e) {
            System.out.println("Other error: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                        
                        <h4>Nested Try-Catch:</h4>
                        <div class="code-block">
                            <pre><code>public class NestedTryCatch {
    
    public static void nestedExample() {
        try {
            System.out.println("Outer try block");
            
            try {
                System.out.println("Inner try block");
                int result = 10 / 0; // This will throw ArithmeticException
            } catch (ArithmeticException e) {
                System.out.println("Inner catch: " + e.getMessage());
                // Re-throw or handle differently
                throw new RuntimeException("Processed arithmetic error", e);
            }
            
        } catch (RuntimeException e) {
            System.out.println("Outer catch: " + e.getMessage());
            System.out.println("Original cause: " + e.getCause().getMessage());
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="finally" class="section">
                    <h2>üîí Finally Block</h2>
                    
                    <div class="subsection">
                        <h3>Finally Block Execution</h3>
                        <p><strong>Key Points:</strong> Finally block always executes regardless of whether an exception occurs or not. Used for cleanup operations like closing resources.</p>
                        
                        <div class="code-block">
                            <pre><code>public class FinallyExample {
    
    public static void finallyBasics() {
        FileInputStream file = null;
        try {
            file = new FileInputStream("data.txt");
            // Process file
            int data = file.read();
            System.out.println("Data: " + data);
            
        } catch (IOException e) {
            System.out.println("File error: " + e.getMessage());
        } finally {
            // This always executes
            System.out.println("Finally block executed");
            if (file != null) {
                try {
                    file.close();
                    System.out.println("File closed successfully");
                } catch (IOException e) {
                    System.out.println("Error closing file: " + e.getMessage());
                }
            }
        }
    }
    
    // Try-with-resources (Java 7+) - Automatic resource management
    public static void tryWithResources() {
        // Resources are automatically closed
        try (FileInputStream file = new FileInputStream("data.txt");
             BufferedReader reader = new BufferedReader(new InputStreamReader(file))) {
            
            String line = reader.readLine();
            System.out.println("First line: " + line);
            
        } catch (IOException e) {
            System.out.println("File processing error: " + e.getMessage());
        }
        // No need for finally - resources auto-closed
    }
    
    // Finally execution scenarios
    public static int finallyWithReturn() {
        try {
            return 1;
        } catch (Exception e) {
            return 2;
        } finally {
            System.out.println("Finally executes even with return");
            // Don't return from finally - it overrides try/catch returns
        }
        // This method returns 1
    }
}</code></pre>
                        </div>
                        
                        <h4>Finally Block Rules:</h4>
                        <ul>
                            <li><strong>Always Executes:</strong> Runs even if exception occurs or return statement is hit</li>
                            <li><strong>Resource Cleanup:</strong> Perfect place for closing files, connections, etc.</li>
                            <li><strong>No Return:</strong> Avoid return statements in finally block</li>
                            <li><strong>Exception Override:</strong> Finally exceptions can mask try/catch exceptions</li>
                        </ul>
                    </div>
                </section>

                <section id="throw-throws" class="section">
                    <h2>üé™ Throw vs Throws</h2>
                    
                    <div class="subsection">
                        <h3>Throw Keyword</h3>
                        <p><strong>Purpose:</strong> Used to explicitly throw an exception from a method or block of code.</p>
                        
                        <div class="code-block">
                            <pre><code>public class ThrowExample {
    
    public static void validateAge(int age) {
        if (age < 0) {
            // Throw unchecked exception
            throw new IllegalArgumentException("Age cannot be negative: " + age);
        }
        if (age > 150) {
            throw new IllegalArgumentException("Age seems unrealistic: " + age);
        }
        System.out.println("Valid age: " + age);
    }
    
    public static void validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("Email cannot be null or empty");
        }
        if (!email.contains("@")) {
            throw new IllegalArgumentException("Invalid email format: " + email);
        }
    }
    
    // Re-throwing exceptions
    public static void processData(String data) {
        try {
            // Some processing that might fail
            if (data == null) {
                throw new NullPointerException("Data is null");
            }
            // Process data...
        } catch (NullPointerException e) {
            // Log the error
            System.err.println("Logging error: " + e.getMessage());
            // Re-throw with more context
            throw new RuntimeException("Failed to process data", e);
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>Throws Keyword</h3>
                        <p><strong>Purpose:</strong> Used in method signature to declare that the method might throw certain exceptions.</p>
                        
                        <div class="code-block">
                            <pre><code>public class ThrowsExample {
    
    // Method declares it might throw IOException
    public static void readFile(String filename) throws IOException {
        FileReader file = new FileReader(filename); // Might throw FileNotFoundException
        BufferedReader reader = new BufferedReader(file);
        
        String line = reader.readLine(); // Might throw IOException
        System.out.println("First line: " + line);
        
        reader.close(); // Might throw IOException
    }
    
    // Multiple exceptions in throws clause
    public static void connectToDatabase(String url) 
            throws SQLException, ClassNotFoundException {
        
        Class.forName("com.mysql.cj.jdbc.Driver"); // ClassNotFoundException
        Connection conn = DriverManager.getConnection(url); // SQLException
        
        // Database operations...
        conn.close();
    }
    
    // Calling methods that throw exceptions
    public static void main(String[] args) {
        try {
            readFile("data.txt");
            connectToDatabase("jdbc:mysql://localhost:3306/mydb");
        } catch (IOException e) {
            System.out.println("File error: " + e.getMessage());
        } catch (SQLException e) {
            System.out.println("Database error: " + e.getMessage());
        } catch (ClassNotFoundException e) {
            System.out.println("Driver not found: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                        
                        <h4>Throw vs Throws Comparison:</h4>
                        <div class="code-block">
                            <pre><code>Aspect          | throw                    | throws
----------------|--------------------------|---------------------------
Purpose         | Actually throws exception| Declares possible exceptions
Location        | Inside method body       | Method signature
Usage           | throw new Exception()    | throws Exception
Quantity        | One exception at a time  | Multiple exceptions allowed
Requirement     | Must be followed by code | Just declaration</code></pre>
                        </div>
                    </div>
                </section>

                <section id="custom-exceptions" class="section">
                    <h2>üé® Custom Exceptions</h2>
                    
                    <div class="subsection">
                        <h3>Creating Custom Exceptions</h3>
                        <p><strong>Why Custom Exceptions:</strong> Provide specific error information, better error handling, and domain-specific error types for your application.</p>
                        
                        <div class="code-block">
                            <pre><code>// Custom checked exception
public class InsufficientFundsException extends Exception {
    private double amount;
    private double balance;
    
    public InsufficientFundsException(double amount, double balance) {
        super("Insufficient funds: Required " + amount + ", Available " + balance);
        this.amount = amount;
        this.balance = balance;
    }
    
    public double getAmount() { return amount; }
    public double getBalance() { return balance; }
    public double getShortfall() { return amount - balance; }
}

// Custom unchecked exception
public class InvalidAccountException extends RuntimeException {
    private String accountNumber;
    
    public InvalidAccountException(String accountNumber) {
        super("Invalid account number: " + accountNumber);
        this.accountNumber = accountNumber;
    }
    
    public InvalidAccountException(String accountNumber, Throwable cause) {
        super("Invalid account number: " + accountNumber, cause);
        this.accountNumber = accountNumber;
    }
    
    public String getAccountNumber() { return accountNumber; }
}

// Using custom exceptions
public class BankAccount {
    private String accountNumber;
    private double balance;
    
    public BankAccount(String accountNumber, double initialBalance) {
        if (accountNumber == null || accountNumber.trim().isEmpty()) {
            throw new InvalidAccountException(accountNumber);
        }
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }
    
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }
        if (amount > balance) {
            throw new InsufficientFundsException(amount, balance);
        }
        balance -= amount;
        System.out.println("Withdrawn: $" + amount + ", New balance: $" + balance);
    }
    
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }
        balance += amount;
        System.out.println("Deposited: $" + amount + ", New balance: $" + balance);
    }
}</code></pre>
                        </div>
                        
                        <h4>Exception Chaining:</h4>
                        <div class="code-block">
                            <pre><code>public class ExceptionChaining {
    
    public static void processPayment(String cardNumber, double amount) 
            throws PaymentProcessingException {
        try {
            validateCard(cardNumber);
            chargeCard(cardNumber, amount);
        } catch (InvalidCardException e) {
            // Chain the original exception
            throw new PaymentProcessingException("Payment failed for card: " + cardNumber, e);
        } catch (NetworkException e) {
            throw new PaymentProcessingException("Network error during payment", e);
        }
    }
    
    public static void main(String[] args) {
        try {
            processPayment("1234-5678-9012-3456", 100.0);
        } catch (PaymentProcessingException e) {
            System.out.println("Payment error: " + e.getMessage());
            
            // Get the root cause
            Throwable cause = e.getCause();
            if (cause != null) {
                System.out.println("Root cause: " + cause.getMessage());
            }
            
            // Print full stack trace
            e.printStackTrace();
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="checked-unchecked" class="section">
                    <h2>‚úÖ Checked vs Unchecked Exceptions</h2>
                    
                    <div class="subsection">
                        <h3>Checked Exceptions</h3>
                        <p><strong>Definition:</strong> Exceptions that must be either caught or declared in the method signature. Compiler enforces handling.</p>
                        
                        <div class="code-block">
                            <pre><code>public class CheckedExceptionExample {
    
    // Must handle or declare IOException
    public static void readFileContent(String filename) throws IOException {
        FileReader file = new FileReader(filename); // FileNotFoundException
        BufferedReader reader = new BufferedReader(file);
        
        String line;
        while ((line = reader.readLine()) != null) { // IOException
            System.out.println(line);
        }
        reader.close(); // IOException
    }
    
    // Handling checked exceptions
    public static void safeFileRead(String filename) {
        try {
            readFileContent(filename);
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + filename);
        } catch (IOException e) {
            System.out.println("Error reading file: " + e.getMessage());
        }
    }
    
    // Common checked exceptions
    public static void checkedExamples() {
        try {
            // ClassNotFoundException
            Class.forName("com.example.NonExistentClass");
            
            // SQLException  
            Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/db");
            
            // InterruptedException
            Thread.sleep(1000);
            
            // ParseException
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            Date date = sdf.parse("invalid-date");
            
        } catch (ClassNotFoundException | SQLException | InterruptedException | ParseException e) {
            System.out.println("Checked exception: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>Unchecked Exceptions</h3>
                        <p><strong>Definition:</strong> Runtime exceptions that don't need to be explicitly handled. Usually indicate programming errors.</p>
                        
                        <div class="code-block">
                            <pre><code>public class UncheckedExceptionExample {
    
    public static void demonstrateUnchecked() {
        // NullPointerException
        String str = null;
        try {
            int length = str.length(); // NPE
        } catch (NullPointerException e) {
            System.out.println("Null pointer: " + e.getMessage());
        }
        
        // ArrayIndexOutOfBoundsException
        int[] arr = {1, 2, 3};
        try {
            int value = arr[5]; // AIOOBE
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
        }
        
        // IllegalArgumentException
        try {
            Thread.sleep(-1000); // Negative sleep time
        } catch (IllegalArgumentException e) {
            System.out.println("Illegal argument: " + e.getMessage());
        } catch (InterruptedException e) {
            System.out.println("Thread interrupted");
        }
        
        // ClassCastException
        Object obj = "Hello";
        try {
            Integer num = (Integer) obj; // CCE
        } catch (ClassCastException e) {
            System.out.println("Class cast error: " + e.getMessage());
        }
        
        // NumberFormatException
        try {
            int num = Integer.parseInt("abc123");
        } catch (NumberFormatException e) {
            System.out.println("Number format error: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                        
                        <h4>Comparison Table:</h4>
                        <div class="code-block">
                            <pre><code>Aspect              | Checked Exceptions        | Unchecked Exceptions
--------------------|---------------------------|-------------------------
Compile-time check  | Yes - must handle/declare | No - optional handling
Inheritance         | Extends Exception         | Extends RuntimeException
Examples            | IOException, SQLException | NPE, IllegalArgumentException
Recovery            | Often recoverable         | Usually programming errors
Performance         | Slightly slower           | Faster (no compile checks)
Usage               | External resource errors  | Logic/programming errors</code></pre>
                        </div>
                    </div>
                </section>

                <section id="best-practices" class="section">
                    <h2>üèÜ Exception Handling Best Practices</h2>
                    
                    <div class="subsection">
                        <h3>1. Specific Exception Handling</h3>
                        <div class="code-block">
                            <pre><code>// ‚ùå Bad - Too generic
try {
    // risky operations
} catch (Exception e) {
    System.out.println("Something went wrong");
}

// ‚úÖ Good - Specific handling
try {
    processPayment(amount);
} catch (InsufficientFundsException e) {
    notifyUser("Insufficient funds: " + e.getShortfall());
} catch (InvalidCardException e) {
    notifyUser("Invalid card: " + e.getCardNumber());
} catch (NetworkException e) {
    retryPayment(amount);
}</code></pre>
                        </div>
                        
                        <h3>2. Proper Resource Management</h3>
                        <div class="code-block">
                            <pre><code>// ‚úÖ Good - Try-with-resources
public static void processFile(String filename) throws IOException {
    try (FileInputStream fis = new FileInputStream(filename);
         BufferedInputStream bis = new BufferedInputStream(fis);
         ObjectInputStream ois = new ObjectInputStream(bis)) {
        
        Object data = ois.readObject();
        processData(data);
        
    } catch (ClassNotFoundException e) {
        throw new IOException("Invalid file format", e);
    }
    // Resources automatically closed
}

// ‚úÖ Good - Manual resource management
public static void legacyResourceHandling(String filename) throws IOException {
    FileInputStream fis = null;
    try {
        fis = new FileInputStream(filename);
        // Process file
    } finally {
        if (fis != null) {
            try {
                fis.close();
            } catch (IOException e) {
                // Log but don't throw - avoid masking original exception
                logger.warn("Failed to close file", e);
            }
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>3. Meaningful Error Messages</h3>
                        <div class="code-block">
                            <pre><code>public class MeaningfulExceptions {
    
    // ‚úÖ Good - Descriptive messages with context
    public static void validateUser(User user) {
        if (user == null) {
            throw new IllegalArgumentException("User cannot be null");
        }
        if (user.getEmail() == null || user.getEmail().trim().isEmpty()) {
            throw new IllegalArgumentException(
                "User email is required for user ID: " + user.getId());
        }
        if (!isValidEmail(user.getEmail())) {
            throw new IllegalArgumentException(
                "Invalid email format: '" + user.getEmail() + 
                "' for user ID: " + user.getId());
        }
    }
    
    // ‚úÖ Good - Include relevant data in exceptions
    public static void transfer(Account from, Account to, double amount) 
            throws InsufficientFundsException {
        if (from.getBalance() < amount) {
            throw new InsufficientFundsException(
                String.format("Transfer failed: Account %s has balance $%.2f, " +
                             "but transfer amount is $%.2f", 
                             from.getAccountNumber(), from.getBalance(), amount),
                amount, from.getBalance());
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>4. Exception Logging and Monitoring</h3>
                        <div class="code-block">
                            <pre><code>public class ExceptionLogging {
    private static final Logger logger = LoggerFactory.getLogger(ExceptionLogging.class);
    
    public static void processOrder(Order order) {
        try {
            validateOrder(order);
            processPayment(order);
            updateInventory(order);
            sendConfirmation(order);
            
        } catch (ValidationException e) {
            // Log validation errors as warnings
            logger.warn("Order validation failed for order {}: {}", 
                       order.getId(), e.getMessage());
            throw e; // Re-throw for caller to handle
            
        } catch (PaymentException e) {
            // Log payment errors with full context
            logger.error("Payment processing failed for order {} amount ${}: {}", 
                        order.getId(), order.getTotal(), e.getMessage(), e);
            // Don't re-throw - handle gracefully
            handlePaymentFailure(order, e);
            
        } catch (Exception e) {
            // Log unexpected errors with full stack trace
            logger.error("Unexpected error processing order {}: {}", 
                        order.getId(), e.getMessage(), e);
            throw new OrderProcessingException("Failed to process order", e);
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>5. Don't Ignore Exceptions</h3>
                        <div class="code-block">
                            <pre><code>// ‚ùå Bad - Swallowing exceptions
try {
    riskyOperation();
} catch (Exception e) {
    // Silent failure - very bad!
}

// ‚ùå Bad - Generic logging without context
try {
    riskyOperation();
} catch (Exception e) {
    e.printStackTrace(); // Not helpful in production
}

// ‚úÖ Good - Proper exception handling
try {
    riskyOperation();
} catch (SpecificException e) {
    logger.error("Specific operation failed with input {}: {}", 
                input, e.getMessage(), e);
    // Take appropriate action
    handleFailure(e);
} catch (Exception e) {
    logger.error("Unexpected error in riskyOperation: {}", e.getMessage(), e);
    throw new ServiceException("Operation failed", e);
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="common-exceptions" class="section">
                    <h2>üîç Common Java Exceptions</h2>
                    
                    <div class="subsection">
                        <h3>Runtime Exceptions (Unchecked)</h3>
                        <div class="code-block">
                            <pre><code>public class CommonRuntimeExceptions {
    
    public static void demonstrateCommonExceptions() {
        
        // 1. NullPointerException - Most common
        String str = null;
        // str.length(); // NPE
        
        // 2. ArrayIndexOutOfBoundsException
        int[] arr = {1, 2, 3};
        // arr[5] = 10; // AIOOBE
        
        // 3. IllegalArgumentException
        // Thread.sleep(-1000); // Negative argument
        
        // 4. ClassCastException
        Object obj = "Hello";
        // Integer num = (Integer) obj; // CCE
        
        // 5. NumberFormatException
        // int num = Integer.parseInt("abc"); // NFE
        
        // 6. IllegalStateException
        List<String> list = Arrays.asList("a", "b", "c");
        Iterator<String> iter = list.iterator();
        // iter.remove(); // ISE - no next() called
        
        // 7. UnsupportedOperationException
        List<String> immutableList = Collections.unmodifiableList(list);
        // immutableList.add("d"); // UOE
        
        // 8. ConcurrentModificationException
        List<String> mutableList = new ArrayList<>(Arrays.asList("a", "b", "c"));
        for (String item : mutableList) {
            if ("b".equals(item)) {
                // mutableList.remove(item); // CME
            }
        }
    }
}</code></pre>
                        </div>
                        
                        <h3>Checked Exceptions</h3>
                        <div class="code-block">
                            <pre><code>public class CommonCheckedExceptions {
    
    public static void demonstrateCheckedExceptions() throws Exception {
        
        // 1. IOException and subclasses
        try {
            FileReader file = new FileReader("nonexistent.txt"); // FileNotFoundException
            file.read(); // IOException
        } catch (IOException e) {
            System.out.println("IO Error: " + e.getMessage());
        }
        
        // 2. SQLException
        try {
            Connection conn = DriverManager.getConnection("invalid_url");
        } catch (SQLException e) {
            System.out.println("Database Error: " + e.getMessage());
        }
        
        // 3. ClassNotFoundException
        try {
            Class.forName("com.nonexistent.Class");
        } catch (ClassNotFoundException e) {
            System.out.println("Class not found: " + e.getMessage());
        }
        
        // 4. InterruptedException
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // Restore interrupt status
            System.out.println("Thread interrupted");
        }
        
        // 5. ParseException
        try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            Date date = sdf.parse("invalid-date");
        } catch (ParseException e) {
            System.out.println("Parse error: " + e.getMessage());
        }
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="interview" class="section">
                    <h2>üíº Interview Questions</h2>
                    
                    <div class="subsection">
                        <h3>Frequently Asked Questions</h3>
                        
                        <div class="question-block">
                            <h4>Q1: What is the difference between throw and throws?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>throw:</strong> Used to explicitly throw an exception from code</li>
                                <li><strong>throws:</strong> Used in method signature to declare possible exceptions</li>
                                <li><strong>throw:</strong> Can throw only one exception at a time</li>
                                <li><strong>throws:</strong> Can declare multiple exceptions</li>
                                <li><strong>throw:</strong> Followed by exception instance</li>
                                <li><strong>throws:</strong> Followed by exception class names</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q2: Can we have try without catch?</h4>
                            <p><strong>Answer:</strong> Yes, but must have finally block. Also possible with try-with-resources.</p>
                            <div class="code-block">
                                <pre><code>// Valid - try with finally
try {
    // risky code
} finally {
    // cleanup
}

// Valid - try-with-resources
try (FileReader file = new FileReader("data.txt")) {
    // use file
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q3: What happens if exception occurs in finally block?</h4>
                            <p><strong>Answer:</strong> Exception in finally block masks the original exception from try/catch block. The finally exception becomes the method's thrown exception.</p>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q4: Difference between final, finally, and finalize?</h4>
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>final:</strong> Keyword for constants, preventing inheritance/override</li>
                                <li><strong>finally:</strong> Block that always executes in try-catch</li>
                                <li><strong>finalize():</strong> Method called by garbage collector before object destruction</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q5: Can we override a method that throws checked exception?</h4>
                            <p><strong>Answer:</strong> Yes, but with restrictions:</p>
                            <ul>
                                <li>Can throw same exception or its subclass</li>
                                <li>Can throw fewer exceptions</li>
                                <li>Cannot throw broader/new checked exceptions</li>
                                <li>Can throw any unchecked exceptions</li>
                            </ul>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q6: What is exception chaining?</h4>
                            <p><strong>Answer:</strong> Technique of catching one exception and throwing another while preserving the original exception as the cause. Helps maintain error context through call stack.</p>
                        </div>
                        
                        <h3>Coding Questions</h3>
                        
                        <div class="question-block">
                            <h4>Q7: Create a custom exception for bank operations</h4>
                            <div class="code-block">
                                <pre><code>public class BankOperationException extends Exception {
    private String accountNumber;
    private String operation;
    private double amount;
    
    public BankOperationException(String message, String accountNumber, 
                                 String operation, double amount) {
        super(message);
        this.accountNumber = accountNumber;
        this.operation = operation;
        this.amount = amount;
    }
    
    public BankOperationException(String message, Throwable cause, 
                                 String accountNumber, String operation, double amount) {
        super(message, cause);
        this.accountNumber = accountNumber;
        this.operation = operation;
        this.amount = amount;
    }
    
    // Getters
    public String getAccountNumber() { return accountNumber; }
    public String getOperation() { return operation; }
    public double getAmount() { return amount; }
    
    @Override
    public String toString() {
        return String.format("BankOperationException: %s [Account: %s, Operation: %s, Amount: %.2f]",
                           getMessage(), accountNumber, operation, amount);
    }
}</code></pre>
                            </div>
                        </div>
                        
                        <div class="question-block">
                            <h4>Q8: Implement retry mechanism with exception handling</h4>
                            <div class="code-block">
                                <pre><code>public class RetryMechanism {
    
    public static <T> T executeWithRetry(Supplier<T> operation, 
                                        int maxRetries, 
                                        long delayMs) throws Exception {
        Exception lastException = null;
        
        for (int attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                return operation.get();
            } catch (Exception e) {
                lastException = e;
                System.out.println("Attempt " + attempt + " failed: " + e.getMessage());
                
                if (attempt < maxRetries) {
                    try {
                        Thread.sleep(delayMs);
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new Exception("Retry interrupted", ie);
                    }
                }
            }
        }
        
        throw new Exception("Operation failed after " + maxRetries + " attempts", lastException);
    }
    
    // Usage example
    public static void main(String[] args) {
        try {
            String result = executeWithRetry(() -> {
                // Simulate unreliable operation
                if (Math.random() < 0.7) {
                    throw new RuntimeException("Random failure");
                }
                return "Success!";
            }, 3, 1000);
            
            System.out.println("Result: " + result);
        } catch (Exception e) {
            System.out.println("Final failure: " + e.getMessage());
        }
    }
}</code></pre>
                            </div>
                        </div>
                    </div>
                </section>

            </div>
            </div>
        </div>
    </div>
    
    <script src="../footer.js"></script>
</body>
</html>