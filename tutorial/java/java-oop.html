<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />
    <title>Java OOP Concepts - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css" />
  </head>
  <body class="page-java">
    <header>
      <div class="container">
        <div class="hero">
          <h1>Java Object-Oriented Programming</h1>
          <p>
            Master OOP Principles & Design Patterns for Enterprise Development
          </p>
        </div>
      </div>
    </header>
    <nav></nav>
    <script>
      window.activePage = 'java-oop'
    </script>
    <script src="../menu.js"></script>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const codeBlocks = document.querySelectorAll('pre code')
        codeBlocks.forEach((block) => {
          highlightJava(block)
        })
        updateActiveNav()
      })

      // Active navigation highlighting
      function updateActiveNav() {
        const sections = document.querySelectorAll('.section')
        const navLinks = document.querySelectorAll('.toc-nav a')

        let currentSection = ''
        sections.forEach((section) => {
          const rect = section.getBoundingClientRect()
          if (rect.top <= 100) {
            currentSection = section.id
          }
        })

        navLinks.forEach((link) => {
          link.classList.remove('active')
          if (link.getAttribute('href') === '#' + currentSection) {
            link.classList.add('active')
          }
        })
      }

      window.addEventListener('scroll', updateActiveNav)
      updateActiveNav()

      function highlightJava(element) {
        let code = element.textContent

        code = code.replace(
          /\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert)\b/g,
          '<span class="keyword">$1</span>'
        )

        code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>')
        code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>')

        code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>')
        code = code.replace(
          /\/\*[\s\S]*?\*\//g,
          '<span class="comment">$&</span>'
        )

        code = code.replace(
          /\b\d+(\.\d+)?[fLdF]?\b/g,
          '<span class="number">$&</span>'
        )

        code = code.replace(
          /\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g,
          '<span class="method">$1</span>('
        )

        code = code.replace(
          /\b[A-Z][a-zA-Z0-9_]*\b/g,
          '<span class="class">$&</span>'
        )

        element.innerHTML = code
      }
    </script>

    <div class="container">
      <div class="content-with-sidebar">
        <aside class="sidebar-toc">
          <div class="toc-header">
            <h2>üìö OOP Topics</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#overview">OOP Overview</a></li>
              <li><a href="#classes-objects">Classes & Objects</a></li>
              <li><a href="#encapsulation">Encapsulation</a></li>
              <li><a href="#inheritance">Inheritance</a></li>
              <li><a href="#polymorphism">Polymorphism</a></li>
              <li><a href="#abstraction">Abstraction</a></li>
              <li><a href="#interfaces">Interfaces</a></li>
              <li><a href="#constructors">Constructors</a></li>
              <li><a href="#static-members">Static Members</a></li>
              <li><a href="#design-patterns">Design Patterns</a></li>
              <li><a href="#best-practices">Best Practices</a></li>
              <li><a href="#interview">Interview Questions</a></li>
            </ul>
          </nav>
        </aside>

        <div class="main-content">
          <div class="topic">
            <section id="overview" class="section">
              <h2>üöÄ Object-Oriented Programming Overview</h2>

              <div class="subsection">
                <h3>What is OOP?</h3>
                <p>
                  <strong>Definition:</strong> Object-Oriented Programming is a
                  programming paradigm based on the concept of objects, which
                  contain data (attributes) and code (methods). OOP focuses on
                  creating reusable, modular, and maintainable code.
                </p>

                <h4>Four Pillars of OOP:</h4>
                <ul>
                  <li>
                    <strong>Encapsulation:</strong> Bundling data and methods
                    together, hiding internal details
                  </li>
                  <li>
                    <strong>Inheritance:</strong> Creating new classes based on
                    existing classes
                  </li>
                  <li>
                    <strong>Polymorphism:</strong> Same interface, different
                    implementations
                  </li>
                  <li>
                    <strong>Abstraction:</strong> Hiding complex implementation
                    details, showing only essential features
                  </li>
                </ul>

                <h4>Benefits of OOP:</h4>
                <ul>
                  <li>
                    <strong>Modularity:</strong> Code is organized into
                    separate, interchangeable components
                  </li>
                  <li>
                    <strong>Reusability:</strong> Objects can be reused across
                    different parts of application
                  </li>
                  <li>
                    <strong>Maintainability:</strong> Changes to one part don't
                    affect other parts
                  </li>
                  <li>
                    <strong>Scalability:</strong> Easy to extend and modify
                    existing code
                  </li>
                  <li>
                    <strong>Real-world Modeling:</strong> Maps closely to
                    real-world entities and relationships
                  </li>
                </ul>

                <h4>OOP vs Procedural Programming:</h4>
                <div class="code-block">
                  <pre><code>Aspect          | OOP                      | Procedural
----------------|--------------------------|---------------------------
Focus           | Objects and classes      | Functions and procedures
Data Security   | Encapsulated (private)   | Global data access
Code Reuse      | Inheritance, composition | Function calls
Problem Solving | Bottom-up approach       | Top-down approach
Maintenance     | Easier to maintain       | Harder as code grows
Examples        | Java, C++, Python       | C, Pascal, FORTRAN</code></pre>
                </div>
              </div>
            </section>

            <section id="classes-objects" class="section">
              <h2>üèóÔ∏è Classes and Objects</h2>

              <div class="subsection">
                <h3>Understanding Classes and Objects</h3>
                <p>
                  <strong>Class:</strong> A blueprint or template for creating
                  objects. Defines attributes and methods that objects will
                  have.
                </p>
                <p>
                  <strong>Object:</strong> An instance of a class. Contains
                  actual data and can perform actions defined by the class.
                </p>

                <h4>Basic Class Structure:</h4>
                <div class="code-block">
                  <pre><code>// Class definition
public class Car {
    // Instance variables (attributes)
    private String brand;
    private String model;
    private int year;
    private double price;
    private boolean isRunning;
    
    // Constructor
    public Car(String brand, String model, int year, double price) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.price = price;
        this.isRunning = false;
    }
    
    // Instance methods (behaviors)
    public void start() {
        if (!isRunning) {
            isRunning = true;
            System.out.println(brand + " " + model + " is now running");
        } else {
            System.out.println("Car is already running");
        }
    }
    
    public void stop() {
        if (isRunning) {
            isRunning = false;
            System.out.println(brand + " " + model + " has stopped");
        } else {
            System.out.println("Car is already stopped");
        }
    }
    
    public void accelerate(int speed) {
        if (isRunning) {
            System.out.println("Accelerating to " + speed + " mph");
        } else {
            System.out.println("Cannot accelerate. Car is not running.");
        }
    }
    
    // Getter methods
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public int getYear() { return year; }
    public double getPrice() { return price; }
    public boolean isRunning() { return isRunning; }
    
    // Setter methods
    public void setPrice(double price) {
        if (price > 0) {
            this.price = price;
        }
    }
    
    // toString method for string representation
    @Override
    public String toString() {
        return String.format("%d %s %s - $%.2f %s", 
                           year, brand, model, price, 
                           isRunning ? "(Running)" : "(Stopped)");
    }
}</code></pre>
                </div>

                <h4>Creating and Using Objects:</h4>
                <div class="code-block">
                  <pre><code>public class CarDemo {
    public static void main(String[] args) {
        // Creating objects (instantiation)
        Car car1 = new Car("Toyota", "Camry", 2023, 28000.0);
        Car car2 = new Car("Honda", "Civic", 2022, 25000.0);
        Car car3 = new Car("BMW", "X5", 2023, 65000.0);
        
        // Using object methods
        System.out.println("=== Car Information ===");
        System.out.println(car1);
        System.out.println(car2);
        System.out.println(car3);
        
        System.out.println("\n=== Starting Cars ===");
        car1.start();
        car2.start();
        
        System.out.println("\n=== Accelerating ===");
        car1.accelerate(60);
        car2.accelerate(45);
        car3.accelerate(30); // This won't work - car not started
        
        System.out.println("\n=== Stopping Cars ===");
        car1.stop();
        car2.stop();
        
        // Accessing object properties through getters
        System.out.println("\n=== Car Details ===");
        System.out.println("Car 1: " + car1.getYear() + " " + 
                          car1.getBrand() + " " + car1.getModel());
        System.out.println("Price: $" + car1.getPrice());
        
        // Modifying object state
        car1.setPrice(26000.0);
        System.out.println("Updated price: $" + car1.getPrice());
    }
}</code></pre>
                </div>

                <h4>Object Memory Allocation:</h4>
                <div class="code-block">
                  <pre><code>public class ObjectMemoryExample {
    public static void main(String[] args) {
        // Reference variables are stored in stack
        Car car1;           // Reference variable (null initially)
        Car car2;           // Reference variable (null initially)
        
        // Objects are created in heap memory
        car1 = new Car("Toyota", "Prius", 2023, 30000.0); // Object in heap
        car2 = new Car("Honda", "Accord", 2022, 32000.0); // Object in heap
        
        // Multiple references to same object
        Car car3 = car1;    // car3 points to same object as car1
        
        System.out.println("car1 == car2: " + (car1 == car2)); // false (different objects)
        System.out.println("car1 == car3: " + (car1 == car3)); // true (same object)
        
        // Modifying through one reference affects all references to same object
        car3.setPrice(28000.0);
        System.out.println("car1 price: " + car1.getPrice()); // 28000.0
        System.out.println("car3 price: " + car3.getPrice()); // 28000.0
        
        // Setting reference to null
        car1 = null; // car1 no longer points to any object
        // car3 still points to the Toyota object
        System.out.println("car3 still works: " + car3.getBrand()); // Toyota
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="encapsulation" class="section">
              <h2>üîí Encapsulation</h2>

              <div class="subsection">
                <h3>What is Encapsulation?</h3>
                <p>
                  <strong>Definition:</strong> Encapsulation is the bundling of
                  data (variables) and methods that operate on that data into a
                  single unit (class), while restricting direct access to some
                  components.
                </p>

                <h4>Access Modifiers:</h4>
                <div class="code-block">
                  <pre><code>Modifier    | Same Class | Same Package | Subclass | Different Package
------------|------------|--------------|----------|------------------
private     | ‚úì          | ‚úó            | ‚úó        | ‚úó
default     | ‚úì          | ‚úì            | ‚úó        | ‚úó
protected   | ‚úì          | ‚úì            | ‚úì        | ‚úó
public      | ‚úì          | ‚úì            | ‚úì        | ‚úì</code></pre>
                </div>

                <h4>Proper Encapsulation Example:</h4>
                <div class="code-block">
                  <pre><code>public class BankAccount {
    // Private fields - cannot be accessed directly from outside
    private String accountNumber;
    private String accountHolderName;
    private double balance;
    private String accountType;
    
    // Constructor
    public BankAccount(String accountNumber, String accountHolderName, 
                      String accountType, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolderName = accountHolderName;
        this.accountType = accountType;
        this.balance = initialBalance >= 0 ? initialBalance : 0;
    }
    
    // Public getter methods - controlled access to private data
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public String getAccountHolderName() {
        return accountHolderName;
    }
    
    public double getBalance() {
        return balance;
    }
    
    public String getAccountType() {
        return accountType;
    }
    
    // Public methods with business logic and validation
    public boolean deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: $" + amount);
            System.out.println("New balance: $" + balance);
            return true;
        } else {
            System.out.println("Invalid deposit amount: $" + amount);
            return false;
        }
    }
    
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrawn: $" + amount);
            System.out.println("New balance: $" + balance);
            return true;
        } else if (amount > balance) {
            System.out.println("Insufficient funds. Balance: $" + balance);
            return false;
        } else {
            System.out.println("Invalid withdrawal amount: $" + amount);
            return false;
        }
    }
    
    public boolean transfer(BankAccount targetAccount, double amount) {
        if (this.withdraw(amount)) {
            targetAccount.deposit(amount);
            System.out.println("Transfer successful to account: " + 
                             targetAccount.getAccountNumber());
            return true;
        } else {
            System.out.println("Transfer failed");
            return false;
        }
    }
    
    // Private helper method - internal use only
    private void logTransaction(String type, double amount) {
        System.out.println("Transaction: " + type + " - $" + amount + 
                          " - Balance: $" + balance);
    }
    
    @Override
    public String toString() {
        return String.format("Account[%s] - %s (%s) - Balance: $%.2f",
                           accountNumber, accountHolderName, accountType, balance);
    }
}</code></pre>
                </div>

                <h4>Benefits of Encapsulation:</h4>
                <div class="code-block">
                  <pre><code>public class EncapsulationDemo {
    public static void main(String[] args) {
        BankAccount account1 = new BankAccount("ACC001", "John Doe", "Savings", 1000.0);
        BankAccount account2 = new BankAccount("ACC002", "Jane Smith", "Checking", 500.0);
        
        // ‚úÖ Proper way - using public methods
        account1.deposit(200.0);
        account1.withdraw(150.0);
        account1.transfer(account2, 100.0);
        
        // ‚ùå This won't work - private fields are not accessible
        // account1.balance = 10000.0; // Compilation error
        // account1.accountNumber = "HACKED"; // Compilation error
        
        // ‚úÖ Controlled access through getters
        System.out.println("Account 1 balance: $" + account1.getBalance());
        System.out.println("Account 2 balance: $" + account2.getBalance());
        
        // Data integrity is maintained through validation in methods
        account1.withdraw(-50.0);  // Invalid - negative amount
        account1.withdraw(5000.0); // Invalid - insufficient funds
        
        System.out.println("\nFinal account states:");
        System.out.println(account1);
        System.out.println(account2);
    }
}</code></pre>
                </div>

                <h4>Data Validation in Encapsulation:</h4>
                <div class="code-block">
                  <pre><code>public class Student {
    private String name;
    private int age;
    private String email;
    private double gpa;
    
    public Student(String name, int age, String email, double gpa) {
        setName(name);
        setAge(age);
        setEmail(email);
        setGpa(gpa);
    }
    
    // Setter with validation
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name.trim();
        } else {
            throw new IllegalArgumentException("Name cannot be null or empty");
        }
    }
    
    public void setAge(int age) {
        if (age >= 16 && age <= 100) {
            this.age = age;
        } else {
            throw new IllegalArgumentException("Age must be between 16 and 100");
        }
    }
    
    public void setEmail(String email) {
        if (email != null && email.contains("@") && email.contains(".")) {
            this.email = email.toLowerCase();
        } else {
            throw new IllegalArgumentException("Invalid email format");
        }
    }
    
    public void setGpa(double gpa) {
        if (gpa >= 0.0 && gpa <= 4.0) {
            this.gpa = gpa;
        } else {
            throw new IllegalArgumentException("GPA must be between 0.0 and 4.0");
        }
    }
    
    // Getters
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    public double getGpa() { return gpa; }
    
    // Computed properties
    public String getGradeLevel() {
        if (gpa >= 3.7) return "A";
        else if (gpa >= 3.3) return "B+";
        else if (gpa >= 3.0) return "B";
        else if (gpa >= 2.7) return "C+";
        else if (gpa >= 2.0) return "C";
        else return "D";
    }
    
    public boolean isHonorStudent() {
        return gpa >= 3.5;
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="inheritance" class="section">
              <h2>üß¨ Inheritance</h2>

              <div class="subsection">
                <h3>What is Inheritance?</h3>
                <p>
                  <strong>Definition:</strong> Inheritance allows a class to
                  inherit properties and methods from another class, promoting
                  code reuse and establishing an "is-a" relationship.
                </p>

                <h4>Basic Inheritance Example:</h4>
                <div class="code-block">
                  <pre><code>// Parent class (Superclass/Base class)
public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;
    protected double price;
    
    public Vehicle(String brand, String model, int year, double price) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        this.price = price;
    }
    
    public void start() {
        System.out.println(brand + " " + model + " is starting...");
    }
    
    public void stop() {
        System.out.println(brand + " " + model + " has stopped.");
    }
    
    public void displayInfo() {
        System.out.println(year + " " + brand + " " + model + " - $" + price);
    }
    
    // Getters
    public String getBrand() { return brand; }
    public String getModel() { return model; }
    public int getYear() { return year; }
    public double getPrice() { return price; }
}

// Child class (Subclass/Derived class)
public class Car extends Vehicle {
    private int numberOfDoors;
    private String fuelType;
    
    public Car(String brand, String model, int year, double price, 
               int numberOfDoors, String fuelType) {
        super(brand, model, year, price); // Call parent constructor
        this.numberOfDoors = numberOfDoors;
        this.fuelType = fuelType;
    }
    
    // Method specific to Car
    public void openTrunk() {
        System.out.println("Opening trunk of " + brand + " " + model);
    }
    
    // Override parent method
    @Override
    public void displayInfo() {
        super.displayInfo(); // Call parent method
        System.out.println("Doors: " + numberOfDoors + ", Fuel: " + fuelType);
    }
    
    // Getters for Car-specific properties
    public int getNumberOfDoors() { return numberOfDoors; }
    public String getFuelType() { return fuelType; }
}

// Another child class
public class Motorcycle extends Vehicle {
    private boolean hasSidecar;
    private int engineCC;
    
    public Motorcycle(String brand, String model, int year, double price,
                     boolean hasSidecar, int engineCC) {
        super(brand, model, year, price);
        this.hasSidecar = hasSidecar;
        this.engineCC = engineCC;
    }
    
    public void wheelie() {
        System.out.println("Performing wheelie on " + brand + " " + model + "!");
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Engine: " + engineCC + "cc, Sidecar: " + 
                          (hasSidecar ? "Yes" : "No"));
    }
    
    public boolean isHasSidecar() { return hasSidecar; }
    public int getEngineCC() { return engineCC; }
}</code></pre>
                </div>

                <h4>Inheritance Demonstration:</h4>
                <div class="code-block">
                  <pre><code>public class InheritanceDemo {
    public static void main(String[] args) {
        // Creating objects of different classes
        Vehicle vehicle = new Vehicle("Generic", "Vehicle", 2023, 15000.0);
        Car car = new Car("Toyota", "Camry", 2023, 28000.0, 4, "Gasoline");
        Motorcycle bike = new Motorcycle("Harley", "Sportster", 2023, 12000.0, false, 883);
        
        System.out.println("=== Vehicle Information ===");
        vehicle.displayInfo();
        vehicle.start();
        vehicle.stop();
        
        System.out.println("\n=== Car Information ===");
        car.displayInfo();      // Overridden method
        car.start();            // Inherited method
        car.openTrunk();        // Car-specific method
        car.stop();             // Inherited method
        
        System.out.println("\n=== Motorcycle Information ===");
        bike.displayInfo();     // Overridden method
        bike.start();           // Inherited method
        bike.wheelie();         // Motorcycle-specific method
        bike.stop();            // Inherited method
        
        // Demonstrating "is-a" relationship
        System.out.println("\n=== Is-A Relationship ===");
        System.out.println("car is Vehicle: " + (car instanceof Vehicle));     // true
        System.out.println("bike is Vehicle: " + (bike instanceof Vehicle));   // true
        System.out.println("car is Car: " + (car instanceof Car));             // true
        System.out.println("car is Motorcycle: " + (car instanceof Motorcycle)); // false
    }
}</code></pre>
                </div>

                <h4>Multi-level Inheritance:</h4>
                <div class="code-block">
                  <pre><code>// Level 1: Base class
public class Animal {
    protected String name;
    protected int age;
    
    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void eat() {
        System.out.println(name + " is eating");
    }
    
    public void sleep() {
        System.out.println(name + " is sleeping");
    }
}

// Level 2: Intermediate class
public class Mammal extends Animal {
    protected boolean hasFur;
    
    public Mammal(String name, int age, boolean hasFur) {
        super(name, age);
        this.hasFur = hasFur;
    }
    
    public void giveBirth() {
        System.out.println(name + " is giving birth to live young");
    }
}

// Level 3: Final derived class
public class Dog extends Mammal {
    private String breed;
    
    public Dog(String name, int age, String breed) {
        super(name, age, true); // Dogs have fur
        this.breed = breed;
    }
    
    public void bark() {
        System.out.println(name + " the " + breed + " is barking: Woof!");
    }
    
    @Override
    public void eat() {
        System.out.println(name + " the dog is eating dog food");
    }
    
    // Dog has access to all methods from Animal and Mammal
    public void displayInfo() {
        System.out.println("Dog: " + name + ", Age: " + age + 
                          ", Breed: " + breed + ", Has fur: " + hasFur);
    }
}</code></pre>
                </div>

                <h4>Method Overriding Rules:</h4>
                <div class="code-block">
                  <pre><code>public class OverridingRules {
    
    // Parent class
    static class Parent {
        public void method1() { }           // Can be overridden
        protected void method2() { }        // Can be overridden
        final void method3() { }            // Cannot be overridden
        static void method4() { }           // Cannot be overridden (hidden instead)
        private void method5() { }          // Cannot be overridden (not inherited)
    }
    
    // Child class
    static class Child extends Parent {
        @Override
        public void method1() {             // ‚úÖ Valid override
            System.out.println("Overridden method1");
        }
        
        @Override
        public void method2() {             // ‚úÖ Valid - can increase visibility
            System.out.println("Overridden method2");
        }
        
        // public void method3() { }        // ‚ùå Error - cannot override final method
        
        public static void method4() {      // ‚úÖ Valid - method hiding (not overriding)
            System.out.println("Hidden static method");
        }
        
        public void method5() {             // ‚úÖ Valid - new method (not overriding)
            System.out.println("New method5 in child");
        }
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="polymorphism" class="section">
              <h2>üé≠ Polymorphism</h2>

              <div class="subsection">
                <h3>What is Polymorphism?</h3>
                <p>
                  <strong>Definition:</strong> Polymorphism allows objects of
                  different types to be treated as objects of a common base
                  type, while maintaining their specific behavior. "One
                  interface, multiple implementations."
                </p>

                <h4>Types of Polymorphism:</h4>
                <ul>
                  <li>
                    <strong>Runtime Polymorphism:</strong> Method overriding
                    (dynamic binding)
                  </li>
                  <li>
                    <strong>Compile-time Polymorphism:</strong> Method
                    overloading (static binding)
                  </li>
                </ul>

                <h4>Runtime Polymorphism Example:</h4>
                <div class="code-block">
                  <pre><code>// Base class
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // Abstract method - must be implemented by subclasses
    public abstract double calculateArea();
    public abstract double calculatePerimeter();
    
    // Concrete method - can be overridden
    public void displayInfo() {
        System.out.println("Shape: " + getClass().getSimpleName() + 
                          ", Color: " + color);
        System.out.println("Area: " + calculateArea());
        System.out.println("Perimeter: " + calculatePerimeter());
    }
    
    public String getColor() { return color; }
}

// Concrete subclasses
public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
    
    public double getRadius() { return radius; }
}

public class Rectangle extends Shape {
    private double length;
    private double width;
    
    public Rectangle(String color, double length, double width) {
        super(color);
        this.length = length;
        this.width = width;
    }
    
    @Override
    public double calculateArea() {
        return length * width;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * (length + width);
    }
    
    public double getLength() { return length; }
    public double getWidth() { return width; }
}

public class Triangle extends Shape {
    private double side1, side2, side3;
    
    public Triangle(String color, double side1, double side2, double side3) {
        super(color);
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }
    
    @Override
    public double calculateArea() {
        // Using Heron's formula
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }
    
    @Override
    public double calculatePerimeter() {
        return side1 + side2 + side3;
    }
}</code></pre>
                </div>

                <h4>Polymorphism in Action:</h4>
                <div class="code-block">
                  <pre><code>public class PolymorphismDemo {
    
    public static void main(String[] args) {
        // Polymorphic array - different objects, same reference type
        Shape[] shapes = {
            new Circle("Red", 5.0),
            new Rectangle("Blue", 4.0, 6.0),
            new Triangle("Green", 3.0, 4.0, 5.0),
            new Circle("Yellow", 3.0),
            new Rectangle("Purple", 2.0, 8.0)
        };
        
        System.out.println("=== Polymorphic Method Calls ===");
        double totalArea = 0;
        
        // Same method call, different implementations
        for (Shape shape : shapes) {
            shape.displayInfo();        // Calls appropriate overridden method
            totalArea += shape.calculateArea();
            System.out.println("---");
        }
        
        System.out.println("Total area of all shapes: " + totalArea);
        
        // Method that works with any Shape
        processShape(new Circle("Orange", 7.0));
        processShape(new Rectangle("Pink", 5.0, 3.0));
        
        // Demonstrating instanceof and casting
        demonstrateInstanceOf(shapes);
    }
    
    // Polymorphic method - accepts any Shape
    public static void processShape(Shape shape) {
        System.out.println("\n=== Processing Shape ===");
        shape.displayInfo();
        
        // Type checking and casting
        if (shape instanceof Circle) {
            Circle circle = (Circle) shape;
            System.out.println("Circle radius: " + circle.getRadius());
        } else if (shape instanceof Rectangle) {
            Rectangle rect = (Rectangle) shape;
            System.out.println("Rectangle dimensions: " + rect.getLength() + 
                             " x " + rect.getWidth());
        }
    }
    
    public static void demonstrateInstanceOf(Shape[] shapes) {
        System.out.println("\n=== Type Checking ===");
        int circles = 0, rectangles = 0, triangles = 0;
        
        for (Shape shape : shapes) {
            if (shape instanceof Circle) {
                circles++;
            } else if (shape instanceof Rectangle) {
                rectangles++;
            } else if (shape instanceof Triangle) {
                triangles++;
            }
        }
        
        System.out.println("Circles: " + circles);
        System.out.println("Rectangles: " + rectangles);
        System.out.println("Triangles: " + triangles);
    }
}</code></pre>
                </div>

                <h4>Method Overloading (Compile-time Polymorphism):</h4>
                <div class="code-block">
                  <pre><code>public class Calculator {
    
    // Method overloading - same name, different parameters
    public int add(int a, int b) {
        System.out.println("Adding two integers");
        return a + b;
    }
    
    public double add(double a, double b) {
        System.out.println("Adding two doubles");
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        System.out.println("Adding three integers");
        return a + b + c;
    }
    
    public String add(String a, String b) {
        System.out.println("Concatenating two strings");
        return a + b;
    }
    
    // Variable arguments (varargs)
    public int add(int... numbers) {
        System.out.println("Adding " + numbers.length + " integers using varargs");
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Compiler determines which method to call based on arguments
        System.out.println("Result: " + calc.add(5, 3));           // int version
        System.out.println("Result: " + calc.add(5.5, 3.2));      // double version
        System.out.println("Result: " + calc.add(1, 2, 3));       // three int version
        System.out.println("Result: " + calc.add("Hello", "World")); // String version
        System.out.println("Result: " + calc.add(1, 2, 3, 4, 5)); // varargs version
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="abstraction" class="section">
              <h2>üé® Abstraction</h2>

              <div class="subsection">
                <h3>What is Abstraction?</h3>
                <p>
                  <strong>Definition:</strong> Abstraction hides complex
                  implementation details while showing only essential features
                  of an object. It focuses on what an object does rather than
                  how it does it.
                </p>

                <h4>Abstract Classes:</h4>
                <div class="code-block">
                  <pre><code>// Abstract class - cannot be instantiated
public abstract class Employee {
    protected String name;
    protected int employeeId;
    protected double baseSalary;
    
    public Employee(String name, int employeeId, double baseSalary) {
        this.name = name;
        this.employeeId = employeeId;
        this.baseSalary = baseSalary;
    }
    
    // Abstract methods - must be implemented by subclasses
    public abstract double calculateSalary();
    public abstract String getJobTitle();
    public abstract void performDuties();
    
    // Concrete methods - shared by all employees
    public void clockIn() {
        System.out.println(name + " (" + getJobTitle() + ") clocked in at " + 
                          java.time.LocalTime.now());
    }
    
    public void clockOut() {
        System.out.println(name + " (" + getJobTitle() + ") clocked out at " + 
                          java.time.LocalTime.now());
    }
    
    public void displayInfo() {
        System.out.println("Employee: " + name);
        System.out.println("ID: " + employeeId);
        System.out.println("Job Title: " + getJobTitle());
        System.out.println("Salary: $" + calculateSalary());
    }
    
    // Getters
    public String getName() { return name; }
    public int getEmployeeId() { return employeeId; }
    public double getBaseSalary() { return baseSalary; }
}

// Concrete subclass 1
public class FullTimeEmployee extends Employee {
    private double benefits;
    private int vacationDays;
    
    public FullTimeEmployee(String name, int employeeId, double baseSalary, 
                           double benefits, int vacationDays) {
        super(name, employeeId, baseSalary);
        this.benefits = benefits;
        this.vacationDays = vacationDays;
    }
    
    @Override
    public double calculateSalary() {
        return baseSalary + benefits;
    }
    
    @Override
    public String getJobTitle() {
        return "Full-Time Employee";
    }
    
    @Override
    public void performDuties() {
        System.out.println(name + " is working full-time duties (40 hours/week)");
    }
    
    public int getVacationDays() { return vacationDays; }
}

// Concrete subclass 2
public class PartTimeEmployee extends Employee {
    private int hoursWorked;
    private double hourlyRate;
    
    public PartTimeEmployee(String name, int employeeId, double hourlyRate, int hoursWorked) {
        super(name, employeeId, 0); // No base salary for part-time
        this.hourlyRate = hourlyRate;
        this.hoursWorked = hoursWorked;
    }
    
    @Override
    public double calculateSalary() {
        return hourlyRate * hoursWorked;
    }
    
    @Override
    public String getJobTitle() {
        return "Part-Time Employee";
    }
    
    @Override
    public void performDuties() {
        System.out.println(name + " is working part-time duties (" + hoursWorked + " hours/week)");
    }
    
    public int getHoursWorked() { return hoursWorked; }
    public double getHourlyRate() { return hourlyRate; }
}

// Concrete subclass 3
public class Contractor extends Employee {
    private double contractAmount;
    private String projectName;
    
    public Contractor(String name, int employeeId, double contractAmount, String projectName) {
        super(name, employeeId, 0); // No base salary for contractors
        this.contractAmount = contractAmount;
        this.projectName = projectName;
    }
    
    @Override
    public double calculateSalary() {
        return contractAmount;
    }
    
    @Override
    public String getJobTitle() {
        return "Contractor";
    }
    
    @Override
    public void performDuties() {
        System.out.println(name + " is working on contract project: " + projectName);
    }
    
    public String getProjectName() { return projectName; }
}</code></pre>
                </div>

                <h4>Using Abstract Classes:</h4>
                <div class="code-block">
                  <pre><code>public class AbstractionDemo {
    
    public static void main(String[] args) {
        // Cannot instantiate abstract class
        // Employee emp = new Employee("John", 1, 50000); // Compilation error
        
        // Create concrete implementations
        Employee[] employees = {
            new FullTimeEmployee("Alice Johnson", 101, 75000, 15000, 25),
            new PartTimeEmployee("Bob Smith", 102, 25.0, 20),
            new Contractor("Carol Davis", 103, 120000, "Website Redesign"),
            new FullTimeEmployee("David Wilson", 104, 85000, 18000, 30)
        };
        
        System.out.println("=== Employee Management System ===");
        
        double totalPayroll = 0;
        for (Employee emp : employees) {
            emp.clockIn();
            emp.performDuties();
            emp.displayInfo();
            totalPayroll += emp.calculateSalary();
            emp.clockOut();
            System.out.println("---");
        }
        
        System.out.println("Total Payroll: $" + totalPayroll);
        
        // Demonstrate polymorphism with abstraction
        processEmployee(new FullTimeEmployee("Eve Brown", 105, 90000, 20000, 28));
        processEmployee(new Contractor("Frank Miller", 106, 150000, "Mobile App"));
    }
    
    // Method that works with any Employee (abstraction in action)
    public static void processEmployee(Employee employee) {
        System.out.println("\n=== Processing Employee ===");
        employee.displayInfo();
        employee.performDuties();
        
        // Type-specific operations
        if (employee instanceof FullTimeEmployee) {
            FullTimeEmployee fte = (FullTimeEmployee) employee;
            System.out.println("Vacation days available: " + fte.getVacationDays());
        } else if (employee instanceof PartTimeEmployee) {
            PartTimeEmployee pte = (PartTimeEmployee) employee;
            System.out.println("Hourly rate: $" + pte.getHourlyRate());
        } else if (employee instanceof Contractor) {
            Contractor contractor = (Contractor) employee;
            System.out.println("Project: " + contractor.getProjectName());
        }
    }
}</code></pre>
                </div>

                <h4>Abstract Class vs Interface:</h4>
                <div class="code-block">
                  <pre><code>Feature                 | Abstract Class              | Interface
------------------------|-----------------------------|--------------------------
Instantiation           | Cannot be instantiated      | Cannot be instantiated
Methods                 | Abstract + concrete methods | Abstract methods (default in Java 8+)
Variables               | Instance variables allowed  | Only public static final
Inheritance             | Single inheritance (extends)| Multiple inheritance (implements)
Access Modifiers        | All access modifiers        | Public methods only (default/static in Java 8+)
Constructor             | Can have constructors       | Cannot have constructors
When to Use             | Common base with shared code| Contract definition only</code></pre>
                </div>
              </div>
            </section>

            <section id="interfaces" class="section">
              <h2>üîå Interfaces</h2>

              <div class="subsection">
                <h3>What are Interfaces?</h3>
                <p>
                  <strong>Definition:</strong> An interface is a contract that
                  defines what methods a class must implement, without providing
                  the implementation details. It represents "can-do"
                  relationships.
                </p>

                <h4>Basic Interface Example:</h4>
                <div class="code-block">
                  <pre><code>// Interface definition
public interface Drawable {
    // Abstract methods (implicitly public abstract)
    void draw();
    void resize(double factor);
    void move(int x, int y);
    
    // Constants (implicitly public static final)
    String DEFAULT_COLOR = "BLACK";
    int MAX_SIZE = 1000;
}

// Interface implementation
public class Circle implements Drawable {
    private double radius;
    private int x, y;
    private String color;
    
    public Circle(double radius, int x, int y, String color) {
        this.radius = radius;
        this.x = x;
        this.y = y;
        this.color = color;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " circle at (" + x + "," + y + 
                          ") with radius " + radius);
    }
    
    @Override
    public void resize(double factor) {
        radius *= factor;
        System.out.println("Circle resized by factor " + factor + 
                          ", new radius: " + radius);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("Circle moved to (" + x + "," + y + ")");
    }
    
    // Circle-specific methods
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle implements Drawable {
    private double width, height;
    private int x, y;
    private String color;
    
    public Rectangle(double width, double height, int x, int y, String color) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
        this.color = color;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " rectangle at (" + x + "," + y + 
                          ") with dimensions " + width + "x" + height);
    }
    
    @Override
    public void resize(double factor) {
        width *= factor;
        height *= factor;
        System.out.println("Rectangle resized by factor " + factor + 
                          ", new dimensions: " + width + "x" + height);
    }
    
    @Override
    public void move(int newX, int newY) {
        this.x = newX;
        this.y = newY;
        System.out.println("Rectangle moved to (" + x + "," + y + ")");
    }
    
    public double getArea() {
        return width * height;
    }
}</code></pre>
                </div>

                <h4>Multiple Interface Implementation:</h4>
                <div class="code-block">
                  <pre><code>// Multiple interfaces
public interface Flyable {
    void fly();
    void land();
    double getMaxAltitude();
}

public interface Swimmable {
    void swim();
    void dive(double depth);
    double getMaxDepth();
}

public interface Walkable {
    void walk();
    void run();
    double getMaxSpeed();
}

// Class implementing multiple interfaces
public class Duck implements Flyable, Swimmable, Walkable {
    private String name;
    private boolean isFlying;
    private boolean isSwimming;
    private boolean isWalking;
    
    public Duck(String name) {
        this.name = name;
    }
    
    // Flyable implementation
    @Override
    public void fly() {
        isFlying = true;
        isSwimming = false;
        isWalking = false;
        System.out.println(name + " is flying");
    }
    
    @Override
    public void land() {
        isFlying = false;
        System.out.println(name + " has landed");
    }
    
    @Override
    public double getMaxAltitude() {
        return 500.0; // meters
    }
    
    // Swimmable implementation
    @Override
    public void swim() {
        isSwimming = true;
        isFlying = false;
        isWalking = false;
        System.out.println(name + " is swimming");
    }
    
    @Override
    public void dive(double depth) {
        System.out.println(name + " is diving to " + depth + " meters");
    }
    
    @Override
    public double getMaxDepth() {
        return 10.0; // meters
    }
    
    // Walkable implementation
    @Override
    public void walk() {
        isWalking = true;
        isFlying = false;
        isSwimming = false;
        System.out.println(name + " is walking");
    }
    
    @Override
    public void run() {
        System.out.println(name + " is running");
    }
    
    @Override
    public double getMaxSpeed() {
        return 15.0; // km/h
    }
    
    public void displayStatus() {
        System.out.println(name + " status - Flying: " + isFlying + 
                          ", Swimming: " + isSwimming + ", Walking: " + isWalking);
    }
}</code></pre>
                </div>

                <h4>Interface with Default and Static Methods (Java 8+):</h4>
                <div class="code-block">
                  <pre><code>public interface Vehicle {
    // Abstract methods
    void start();
    void stop();
    double getMaxSpeed();
    
    // Default method - provides default implementation
    default void honk() {
        System.out.println("Beep beep!");
    }
    
    default void displayInfo() {
        System.out.println("Vehicle max speed: " + getMaxSpeed() + " km/h");
    }
    
    // Static method - belongs to interface, not implementing class
    static boolean isValidSpeed(double speed) {
        return speed >= 0 && speed <= 500;
    }
    
    static void compareVehicles(Vehicle v1, Vehicle v2) {
        System.out.println("Vehicle 1 max speed: " + v1.getMaxSpeed());
        System.out.println("Vehicle 2 max speed: " + v2.getMaxSpeed());
        System.out.println("Faster vehicle: " + 
                          (v1.getMaxSpeed() > v2.getMaxSpeed() ? "Vehicle 1" : "Vehicle 2"));
    }
}

public class Car implements Vehicle {
    private String model;
    private boolean isRunning;
    
    public Car(String model) {
        this.model = model;
    }
    
    @Override
    public void start() {
        isRunning = true;
        System.out.println(model + " car started");
    }
    
    @Override
    public void stop() {
        isRunning = false;
        System.out.println(model + " car stopped");
    }
    
    @Override
    public double getMaxSpeed() {
        return 200.0;
    }
    
    // Override default method if needed
    @Override
    public void honk() {
        System.out.println(model + " car: HONK HONK!");
    }
}

public class Bicycle implements Vehicle {
    private String type;
    
    public Bicycle(String type) {
        this.type = type;
    }
    
    @Override
    public void start() {
        System.out.println("Started pedaling the " + type + " bicycle");
    }
    
    @Override
    public void stop() {
        System.out.println("Stopped pedaling the " + type + " bicycle");
    }
    
    @Override
    public double getMaxSpeed() {
        return 40.0;
    }
    
    // Use default honk() method - bicycles don't typically honk
}</code></pre>
                </div>

                <h4>Interface Usage Example:</h4>
                <div class="code-block">
                  <pre><code>public class InterfaceDemo {
    
    public static void main(String[] args) {
        // Interface polymorphism
        Drawable[] drawables = {
            new Circle(5.0, 10, 20, "Red"),
            new Rectangle(8.0, 6.0, 30, 40, "Blue"),
            new Circle(3.0, 50, 60, "Green")
        };
        
        System.out.println("=== Drawing Shapes ===");
        for (Drawable drawable : drawables) {
            drawable.draw();
            drawable.resize(1.5);
            drawable.move(100, 100);
            System.out.println("---");
        }
        
        // Multiple interface usage
        Duck duck = new Duck("Donald");
        System.out.println("\n=== Duck Abilities ===");
        
        // Use as different interface types
        Flyable flyingDuck = duck;
        Swimmable swimmingDuck = duck;
        Walkable walkingDuck = duck;
        
        flyingDuck.fly();
        duck.displayStatus();
        
        swimmingDuck.swim();
        duck.displayStatus();
        
        walkingDuck.walk();
        duck.displayStatus();
        
        // Interface with default methods
        System.out.println("\n=== Vehicle Interface ===");
        Vehicle car = new Car("Toyota");
        Vehicle bike = new Bicycle("Mountain");
        
        car.start();
        car.honk();           // Overridden method
        car.displayInfo();    // Default method
        
        bike.start();
        bike.honk();          // Default method
        bike.displayInfo();   // Default method
        
        // Static method usage
        System.out.println("Is 250 km/h valid speed? " + Vehicle.isValidSpeed(250));
        Vehicle.compareVehicles(car, bike);
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="constructors" class="section">
              <h2>üèóÔ∏è Constructors</h2>

              <div class="subsection">
                <h3>What are Constructors?</h3>
                <p>
                  <strong>Definition:</strong> Special methods used to
                  initialize objects when they are created. They have the same
                  name as the class and no return type.
                </p>

                <h4>Types of Constructors:</h4>
                <div class="code-block">
                  <pre><code>public class Student {
    private String name;
    private int age;
    private String studentId;
    private double gpa;
    
    // 1. Default Constructor (no parameters)
    public Student() {
        this.name = "Unknown";
        this.age = 18;
        this.studentId = "STU000";
        this.gpa = 0.0;
        System.out.println("Default constructor called");
    }
    
    // 2. Parameterized Constructor
    public Student(String name, int age, String studentId) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
        this.gpa = 0.0;
        System.out.println("Parameterized constructor called");
    }
    
    // 3. Constructor with all parameters
    public Student(String name, int age, String studentId, double gpa) {
        this.name = name;
        this.age = age;
        this.studentId = studentId;
        this.gpa = gpa;
        System.out.println("Full constructor called");
    }
    
    // 4. Constructor chaining using this()
    public Student(String name, String studentId) {
        this(name, 18, studentId); // Calls 3-parameter constructor
        System.out.println("Constructor chaining used");
    }
    
    // Copy Constructor
    public Student(Student other) {
        this.name = other.name;
        this.age = other.age;
        this.studentId = other.studentId + "_COPY";
        this.gpa = other.gpa;
        System.out.println("Copy constructor called");
    }
    
    @Override
    public String toString() {
        return String.format("Student{name='%s', age=%d, id='%s', gpa=%.2f}",
                           name, age, studentId, gpa);
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="static-members" class="section">
              <h2>‚ö° Static Members</h2>

              <div class="subsection">
                <h3>What are Static Members?</h3>
                <p>
                  <strong>Definition:</strong> Static members belong to the
                  class rather than any specific instance. They are shared among
                  all objects of the class.
                </p>

                <div class="code-block">
                  <pre><code>public class Counter {
    // Static variable - shared among all instances
    private static int totalCount = 0;
    private static final String CLASS_NAME = "Counter";
    
    // Instance variable - unique to each object
    private int instanceCount;
    private String name;
    
    // Static block - executed when class is first loaded
    static {
        System.out.println("Counter class loaded. Initializing...");
        totalCount = 0;
    }
    
    public Counter(String name) {
        this.name = name;
        this.instanceCount = 0;
        totalCount++;
        System.out.println("Counter '" + name + "' created. Total: " + totalCount);
    }
    
    public void increment() {
        instanceCount++;
        totalCount++;
        System.out.println(name + " - Instance: " + instanceCount + ", Total: " + totalCount);
    }
    
    // Static method - can only access static members directly
    public static int getTotalCount() {
        return totalCount;
    }
    
    public static void printClassInfo() {
        System.out.println("Class: " + CLASS_NAME + ", Total instances: " + totalCount);
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="design-patterns" class="section">
              <h2>üéØ Design Patterns</h2>

              <div class="subsection">
                <h3>Common OOP Design Patterns</h3>

                <h4>1. Singleton Pattern:</h4>
                <div class="code-block">
                  <pre><code>public class DatabaseConnection {
    private static DatabaseConnection instance;
    private String connectionString;
    
    private DatabaseConnection() {
        connectionString = "jdbc:mysql://localhost:3306/mydb";
    }
    
    public static synchronized DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}</code></pre>
                </div>

                <h4>2. Factory Pattern:</h4>
                <div class="code-block">
                  <pre><code>abstract class Vehicle {
    public abstract void start();
}

class Car extends Vehicle {
    public void start() { System.out.println("Car started"); }
}

class VehicleFactory {
    public static Vehicle createVehicle(String type) {
        if ("car".equals(type)) return new Car();
        throw new IllegalArgumentException("Unknown type");
    }
}</code></pre>
                </div>
              </div>
            </section>

            <section id="best-practices" class="section">
              <h2>‚úÖ Best Practices</h2>

              <div class="subsection">
                <h3>OOP Best Practices</h3>

                <h4>1. SOLID Principles:</h4>
                <ul>
                  <li>
                    <strong>S - Single Responsibility:</strong> One class, one
                    responsibility
                  </li>
                  <li>
                    <strong>O - Open/Closed:</strong> Open for extension, closed
                    for modification
                  </li>
                  <li>
                    <strong>L - Liskov Substitution:</strong> Subtypes must be
                    substitutable
                  </li>
                  <li>
                    <strong>I - Interface Segregation:</strong> Many specific
                    interfaces
                  </li>
                  <li>
                    <strong>D - Dependency Inversion:</strong> Depend on
                    abstractions
                  </li>
                </ul>

                <h4>2. Favor Composition over Inheritance</h4>
                <div class="code-block">
                  <pre><code>// Good: Composition
class Car {
    private Engine engine; // HAS-A relationship
    
    public Car() {
        this.engine = new Engine();
    }
}

// Use inheritance only for IS-A relationships
class SportsCar extends Car { // IS-A Car
}</code></pre>
                </div>
              </div>
            </section>

            <section id="interview" class="section">
              <h2>üíº Interview Questions</h2>

              <div class="subsection">
                <h3>Frequently Asked OOP Questions</h3>

                <div class="question-block">
                  <h4>Q1: What are the four pillars of OOP?</h4>
                  <p><strong>Answer:</strong></p>
                  <ul>
                    <li>
                      <strong>Encapsulation:</strong> Bundling data and methods,
                      controlling access
                    </li>
                    <li>
                      <strong>Inheritance:</strong> Creating new classes from
                      existing ones
                    </li>
                    <li>
                      <strong>Polymorphism:</strong> Same interface, different
                      implementations
                    </li>
                    <li>
                      <strong>Abstraction:</strong> Hiding implementation
                      details, showing essential features
                    </li>
                  </ul>
                </div>

                <div class="question-block">
                  <h4>Q2: Difference between abstract class and interface?</h4>
                  <p><strong>Answer:</strong></p>
                  <ul>
                    <li>
                      <strong>Abstract Class:</strong> Can have concrete
                      methods, constructors, instance variables
                    </li>
                    <li>
                      <strong>Interface:</strong> Only abstract methods
                      (default/static in Java 8+), constants only
                    </li>
                    <li>
                      <strong>Inheritance:</strong> Class extends one abstract
                      class, implements multiple interfaces
                    </li>
                    <li>
                      <strong>Access:</strong> Abstract class supports all
                      modifiers, interface methods are public
                    </li>
                  </ul>
                </div>

                <div class="question-block">
                  <h4>Q3: What is method overriding vs overloading?</h4>
                  <p><strong>Answer:</strong></p>
                  <ul>
                    <li>
                      <strong>Overriding:</strong> Same method signature in
                      subclass, runtime polymorphism
                    </li>
                    <li>
                      <strong>Overloading:</strong> Same method name, different
                      parameters, compile-time polymorphism
                    </li>
                    <li>
                      <strong>Binding:</strong> Overriding uses dynamic binding,
                      overloading uses static binding
                    </li>
                  </ul>
                </div>

                <div class="question-block">
                  <h4>Q4: Can we override static methods?</h4>
                  <p>
                    <strong>Answer:</strong> No, static methods cannot be
                    overridden. They can be hidden by defining a static method
                    with the same signature in subclass, but it's method hiding,
                    not overriding.
                  </p>
                </div>

                <div class="question-block">
                  <h4>
                    Q5: What is the difference between composition and
                    inheritance?
                  </h4>
                  <p><strong>Answer:</strong></p>
                  <ul>
                    <li>
                      <strong>Inheritance:</strong> "is-a" relationship, extends
                      class functionality
                    </li>
                    <li>
                      <strong>Composition:</strong> "has-a" relationship,
                      contains other objects
                    </li>
                    <li>
                      <strong>Flexibility:</strong> Composition is more
                      flexible, inheritance is tighter coupling
                    </li>
                    <li>
                      <strong>Design:</strong> Favor composition over
                      inheritance for better design
                    </li>
                  </ul>
                </div>

                <h3>Coding Questions</h3>

                <div class="question-block">
                  <h4>Q6: Design a Shape hierarchy with polymorphism</h4>
                  <div class="code-block">
                    <pre><code>// Already covered in the polymorphism section above
// Key points: Abstract base class, concrete implementations,
// polymorphic method calls, instanceof checking</code></pre>
                  </div>
                </div>

                <div class="question-block">
                  <h4>
                    Q7: Implement a simple banking system using OOP principles
                  </h4>
                  <div class="code-block">
                    <pre><code>// Already covered in encapsulation section
// Key points: Private fields, public methods with validation,
// proper constructor, business logic encapsulation</code></pre>
                  </div>
                </div>
              </div>
            </section>
          </div>
        </div>
      </div>
    </div>

    <script src="../footer.js"></script>
  </body>
</html>
