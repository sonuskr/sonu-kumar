<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Java 8 Features - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-java">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Java 8 Features</h1>
                <p>Modern Java Programming with Lambda, Streams & More</p>
            </div>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'java-8';</script>
    <script src="../menu.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            updateActiveNav();
        });
        
        // Active navigation highlighting
        function updateActiveNav() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.toc-nav a');
            
            let currentSection = '';
            sections.forEach(section => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= 100) {
                    currentSection = section.id;
                }
            });
            
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateActiveNav);
        updateActiveNav();
    </script>
    
    <script>
        // Syntax highlighting for Java code
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                highlightJava(block);
            });
        });
        
        function highlightJava(element) {
            let code = element.textContent;
            
            // Java keywords
            code = code.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|abstract|synchronized|volatile|transient|native|strictfp|enum|assert)\b/g, '<span class="keyword">$1</span>');
            
            // Strings
            code = code.replace(/"([^"]*)"/g, '<span class="string">"$1"</span>');
            code = code.replace(/'([^']*)'/g, '<span class="string">\'$1\'</span>');
            
            // Comments
            code = code.replace(/\/\/.*$/gm, '<span class="comment">$&</span>');
            code = code.replace(/\/\*[\s\S]*?\*\//g, '<span class="comment">$&</span>');
            
            // Numbers
            code = code.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span class="number">$&</span>');
            
            // Method calls
            code = code.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span class="method">$1</span>(');
            
            // Class names (capitalized words)
            code = code.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span class="class">$&</span>');
            
            element.innerHTML = code;
        }
    </script>
    
    <div class="container">
        <div class="content-with-sidebar">
            <aside class="sidebar-toc">
                <div class="toc-header">
                    <h2>üìö Java 8 Topics</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#lambda-expressions">Lambda Expressions</a></li>
                        <li><a href="#functional-interfaces">Functional Interfaces</a></li>
                        <li><a href="#stream-api">Stream API</a></li>
                        <li><a href="#optional">Optional Class</a></li>
                        <li><a href="#method-references">Method References</a></li>
                        <li><a href="#default-methods">Default Methods</a></li>
                        <li><a href="#date-time-api">Date Time API</a></li>
                        <li><a href="#collectors">Collectors</a></li>
                        <li><a href="#parallel-streams">Parallel Streams</a></li>
                        <li><a href="#best-practices">Best Practices</a></li>
                    </ul>
                </nav>
            </aside>

            <div class="main-content">
            <div class="topic">

                <section id="lambda-expressions" class="section">
                    <h2>üöÄ Lambda Expressions</h2>
                    
                    <div class="subsection">
                        <h3>What are Lambda Expressions?</h3>
                        <p>Lambda expressions are anonymous functions that provide a concise way to represent functional interfaces. They enable functional programming in Java.</p>
                        
                        <h4>Syntax:</h4>
                        <pre><code>(parameters) -> expression
(parameters) -> { statements; }</code></pre>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;
import java.util.function.*;

public class LambdaBasics {
    public static void main(String[] args) {
        // Traditional anonymous class
        Runnable oldWay = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello from old way!");
            }
        };
        
        // Lambda expression
        Runnable newWay = () -> System.out.println("Hello from lambda!");
        
        // Lambda with parameters
        Comparator<String> oldComparator = new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return a.compareTo(b);
            }
        };
        
        Comparator<String> newComparator = (a, b) -> a.compareTo(b);
        
        // Lambda with multiple statements
        Function<String, String> processor = (input) -> {
            String trimmed = input.trim();
            String upperCase = trimmed.toUpperCase();
            return "Processed: " + upperCase;
        };
        
        // Using lambdas with collections
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // Sorting with lambda
        names.sort((a, b) -> a.length() - b.length());
        
        // Filtering with lambda
        names.stream()
             .filter(name -> name.startsWith("A"))
             .forEach(System.out::println);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="functional-interfaces" class="section">
                    <h2>üéØ Functional Interfaces</h2>
                    
                    <div class="subsection">
                        <h3>What is a Functional Interface?</h3>
                        <p><strong>Definition:</strong> A functional interface is an interface that contains exactly one abstract method. It can have multiple default and static methods, but only one abstract method.</p>
                        
                        <p><strong>Key Points:</strong></p>
                        <ul>
                            <li>Annotated with @FunctionalInterface (optional but recommended)</li>
                            <li>Can be implemented using lambda expressions</li>
                            <li>Foundation of functional programming in Java</li>
                            <li>Enables method references and lambda expressions</li>
                        </ul>
                        
                        <h3>Built-in Functional Interfaces</h3>
                        <p>Java 8 provides several built-in functional interfaces in java.util.function package. Each serves a specific purpose:</p>
                        
                        <h4>Core Functional Interfaces:</h4>
                        <ul>
                            <li><strong>Predicate&lt;T&gt;</strong> - Tests a condition, returns boolean</li>
                            <li><strong>Function&lt;T,R&gt;</strong> - Transforms input T to output R</li>
                            <li><strong>Consumer&lt;T&gt;</strong> - Accepts input T, returns nothing</li>
                            <li><strong>Supplier&lt;T&gt;</strong> - Provides output T, takes no input</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.function.*;
import java.util.*;

public class FunctionalInterfacesDemo {
    public static void main(String[] args) {
        // Predicate<T> - takes T, returns boolean
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<Integer> isEven = num -> num % 2 == 0;
        
        // Function<T, R> - takes T, returns R
        Function<String, Integer> stringLength = String::length;
        Function<String, String> toUpperCase = String::toUpperCase;
        
        // Consumer<T> - takes T, returns void
        Consumer<String> printer = System.out::println;
        
        // Supplier<T> - takes nothing, returns T
        Supplier<String> randomUUID = () -> UUID.randomUUID().toString();
        
        // BiFunction<T, U, R> - takes T and U, returns R
        BiFunction<String, String, String> concat = (a, b) -> a + b;
        
        // UnaryOperator<T> - takes T, returns T
        UnaryOperator<String> addPrefix = str -> "PREFIX_" + str;
        
        // BinaryOperator<T> - takes two T, returns T
        BinaryOperator<Integer> max = Integer::max;
        
        // Using the functional interfaces
        System.out.println("isEmpty test: " + isEmpty.test(""));
        System.out.println("isEven test: " + isEven.test(4));
        System.out.println("String length: " + stringLength.apply("Hello"));
        printer.accept("Hello from Consumer!");
        System.out.println("Random UUID: " + randomUUID.get());
        System.out.println("Max: " + max.apply(10, 20));
    }
}</code></pre>
                        </div>
                        
                        <h3>Custom Functional Interfaces</h3>
                        <div class="code-block">
                            <pre><code>@FunctionalInterface
interface Calculator {
    double calculate(double a, double b);
    
    // Default method allowed
    default double calculateAndRound(double a, double b) {
        return Math.round(calculate(a, b));
    }
    
    // Static method allowed
    static Calculator getAddition() {
        return (a, b) -> a + b;
    }
}

public class CustomFunctionalInterface {
    public static void main(String[] args) {
        Calculator addition = (a, b) -> a + b;
        Calculator multiplication = (a, b) -> a * b;
        
        System.out.println("Addition: " + addition.calculate(10, 5));
        System.out.println("Multiplication: " + multiplication.calculate(10, 5));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="stream-api" class="section">
                    <h2>üåä Stream API</h2>
                    
                    <div class="subsection">
                        <h3>What is Stream API?</h3>
                        <p><strong>Definition:</strong> Stream API is a powerful feature that allows functional-style operations on collections of objects. It provides a declarative way to process data.</p>
                        
                        <p><strong>Stream vs Collection:</strong></p>
                        <ul>
                            <li><strong>Collection:</strong> Data structure that stores elements</li>
                            <li><strong>Stream:</strong> Sequence of elements that supports aggregate operations</li>
                        </ul>
                        
                        <h4>Key Characteristics:</h4>
                        <ul>
                            <li><strong>No storage</strong> - streams don't store elements, they flow through a pipeline</li>
                            <li><strong>Functional in nature</strong> - operations produce results without modifying source</li>
                            <li><strong>Lazy evaluation</strong> - intermediate operations are not executed until terminal operation</li>
                            <li><strong>Possibly unbounded</strong> - streams can be infinite (unlike collections)</li>
                            <li><strong>Consumable</strong> - elements are visited only once during the life of a stream</li>
                        </ul>
                        
                        <h4>Stream Pipeline:</h4>
                        <p>A stream pipeline consists of:</p>
                        <ul>
                            <li><strong>Source:</strong> Collection, array, generator function</li>
                            <li><strong>Intermediate operations:</strong> filter, map, sorted (return Stream)</li>
                            <li><strong>Terminal operation:</strong> collect, forEach, reduce (triggers execution)</li>
                        </ul>
                        
                        <h3>‚≠ê Complete Stream Tutorial - Beginner to Advanced</h3>
                        
                        <h4>üî• How to Create Streams</h4>
                        <div class="code-block">
                            <pre><code>// 1. From a List
List<String> list = List.of("A", "B", "C");
list.stream();

// 2. From individual values
Stream.of("A", "B", "C");

// 3. From Arrays
Arrays.stream(new int[]{1, 2, 3});

// 4. From IntStream / LongStream
IntStream.range(1, 5); // 1,2,3,4
IntStream.rangeClosed(1, 5); // 1,2,3,4,5</code></pre>
                        </div>
                        
                        <h4>üéØ Core Stream Operations</h4>
                        
                        <h5>1Ô∏è‚É£ filter() - Keep only matching values</h5>
                        <div class="code-block">
                            <pre><code>List<Integer> nums = List.of(10, 15, 20, 25);

nums.stream()
    .filter(n -> n > 15)
    .forEach(System.out::println);
// Output: 20, 25</code></pre>
                        </div>
                        
                        <h5>2Ô∏è‚É£ map() - Transform values</h5>
                        <div class="code-block">
                            <pre><code>List<String> names = List.of("java", "spring");

names.stream()
     .map(String::toUpperCase)
     .forEach(System.out::println);
// Output: JAVA, SPRING</code></pre>
                        </div>
                        
                        <h5>3Ô∏è‚É£ collect() - Convert Stream back to List</h5>
                        <div class="code-block">
                            <pre><code>List<Integer> even = nums.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());</code></pre>
                        </div>
                        
                        <h4>üöÄ Advanced Operations</h4>
                        
                        <h5>1Ô∏è‚É£ flatMap() - Flatten nested lists</h5>
                        <div class="code-block">
                            <pre><code>List<List<Integer>> data = List.of(
    List.of(1,2),
    List.of(3,4)
);

data.stream()
    .flatMap(List::stream)
    .forEach(System.out::println);
// Output: 1, 2, 3, 4</code></pre>
                        </div>
                        
                        <h5>2Ô∏è‚É£ reduce() - Combine values</h5>
                        <div class="code-block">
                            <pre><code>int sum = List.of(1,2,3).stream()
    .reduce(0, (a,b) -> a + b);
// Result: 6</code></pre>
                        </div>
                        
                        <h4>üî• Real-World Pipeline Example</h4>
                        <div class="code-block">
                            <pre><code>// Input: Mixed case names with empty strings
List<String> names = List.of("ram", "", "SHYAM", "rahul", "");

// Process: remove empty ‚Üí uppercase ‚Üí sort ‚Üí collect
List<String> result = names.stream()
    .filter(s -> !s.isEmpty())     // Remove empty strings
    .map(String::toUpperCase)      // Convert to uppercase
    .sorted()                      // Sort alphabetically
    .collect(Collectors.toList()); // Collect to list

System.out.println(result);
// Output: [RAHUL, RAM, SHYAM]</code></pre>
                        </div>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;
import java.util.stream.*;

public class StreamBasics {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Filter - intermediate operation
        List<String> longNames = names.stream()
            .filter(name -> name.length() > 3)
            .collect(Collectors.toList());
        
        // Map - transform elements
        List<Integer> nameLengths = names.stream()
            .map(String::length)
            .collect(Collectors.toList());
        
        // FlatMap - flatten nested structures
        List<List<String>> nestedList = Arrays.asList(
            Arrays.asList("a", "b"),
            Arrays.asList("c", "d")
        );
        
        List<String> flattened = nestedList.stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
        
        // Reduce operations
        Optional<Integer> sum = numbers.stream()
            .reduce((a, b) -> a + b);
        
        // Find operations
        Optional<String> first = names.stream()
            .filter(name -> name.startsWith("C"))
            .findFirst();
        
        // Sorting
        List<String> sorted = names.stream()
            .sorted(Comparator.comparing(String::length))
            .collect(Collectors.toList());
        
        System.out.println("Long names: " + longNames);
        System.out.println("Name lengths: " + nameLengths);
        System.out.println("Flattened: " + flattened);
        System.out.println("Sum: " + sum.orElse(0));
        System.out.println("First C name: " + first.orElse("None"));
        System.out.println("Sorted by length: " + sorted);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="optional" class="section">
                    <h2>üéÅ Optional Class</h2>
                    
                    <div class="subsection">
                        <h3>What is Optional?</h3>
                        <p><strong>Definition:</strong> Optional is a container object that may or may not contain a non-null value. It's designed to handle the absence of values without using null references.</p>
                        
                        <h4>Why Optional?</h4>
                        <ul>
                            <li><strong>Null Safety:</strong> Eliminates NullPointerException at compile time</li>
                            <li><strong>Explicit Intent:</strong> Makes it clear when a method might return no value</li>
                            <li><strong>Functional Style:</strong> Supports functional programming patterns</li>
                            <li><strong>Better API Design:</strong> Forces developers to handle absence of values</li>
                        </ul>
                        
                        <h4>When to Use Optional:</h4>
                        <ul>
                            <li>Method return types that might not have a value</li>
                            <li>Avoiding null checks in method chains</li>
                            <li>Representing optional parameters in a clean way</li>
                        </ul>
                        
                        <h4>When NOT to Use Optional:</h4>
                        <ul>
                            <li>As method parameters (use overloading instead)</li>
                            <li>As field types in classes</li>
                            <li>In collections (use empty collections instead)</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;

public class OptionalDemo {
    public static void main(String[] args) {
        // Creating Optional
        Optional<String> empty = Optional.empty();
        Optional<String> nonEmpty = Optional.of("Hello");
        Optional<String> nullable = Optional.ofNullable(null);
        
        // Checking if value is present
        System.out.println("Empty present: " + empty.isPresent());
        System.out.println("NonEmpty present: " + nonEmpty.isPresent());
        
        // Getting values safely
        String value1 = nonEmpty.orElse("Default");
        String value2 = empty.orElse("Default");
        String value3 = empty.orElseGet(() -> "Generated Default");
        
        // Conditional execution
        nonEmpty.ifPresent(System.out::println);
        
        // Transforming Optional values
        Optional<Integer> length = nonEmpty.map(String::length);
        Optional<String> upperCase = nonEmpty.map(String::toUpperCase);
        
        // Filtering Optional values
        Optional<String> filtered = nonEmpty.filter(s -> s.length() > 3);
        
        System.out.println("Value1: " + value1);
        System.out.println("Value2: " + value2);
        System.out.println("Length: " + length.orElse(0));
        System.out.println("UpperCase: " + upperCase.orElse(""));
        System.out.println("Filtered: " + filtered.orElse("Not found"));
    }
    
    // Method returning Optional
    public static Optional<String> findUserById(int id) {
        Map<Integer, String> users = Map.of(1, "Alice", 2, "Bob");
        return Optional.ofNullable(users.get(id));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="method-references" class="section">
                    <h2>üîó Method References</h2>
                    
                    <div class="subsection">
                        <h3>What are Method References?</h3>
                        <p><strong>Definition:</strong> Method references are a shorthand notation for lambda expressions that call a single method. They make code more readable and concise.</p>
                        
                        <h4>When to Use Method References:</h4>
                        <ul>
                            <li>When lambda expression only calls an existing method</li>
                            <li>To improve code readability</li>
                            <li>To avoid code duplication</li>
                        </ul>
                        
                        <h4>Types of Method References:</h4>
                        <ol>
                            <li><strong>Static Method Reference:</strong> ClassName::staticMethod</li>
                            <li><strong>Instance Method Reference (Bound):</strong> instance::instanceMethod</li>
                            <li><strong>Instance Method Reference (Unbound):</strong> ClassName::instanceMethod</li>
                            <li><strong>Constructor Reference:</strong> ClassName::new</li>
                        </ol>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;
import java.util.function.*;

public class MethodReferencesDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // 1. Static method reference
        // Lambda: (a, b) -> Integer.compare(a, b)
        Comparator<Integer> intComparator = Integer::compare;
        
        // 2. Instance method reference of arbitrary object
        // Lambda: s -> s.length()
        Function<String, Integer> lengthFunction = String::length;
        
        // Lambda: s -> s.toUpperCase()
        Function<String, String> upperCaseFunction = String::toUpperCase;
        
        // 3. Instance method reference of particular object
        String prefix = "Hello ";
        // Lambda: s -> prefix.concat(s)
        Function<String, String> greeter = prefix::concat;
        
        // 4. Constructor reference
        // Lambda: () -> new ArrayList<>()
        Supplier<List<String>> listSupplier = ArrayList::new;
        
        // Using method references
        names.forEach(System.out::println);  // Method reference
        
        List<String> processed = names.stream()
            .map(String::toUpperCase)
            .sorted(String::compareTo)
            .collect(Collectors.toList());
        
        System.out.println("Processed: " + processed);
        
        // Constructor reference example
        List<String> newList = listSupplier.get();
        newList.addAll(names);
        System.out.println("New list: " + newList);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="default-methods" class="section">
                    <h2>üîß Default Methods</h2>
                    
                    <div class="subsection">
                        <h3>What are Default Methods?</h3>
                        <p><strong>Definition:</strong> Default methods are methods in interfaces that have a default implementation. They were introduced in Java 8 to enable interface evolution.</p>
                        
                        <h4>Why Default Methods?</h4>
                        <ul>
                            <li><strong>Backward Compatibility:</strong> Add new methods without breaking existing implementations</li>
                            <li><strong>Interface Evolution:</strong> Enhance interfaces over time</li>
                            <li><strong>Multiple Inheritance:</strong> Provide behavior inheritance in interfaces</li>
                            <li><strong>Library Enhancement:</strong> Add new functionality to existing APIs</li>
                        </ul>
                        
                        <h4>Rules for Default Methods:</h4>
                        <ul>
                            <li>Must be declared with 'default' keyword</li>
                            <li>Must have a body (implementation)</li>
                            <li>Can be overridden in implementing classes</li>
                            <li>Cannot be final, synchronized, or native</li>
                        </ul>
                        
                        <h4>Conflict Resolution:</h4>
                        <p>When multiple interfaces have same default method:</p>
                        <ol>
                            <li>Class methods win over interface default methods</li>
                            <li>More specific interface wins</li>
                            <li>Explicit override required if ambiguous</li>
                        </ol>
                        
                        <div class="code-block">
                            <pre><code>interface Vehicle {
    // Abstract method
    void start();
    
    // Default method
    default void stop() {
        System.out.println("Vehicle stopped");
    }
    
    default void honk() {
        System.out.println("Beep beep!");
    }
    
    // Static method
    static void checkLicense() {
        System.out.println("License checked");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car engine started");
    }
    
    // Can override default method
    @Override
    public void honk() {
        System.out.println("Car horn: Honk honk!");
    }
}

public class DefaultMethodsDemo {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();
        car.stop();  // Uses default implementation
        car.honk();  // Uses overridden implementation
        
        Vehicle.checkLicense();  // Static method call
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="date-time-api" class="section">
                    <h2>üìÖ Date Time API</h2>
                    
                    <div class="subsection">
                        <h3>Why New Date Time API?</h3>
                        <p><strong>Problems with Old API (Date/Calendar):</strong></p>
                        <ul>
                            <li><strong>Mutable:</strong> Date objects could be modified after creation</li>
                            <li><strong>Thread-unsafe:</strong> Not safe for concurrent access</li>
                            <li><strong>Poor API design:</strong> Confusing methods and 0-based months</li>
                            <li><strong>Limited functionality:</strong> Basic operations were complex</li>
                        </ul>
                        
                        <h3>New Date Time API Benefits</h3>
                        <ul>
                            <li><strong>Immutable:</strong> Objects cannot be modified after creation</li>
                            <li><strong>Thread-safe:</strong> Safe for concurrent use</li>
                            <li><strong>Fluent API:</strong> Method chaining for better readability</li>
                            <li><strong>Comprehensive:</strong> Covers all date/time use cases</li>
                            <li><strong>ISO-8601 compliant:</strong> Follows international standards</li>
                        </ul>
                        
                        <h4>Core Classes:</h4>
                        <ul>
                            <li><strong>LocalDate:</strong> Date without time (2024-12-25)</li>
                            <li><strong>LocalTime:</strong> Time without date (14:30:45)</li>
                            <li><strong>LocalDateTime:</strong> Date and time without timezone</li>
                            <li><strong>ZonedDateTime:</strong> Date and time with timezone</li>
                            <li><strong>Instant:</strong> Machine timestamp (epoch seconds)</li>
                            <li><strong>Period:</strong> Date-based amount (years, months, days)</li>
                            <li><strong>Duration:</strong> Time-based amount (hours, minutes, seconds)</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeDemo {
    public static void main(String[] args) {
        // Current date and time
        LocalDate today = LocalDate.now();
        LocalTime now = LocalTime.now();
        LocalDateTime dateTime = LocalDateTime.now();
        
        // Creating specific dates
        LocalDate specificDate = LocalDate.of(2024, 12, 25);
        LocalTime specificTime = LocalTime.of(14, 30, 45);
        
        // Parsing from strings
        LocalDate parsedDate = LocalDate.parse("2024-12-25");
        LocalTime parsedTime = LocalTime.parse("14:30:45");
        
        // Date arithmetic
        LocalDate tomorrow = today.plusDays(1);
        LocalDate nextWeek = today.plusWeeks(1);
        LocalDate yesterday = today.minusDays(1);
        
        // Formatting
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        String formattedDate = today.format(formatter);
        
        // Working with time zones
        ZonedDateTime zonedDateTime = ZonedDateTime.now();
        ZonedDateTime utcTime = ZonedDateTime.now(ZoneId.of("UTC"));
        ZonedDateTime tokyoTime = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        
        // Converting between zones
        ZonedDateTime localToTokyo = zonedDateTime.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));
        
        // Period and Duration
        LocalDate startDate = LocalDate.of(2024, 1, 1);
        LocalDate endDate = LocalDate.of(2024, 12, 31);
        Period period = Period.between(startDate, endDate);
        
        System.out.println("Today: " + today);
        System.out.println("Now: " + now);
        System.out.println("Tomorrow: " + tomorrow);
        System.out.println("Formatted: " + formattedDate);
        System.out.println("UTC: " + utcTime);
        System.out.println("Tokyo: " + tokyoTime);
        System.out.println("Period: " + period.getMonths() + " months");
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="collectors" class="section">
                    <h2>üóÇÔ∏è Collectors</h2>
                    
                    <div class="subsection">
                        <h3>What are Collectors?</h3>
                        <p><strong>Definition:</strong> Collectors are utility classes that implement reduction operations to accumulate stream elements into collections, strings, or other summary results.</p>
                        
                        <h4>Why Collectors?</h4>
                        <ul>
                            <li><strong>Reusable:</strong> Common reduction operations are pre-built</li>
                            <li><strong>Efficient:</strong> Optimized for performance</li>
                            <li><strong>Composable:</strong> Can be combined for complex operations</li>
                            <li><strong>Parallel-friendly:</strong> Work efficiently with parallel streams</li>
                        </ul>
                        
                        <h4>Types of Collectors:</h4>
                        <ul>
                            <li><strong>Collection Collectors:</strong> toList(), toSet(), toMap()</li>
                            <li><strong>String Collectors:</strong> joining()</li>
                            <li><strong>Grouping Collectors:</strong> groupingBy(), partitioningBy()</li>
                            <li><strong>Statistical Collectors:</strong> counting(), averaging(), summarizing()</li>
                            <li><strong>Reduction Collectors:</strong> reducing(), minBy(), maxBy()</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;
import java.util.stream.*;

class Employee {
    private String name;
    private String department;
    private double salary;
    
    public Employee(String name, String department, double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
    
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
    
    @Override
    public String toString() {
        return name + "(" + department + ", $" + salary + ")";
    }
}

public class CollectorsDemo {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", "IT", 75000),
            new Employee("Bob", "HR", 65000),
            new Employee("Charlie", "IT", 80000),
            new Employee("David", "Finance", 70000),
            new Employee("Eve", "IT", 85000)
        );
        
        // Basic collectors
        List<String> names = employees.stream()
            .map(Employee::getName)
            .collect(Collectors.toList());
        
        Set<String> departments = employees.stream()
            .map(Employee::getDepartment)
            .collect(Collectors.toSet());
        
        // Joining
        String allNames = employees.stream()
            .map(Employee::getName)
            .collect(Collectors.joining(", "));
        
        // Grouping by department
        Map<String, List<Employee>> byDepartment = employees.stream()
            .collect(Collectors.groupingBy(Employee::getDepartment));
        
        // Counting by department
        Map<String, Long> countByDepartment = employees.stream()
            .collect(Collectors.groupingBy(
                Employee::getDepartment,
                Collectors.counting()
            ));
        
        // Average salary by department
        Map<String, Double> avgSalaryByDepartment = employees.stream()
            .collect(Collectors.groupingBy(
                Employee::getDepartment,
                Collectors.averagingDouble(Employee::getSalary)
            ));
        
        // Partitioning by salary
        Map<Boolean, List<Employee>> partitionedBySalary = employees.stream()
            .collect(Collectors.partitioningBy(emp -> emp.getSalary() > 70000));
        
        System.out.println("Names: " + names);
        System.out.println("Departments: " + departments);
        System.out.println("All names: " + allNames);
        System.out.println("By Department: " + byDepartment);
        System.out.println("Count by Department: " + countByDepartment);
        System.out.println("Avg Salary: " + avgSalaryByDepartment);
        System.out.println("High salary: " + partitionedBySalary.get(true).size());
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="parallel-streams" class="section">
                    <h2>‚ö° Parallel Streams</h2>
                    
                    <div class="subsection">
                        <h3>What are Parallel Streams?</h3>
                        <p><strong>Definition:</strong> Parallel streams automatically divide stream elements into multiple chunks and process them concurrently using the ForkJoinPool framework.</p>
                        
                        <h4>How Parallel Streams Work:</h4>
                        <ul>
                            <li><strong>Fork-Join Framework:</strong> Uses work-stealing algorithm</li>
                            <li><strong>Automatic Splitting:</strong> Divides data into chunks</li>
                            <li><strong>Concurrent Processing:</strong> Processes chunks in parallel</li>
                            <li><strong>Result Combining:</strong> Merges results from all threads</li>
                        </ul>
                        
                        <h4>When to Use Parallel Streams:</h4>
                        <ul>
                            <li><strong>Large datasets:</strong> Thousands of elements or more</li>
                            <li><strong>CPU-intensive operations:</strong> Complex computations per element</li>
                            <li><strong>Independent operations:</strong> No shared mutable state</li>
                            <li><strong>Stateless operations:</strong> No dependencies between elements</li>
                        </ul>
                        
                        <h4>When NOT to Use Parallel Streams:</h4>
                        <ul>
                            <li><strong>Small datasets:</strong> Overhead exceeds benefits</li>
                            <li><strong>I/O operations:</strong> Network/file operations are not CPU-bound</li>
                            <li><strong>Stateful operations:</strong> limit(), skip(), findFirst()</li>
                            <li><strong>Shared mutable state:</strong> Race conditions possible</li>
                        </ul>
                        
                        <div class="code-block">
                            <pre><code>import java.util.*;
import java.util.stream.*;

public class ParallelStreamsDemo {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.rangeClosed(1, 1000000)
            .boxed()
            .collect(Collectors.toList());
        
        // Sequential processing
        long startTime = System.currentTimeMillis();
        long sequentialSum = numbers.stream()
            .mapToLong(Integer::longValue)
            .sum();
        long sequentialTime = System.currentTimeMillis() - startTime;
        
        // Parallel processing
        startTime = System.currentTimeMillis();
        long parallelSum = numbers.parallelStream()
            .mapToLong(Integer::longValue)
            .sum();
        long parallelTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Sequential: " + sequentialSum + " (" + sequentialTime + "ms)");
        System.out.println("Parallel: " + parallelSum + " (" + parallelTime + "ms)");
        
        // Creating parallel streams
        Stream<Integer> parallelStream1 = numbers.parallelStream();
        Stream<Integer> parallelStream2 = numbers.stream().parallel();
        
        // Check if stream is parallel
        System.out.println("Is parallel: " + parallelStream1.isParallel());
        
        // When to use parallel streams
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
        
        List<String> processed = words.parallelStream()
            .filter(word -> word.length() > 4)
            .map(String::toUpperCase)
            .sorted()
            .collect(Collectors.toList());
        
        System.out.println("Processed: " + processed);
        
        // Performance consideration - small datasets
        List<Integer> smallList = Arrays.asList(1, 2, 3, 4, 5);
        
        // For small datasets, sequential is often faster due to overhead
        int sequentialResult = smallList.stream()
            .mapToInt(Integer::intValue)
            .sum();
        
        int parallelResult = smallList.parallelStream()
            .mapToInt(Integer::intValue)
            .sum();
        
        System.out.println("Small dataset - Sequential: " + sequentialResult);
        System.out.println("Small dataset - Parallel: " + parallelResult);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="best-practices" class="section">
                    <h2>üí° Best Practices & Interview Tips</h2>
                    
                    <div class="subsection">
                        <h3>Key Interview Points</h3>
                        <ul>
                            <li><strong>Lambda Expressions:</strong> Anonymous functions that implement functional interfaces</li>
                            <li><strong>Functional Interfaces:</strong> Interfaces with exactly one abstract method (@FunctionalInterface)</li>
                            <li><strong>Stream API:</strong> Declarative way to process collections with intermediate and terminal operations</li>
                            <li><strong>Optional:</strong> Container to avoid NullPointerException and handle absence of values</li>
                            <li><strong>Method References:</strong> Shorthand for lambda expressions (::)</li>
                            <li><strong>Default Methods:</strong> Allow interface evolution without breaking existing implementations</li>
                            <li><strong>Date/Time API:</strong> Immutable, thread-safe replacement for Date and Calendar</li>
                            <li><strong>Collectors:</strong> Utility class for common reduction operations</li>
                            <li><strong>Parallel Streams:</strong> Automatic parallelization for CPU-intensive operations</li>
                        </ul>
                        
                        <h3>Performance Tips</h3>
                        <ul>
                            <li>Use primitive streams (IntStream, LongStream, DoubleStream) to avoid boxing</li>
                            <li>Parallel streams are beneficial for CPU-intensive operations on large datasets</li>
                            <li>Avoid stateful operations (limit, skip) in parallel streams</li>
                            <li>Chain operations efficiently - filter before map</li>
                            <li>Use method references when possible for better readability</li>
                        </ul>
                        
                        <h3>Common Interview Questions</h3>
                        <ol>
                            <li><strong>What is the difference between map() and flatMap()?</strong>
                                <br>map() transforms each element, flatMap() flattens nested structures</li>
                            <li><strong>Explain functional interfaces with examples</strong>
                                <br>Predicate, Function, Consumer, Supplier with their signatures</li>
                            <li><strong>How to handle exceptions in streams?</strong>
                                <br>Use filter with try-catch or Optional wrapper methods</li>
                            <li><strong>When to use parallel streams?</strong>
                                <br>Large datasets with CPU-intensive operations, avoid for I/O operations</li>
                            <li><strong>What are intermediate vs terminal operations?</strong>
                                <br>Intermediate are lazy (filter, map), terminal trigger execution (collect, forEach)</li>
                            <li><strong>What is Optional and why use it?</strong>
                                <br>Container for potentially null values, prevents NullPointerException</li>
                            <li><strong>Explain method references with examples</strong>
                                <br>Static (Class::method), Instance (object::method), Constructor (Class::new)</li>
                        </ol>
                        
                        <h3>Code Examples for Interviews</h3>
                        <div class="code-block">
                            <pre><code>// Common interview scenarios
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");

// 1. Filter and transform
List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());

// 2. Group by length
Map<Integer, List<String>> grouped = names.stream()
    .collect(Collectors.groupingBy(String::length));

// 3. Find first match
Optional<String> first = names.stream()
    .filter(name -> name.startsWith("C"))
    .findFirst();

// 4. Reduce to single value
String concatenated = names.stream()
    .reduce("", (a, b) -> a + b);

// 5. Check conditions
boolean allLong = names.stream()
    .allMatch(name -> name.length() > 2);

// 6. Convert to different collection
Set<String> nameSet = names.stream()
    .collect(Collectors.toSet());</code></pre>
                        </div>
                    </div>
                </section>

            </div>
        </div>
    </div>
    </div>

    <script src="../footer.js"></script>
</body>
</html>