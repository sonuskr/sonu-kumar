<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Java 8 Features - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
    <link rel="icon" type="image/svg+xml" href="../../favicon.svg">
</head>
<body class="page-java">
    <header>
        <div class="container">
            <div class="hero">
                <h1>Java 8 Features</h1>
                <p>Modern Java Programming</p>
            </div>
        </div>
    </header>
    <nav>
        <div class="container">
            <div class="nav-container">
                <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">
                    ‚ò∞
                </button>
                <ul class="nav-links" id="navLinks">
                    <li><a href="../tutorial-index.html">Home</a></li>
                    <li class="dropdown">
                        <a href="#" class="active">Java</a>
                        <div class="dropdown-content">
                            <a href="java-learning.html">Java Fundamentals</a>
                            <a href="java-oop.html">Java OOP</a>
                            <a href="java-exception.html">Java Exception</a>
                            <a href="java-8.html">Java 8</a>
                            <a href="java-collection.html">Java Collections</a>
                            <a href="java-interview.html">Java Interview</a>
                        </div>
                    </li>
                    <li><a href="../javascript-learning.html">JavaScript</a></li>
                    <li><a href="../typescript-learning.html">TypeScript</a></li>
                    <li><a href="../angular-learning.html">Angular</a></li>
                    <li><a href="../react-learning.html">React</a></li>
                    <li><a href="../spring/spring-boot-learning.html">Spring Boot</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
        function toggleMobileMenu() {
            const navLinks = document.getElementById('navLinks');
            navLinks.classList.toggle('active');
        }
        
        document.addEventListener('click', function(event) {
            const nav = document.querySelector('nav');
            const navLinks = document.getElementById('navLinks');
            
            if (!nav.contains(event.target)) {
                navLinks.classList.remove('active');
            }
        });
        
        // Simple syntax highlighting
        document.addEventListener('DOMContentLoaded', function() {
            const codeBlocks = document.querySelectorAll('.code-block code');
            codeBlocks.forEach(block => {
                let html = block.innerHTML;
                
                // Java keywords
                html = html.replace(/\b(public|private|protected|static|final|class|interface|extends|implements|import|package|void|int|String|boolean|double|float|long|short|byte|char|if|else|for|while|do|switch|case|default|break|continue|return|try|catch|finally|throw|throws|new|this|super|null|true|false|default)\b/g, '<span style="color: #c792ea; font-weight: bold;">$1</span>');
                
                // Strings
                html = html.replace(/"([^"]*)"/g, '<span style="color: #c3e88d;">"$1"</span>');
                html = html.replace(/'([^']*)'/g, '<span style="color: #c3e88d;">\'$1\'</span>');
                
                // Comments
                html = html.replace(/\/\/.*$/gm, '<span style="color: #546e7a; font-style: italic;">$&</span>');
                html = html.replace(/\/\*[\s\S]*?\*\//g, '<span style="color: #546e7a; font-style: italic;">$&</span>');
                
                // Numbers
                html = html.replace(/\b\d+(\.\d+)?[fLdF]?\b/g, '<span style="color: #f78c6c;">$&</span>');
                
                // Method calls
                html = html.replace(/\b([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/g, '<span style="color: #82aaff;">$1</span>(');
                
                // Class names (capitalized words)
                html = html.replace(/\b[A-Z][a-zA-Z0-9_]*\b/g, '<span style="color: #ffcb6b;">$&</span>');
                
                block.innerHTML = html;
            });
        });
    </script>
    <div class="container">
        <div class="content">
            <div class="topic">
                <h1>Java 8 Features</h1>
                
                <div class="table-of-contents">
                    <h2>üìö Table of Contents</h2>
                    <div class="toc-grid">
                        <div class="toc-column">
                            <ul>
                                <li><a href="#lambda-expressions">Lambda Expressions</a></li>
                                <li><a href="#functional-interfaces">Functional Interfaces</a></li>
                                <li><a href="#method-references">Method References</a></li>
                                <li><a href="#stream-api">Stream API</a></li>
                                <li><a href="#optional">Optional Class</a></li>
                            </ul>
                        </div>
                        <div class="toc-column">
                            <ul>
                                <li><a href="#default-methods">Default Methods</a></li>
                                <li><a href="#static-methods">Static Methods in Interfaces</a></li>
                                <li><a href="#date-time-api">Date & Time API</a></li>
                                <li><a href="#collectors">Collectors</a></li>
                                <li><a href="#parallel-streams">Parallel Streams</a></li>
                            </ul>
                        </div>
                        <div class="toc-column">
                            <ul>
                                <li><a href="#nashorn">Nashorn JavaScript Engine</a></li>
                                <li><a href="#base64">Base64 Encoding</a></li>
                                <li><a href="#annotations">Repeating Annotations</a></li>
                                <li><a href="#best-practices">Best Practices</a></li>
                                <li><a href="#examples">Real Examples</a></li>
                            </ul>
                        </div>
                    </div>
                </div>

                <section id="lambda-expressions" class="section">
                    <h2>üöÄ Lambda Expressions</h2>
                    
                    <div class="subsection">
                        <h3>Lambda Syntax and Basic Usage</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.function.*;

public class LambdaBasics {
    public static void main(String[] args) {
        // Traditional anonymous class
        Runnable oldWay = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello from old way!");
            }
        };
        
        // Lambda expression
        Runnable newWay = () -> System.out.println("Hello from lambda!");
        
        // Lambda with parameters
        Comparator<String> oldComparator = new Comparator<String>() {
            @Override
            public int compare(String a, String b) {
                return a.compareTo(b);
            }
        };
        
        Comparator<String> newComparator = (a, b) -> a.compareTo(b);
        
        // Even shorter with method reference
        Comparator<String> shortest = String::compareTo;
        
        // Lambda with multiple statements
        Function<String, String> processor = (input) -> {
            String trimmed = input.trim();
            String upperCase = trimmed.toUpperCase();
            return "Processed: " + upperCase;
        };
        
        // Using lambdas with collections
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // Sorting with lambda
        names.sort((a, b) -> a.length() - b.length());
        
        // Filtering with lambda
        names.stream()
             .filter(name -> name.startsWith("A"))
             .forEach(System.out::println);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>Lambda Expression Types</h3>
                        <div class="code-block">
                            <pre><code class="language-java">public class LambdaTypes {
    public static void main(String[] args) {
        // No parameters
        Runnable noParams = () -> System.out.println("No parameters");
        
        // Single parameter (parentheses optional)
        Consumer<String> singleParam = name -> System.out.println("Hello " + name);
        Consumer<String> singleParamWithParens = (name) -> System.out.println("Hello " + name);
        
        // Multiple parameters
        BinaryOperator<Integer> multipleParams = (a, b) -> a + b;
        
        // Explicit type declaration
        BinaryOperator<Integer> explicitTypes = (Integer a, Integer b) -> a + b;
        
        // Return statement
        Function<String, Integer> withReturn = (str) -> {
            return str.length();
        };
        
        // Expression body (implicit return)
        Function<String, Integer> expressionBody = str -> str.length();
        
        // Accessing local variables (effectively final)
        String prefix = "Result: ";
        Function<Integer, String> accessLocal = num -> prefix + num;
        
        // Using lambdas
        noParams.run();
        singleParam.accept("Alice");
        System.out.println(multipleParams.apply(5, 3));
        System.out.println(withReturn.apply("Hello"));
        System.out.println(accessLocal.apply(42));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="functional-interfaces" class="section">
                    <h2>üîß Functional Interfaces</h2>
                    
                    <div class="subsection">
                        <h3>Built-in Functional Interfaces</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.function.*;
import java.util.List;
import java.util.Arrays;

public class FunctionalInterfacesDemo {
    public static void main(String[] args) {
        // Predicate<T> - takes T, returns boolean
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<Integer> isEven = num -> num % 2 == 0;
        Predicate<String> startsWithA = str -> str.startsWith("A");
        
        System.out.println(isEmpty.test(""));        // true
        System.out.println(isEven.test(4));          // true
        System.out.println(startsWithA.test("Apple")); // true
        
        // Function<T, R> - takes T, returns R
        Function<String, Integer> stringLength = String::length;
        Function<Integer, String> intToString = Object::toString;
        Function<String, String> toUpperCase = String::toUpperCase;
        
        System.out.println(stringLength.apply("Hello"));    // 5
        System.out.println(intToString.apply(42));           // "42"
        System.out.println(toUpperCase.apply("hello"));     // "HELLO"
        
        // Consumer<T> - takes T, returns void
        Consumer<String> printer = System.out::println;
        Consumer<List<String>> listPrinter = list -> list.forEach(System.out::println);
        
        printer.accept("Hello World");
        listPrinter.accept(Arrays.asList("A", "B", "C"));
        
        // Supplier<T> - takes nothing, returns T
        Supplier<String> stringSupplier = () -> "Hello from supplier";
        Supplier<Double> randomSupplier = Math::random;
        Supplier<List<String>> listSupplier = ArrayList::new;
        
        System.out.println(stringSupplier.get());
        System.out.println(randomSupplier.get());
        System.out.println(listSupplier.get());
        
        // BinaryOperator<T> - takes two T, returns T
        BinaryOperator<Integer> add = Integer::sum;
        BinaryOperator<String> concat = String::concat;
        BinaryOperator<Integer> max = Integer::max;
        
        System.out.println(add.apply(5, 3));           // 8
        System.out.println(concat.apply("Hello", " World")); // "Hello World"
        System.out.println(max.apply(10, 20));         // 20
        
        // UnaryOperator<T> - takes T, returns T
        UnaryOperator<String> toUpper = String::toUpperCase;
        UnaryOperator<Integer> square = x -> x * x;
        
        System.out.println(toUpper.apply("hello"));    // "HELLO"
        System.out.println(square.apply(5));           // 25
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>Custom Functional Interfaces</h3>
                        <div class="code-block">
                            <pre><code class="language-java">@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
    
    // Default methods are allowed
    default int multiply(int a, int b) {
        return a * b;
    }
    
    // Static methods are allowed
    static int divide(int a, int b) {
        return a / b;
    }
}

@FunctionalInterface
public interface StringProcessor {
    String process(String input);
}

@FunctionalInterface
public interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);
}

public class CustomFunctionalInterfaceDemo {
    public static void main(String[] args) {
        // Using custom functional interfaces
        Calculator add = (a, b) -> a + b;
        Calculator subtract = (a, b) -> a - b;
        Calculator multiply = Integer::sum; // This won't work - wrong operation
        Calculator actualMultiply = (a, b) -> a * b;
        
        System.out.println(add.calculate(5, 3));        // 8
        System.out.println(subtract.calculate(5, 3));   // 2
        System.out.println(actualMultiply.calculate(5, 3)); // 15
        
        // Using default method
        System.out.println(add.multiply(5, 3));         // 15
        
        // Using static method
        System.out.println(Calculator.divide(15, 3));   // 5
        
        // StringProcessor examples
        StringProcessor toUpperCase = String::toUpperCase;
        StringProcessor addPrefix = str -> "Processed: " + str;
        StringProcessor reverse = str -> new StringBuilder(str).reverse().toString();
        
        System.out.println(toUpperCase.process("hello"));
        System.out.println(addPrefix.process("data"));
        System.out.println(reverse.process("hello"));
        
        // TriFunction example
        TriFunction<String, Integer, Integer, String> substring = String::substring;
        System.out.println(substring.apply("Hello World", 0, 5)); // "Hello"
        
        TriFunction<Integer, Integer, Integer, Integer> addThree = (a, b, c) -> a + b + c;
        System.out.println(addThree.apply(1, 2, 3)); // 6
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="method-references" class="section">
                    <h2>üîó Method References</h2>
                    
                    <div class="subsection">
                        <h3>Types of Method References</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.function.*;

public class MethodReferencesDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        
        // 1. Reference to static method
        // ClassName::staticMethodName
        Function<String, Integer> parseInt1 = Integer::parseInt;
        Function<String, Integer> parseInt2 = str -> Integer.parseInt(str);
        
        System.out.println(parseInt1.apply("123")); // 123
        
        // 2. Reference to instance method of particular object
        // object::instanceMethodName
        String prefix = "Hello ";
        Function<String, String> addPrefix1 = prefix::concat;
        Function<String, String> addPrefix2 = str -> prefix.concat(str);
        
        System.out.println(addPrefix1.apply("World")); // "Hello World"
        
        // 3. Reference to instance method of arbitrary object
        // ClassName::instanceMethodName
        Function<String, String> toUpperCase1 = String::toUpperCase;
        Function<String, String> toUpperCase2 = str -> str.toUpperCase();
        
        names.stream()
             .map(String::toUpperCase)
             .forEach(System.out::println);
        
        // 4. Reference to constructor
        // ClassName::new
        Supplier<List<String>> listSupplier1 = ArrayList::new;
        Supplier<List<String>> listSupplier2 = () -> new ArrayList<>();
        
        Function<String, StringBuilder> sbCreator1 = StringBuilder::new;
        Function<String, StringBuilder> sbCreator2 = str -> new StringBuilder(str);
        
        // More examples
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // Static method reference
        numbers.stream()
               .map(String::valueOf)  // Integer.toString() -> String::valueOf
               .forEach(System.out::println);
        
        // Instance method reference
        numbers.stream()
               .map(Object::toString)  // num -> num.toString()
               .forEach(System.out::println);
        
        // Constructor reference
        numbers.stream()
               .map(StringBuilder::new)  // num -> new StringBuilder(num)
               .forEach(System.out::println);
    }
    
    // Custom class for demonstration
    static class Person {
        private String name;
        private int age;
        
        public Person(String name) {
            this.name = name;
        }
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        
        public static int compareByName(Person a, Person b) {
            return a.name.compareTo(b.name);
        }
        
        public int compareByAge(Person other) {
            return Integer.compare(this.age, other.age);
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static void demonstrateWithCustomClass() {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 20)
        );
        
        // Static method reference
        people.sort(Person::compareByName);
        
        // Instance method reference of arbitrary object
        people.stream()
              .map(Person::getName)
              .forEach(System.out::println);
        
        // Constructor reference
        Function<String, Person> personCreator = Person::new;
        Person newPerson = personCreator.apply("Eve");
        
        // BiFunction for constructor with two parameters
        BiFunction<String, Integer, Person> personCreatorWithAge = Person::new;
        Person anotherPerson = personCreatorWithAge.apply("Frank", 35);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="stream-api" class="section">
                    <h2>üåä Stream API</h2>
                    
                    <div class="subsection">
                        <h3>Stream Creation and Basic Operations</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.stream.*;

public class StreamBasics {
    public static void main(String[] args) {
        // Creating streams
        
        // From collections
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        Stream<String> streamFromList = names.stream();
        
        // From arrays
        String[] array = {"A", "B", "C"};
        Stream<String> streamFromArray = Arrays.stream(array);
        
        // From values
        Stream<String> streamFromValues = Stream.of("X", "Y", "Z");
        
        // Empty stream
        Stream<String> emptyStream = Stream.empty();
        
        // Infinite streams
        Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);
        Stream<Double> randomStream = Stream.generate(Math::random);
        
        // Range streams
        IntStream range = IntStream.range(1, 10);        // 1 to 9
        IntStream rangeClosed = IntStream.rangeClosed(1, 10); // 1 to 10
        
        // Basic operations
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Filter - intermediate operation
        List<Integer> evenNumbers = numbers.stream()
            .filter(n -> n % 2 == 0)
            .collect(Collectors.toList());
        System.out.println("Even numbers: " + evenNumbers);
        
        // Map - intermediate operation
        List<String> stringNumbers = numbers.stream()
            .map(Object::toString)
            .collect(Collectors.toList());
        System.out.println("String numbers: " + stringNumbers);
        
        // Sorted - intermediate operation
        List<String> sortedNames = names.stream()
            .sorted()
            .collect(Collectors.toList());
        System.out.println("Sorted names: " + sortedNames);
        
        // Distinct - intermediate operation
        List<Integer> duplicates = Arrays.asList(1, 2, 2, 3, 3, 3, 4);
        List<Integer> unique = duplicates.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("Unique numbers: " + unique);
        
        // Limit and Skip - intermediate operations
        List<Integer> limitedNumbers = numbers.stream()
            .skip(3)
            .limit(4)
            .collect(Collectors.toList());
        System.out.println("Limited numbers: " + limitedNumbers);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>Terminal Operations</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.stream.*;

public class StreamTerminalOperations {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date", "elderberry");
        
        // forEach - terminal operation
        System.out.println("Numbers:");
        numbers.stream()
               .filter(n -> n % 2 == 0)
               .forEach(System.out::println);
        
        // collect - terminal operation
        List<String> upperCaseWords = words.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println("Uppercase words: " + upperCaseWords);
        
        // reduce - terminal operation
        Optional<Integer> sum = numbers.stream()
            .reduce(Integer::sum);
        System.out.println("Sum: " + sum.orElse(0));
        
        int product = numbers.stream()
            .reduce(1, (a, b) -> a * b);
        System.out.println("Product: " + product);
        
        // count - terminal operation
        long evenCount = numbers.stream()
            .filter(n -> n % 2 == 0)
            .count();
        System.out.println("Even count: " + evenCount);
        
        // anyMatch, allMatch, noneMatch - terminal operations
        boolean hasEven = numbers.stream()
            .anyMatch(n -> n % 2 == 0);
        System.out.println("Has even numbers: " + hasEven);
        
        boolean allPositive = numbers.stream()
            .allMatch(n -> n > 0);
        System.out.println("All positive: " + allPositive);
        
        boolean noneNegative = numbers.stream()
            .noneMatch(n -> n < 0);
        System.out.println("None negative: " + noneNegative);
        
        // findFirst, findAny - terminal operations
        Optional<Integer> firstEven = numbers.stream()
            .filter(n -> n % 2 == 0)
            .findFirst();
        System.out.println("First even: " + firstEven.orElse(-1));
        
        Optional<String> anyLongWord = words.stream()
            .filter(word -> word.length() > 5)
            .findAny();
        System.out.println("Any long word: " + anyLongWord.orElse("none"));
        
        // min, max - terminal operations
        Optional<Integer> min = numbers.stream()
            .min(Integer::compareTo);
        System.out.println("Min: " + min.orElse(-1));
        
        Optional<String> longestWord = words.stream()
            .max(Comparator.comparing(String::length));
        System.out.println("Longest word: " + longestWord.orElse("none"));
        
        // toArray - terminal operation
        String[] wordArray = words.stream()
            .filter(word -> word.startsWith("a"))
            .toArray(String[]::new);
        System.out.println("Words starting with 'a': " + Arrays.toString(wordArray));
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>Complex Stream Operations</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.stream.*;

public class ComplexStreamOperations {
    
    static class Person {
        private String name;
        private int age;
        private String city;
        private double salary;
        
        public Person(String name, int age, String city, double salary) {
            this.name = name;
            this.age = age;
            this.city = city;
            this.salary = salary;
        }
        
        // Getters
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        public double getSalary() { return salary; }
        
        @Override
        public String toString() {
            return String.format("%s(%d, %s, %.0f)", name, age, city, salary);
        }
    }
    
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "NYC", 75000),
            new Person("Bob", 30, "LA", 80000),
            new Person("Charlie", 35, "NYC", 90000),
            new Person("David", 28, "Chicago", 70000),
            new Person("Eve", 32, "LA", 85000),
            new Person("Frank", 27, "NYC", 72000)
        );
        
        // Complex filtering and mapping
        List<String> highEarnersInNYC = people.stream()
            .filter(person -> person.getCity().equals("NYC"))
            .filter(person -> person.getSalary() > 70000)
            .map(Person::getName)
            .sorted()
            .collect(Collectors.toList());
        System.out.println("High earners in NYC: " + highEarnersInNYC);
        
        // FlatMap example
        List<List<String>> nestedList = Arrays.asList(
            Arrays.asList("a", "b"),
            Arrays.asList("c", "d", "e"),
            Arrays.asList("f")
        );
        
        List<String> flatList = nestedList.stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
        System.out.println("Flattened list: " + flatList);
        
        // Grouping
        Map<String, List<Person>> peopleByCity = people.stream()
            .collect(Collectors.groupingBy(Person::getCity));
        System.out.println("People by city: " + peopleByCity);
        
        // Partitioning
        Map<Boolean, List<Person>> partitionedByAge = people.stream()
            .collect(Collectors.partitioningBy(person -> person.getAge() > 30));
        System.out.println("Partitioned by age > 30: " + partitionedByAge);
        
        // Statistics
        DoubleSummaryStatistics salaryStats = people.stream()
            .mapToDouble(Person::getSalary)
            .summaryStatistics();
        System.out.println("Salary statistics: " + salaryStats);
        
        // Custom collector
        String namesConcatenated = people.stream()
            .map(Person::getName)
            .collect(Collectors.joining(", ", "[", "]"));
        System.out.println("Names concatenated: " + namesConcatenated);
        
        // Parallel stream
        double averageSalary = people.parallelStream()
            .mapToDouble(Person::getSalary)
            .average()
            .orElse(0.0);
        System.out.println("Average salary: " + averageSalary);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="optional" class="section">
                    <h2>üéÅ Optional Class</h2>
                    
                    <div class="subsection">
                        <h3>Optional Creation and Usage</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;

public class OptionalDemo {
    public static void main(String[] args) {
        // Creating Optional instances
        
        // Optional with value
        Optional<String> optionalWithValue = Optional.of("Hello");
        
        // Optional with null (throws exception)
        // Optional<String> optionalWithNull = Optional.of(null); // NullPointerException
        
        // Optional that may contain null
        Optional<String> optionalNullable = Optional.ofNullable(null);
        Optional<String> optionalNullable2 = Optional.ofNullable("World");
        
        // Empty optional
        Optional<String> emptyOptional = Optional.empty();
        
        // Checking if value is present
        if (optionalWithValue.isPresent()) {
            System.out.println("Value: " + optionalWithValue.get());
        }
        
        // Better way - using ifPresent
        optionalWithValue.ifPresent(value -> System.out.println("Value: " + value));
        optionalWithValue.ifPresent(System.out::println);
        
        // Getting value with default
        String value1 = optionalNullable.orElse("Default Value");
        System.out.println("Value with default: " + value1);
        
        // Getting value with supplier
        String value2 = optionalNullable.orElseGet(() -> "Generated Default");
        System.out.println("Value with supplier: " + value2);
        
        // Throwing exception if empty
        try {
            String value3 = optionalNullable.orElseThrow(() -> 
                new RuntimeException("Value not present"));
        } catch (RuntimeException e) {
            System.out.println("Exception: " + e.getMessage());
        }
        
        // Transforming Optional values
        Optional<String> upperCase = optionalWithValue.map(String::toUpperCase);
        upperCase.ifPresent(System.out::println);
        
        Optional<Integer> length = optionalWithValue.map(String::length);
        length.ifPresent(len -> System.out.println("Length: " + len));
        
        // Filtering Optional values
        Optional<String> filtered = optionalWithValue.filter(s -> s.startsWith("H"));
        filtered.ifPresent(s -> System.out.println("Filtered: " + s));
        
        // FlatMap with Optional
        Optional<String> flatMapped = optionalWithValue.flatMap(s -> 
            s.isEmpty() ? Optional.empty() : Optional.of(s.toUpperCase()));
        flatMapped.ifPresent(System.out::println);
    }
    
    // Practical example - finding user by ID
    static class User {
        private int id;
        private String name;
        private String email;
        
        public User(int id, String name, String email) {
            this.id = id;
            this.name = name;
            this.email = email;
        }
        
        public int getId() { return id; }
        public String getName() { return name; }
        public String getEmail() { return email; }
        
        @Override
        public String toString() {
            return String.format("User{id=%d, name='%s', email='%s'}", id, name, email);
        }
    }
    
    static class UserService {
        private List<User> users = Arrays.asList(
            new User(1, "Alice", "alice@example.com"),
            new User(2, "Bob", "bob@example.com"),
            new User(3, "Charlie", "charlie@example.com")
        );
        
        public Optional<User> findUserById(int id) {
            return users.stream()
                       .filter(user -> user.getId() == id)
                       .findFirst();
        }
        
        public Optional<String> getUserEmail(int id) {
            return findUserById(id).map(User::getEmail);
        }
    }
    
    public static void demonstrateOptionalWithService() {
        UserService userService = new UserService();
        
        // Finding existing user
        Optional<User> user1 = userService.findUserById(1);
        user1.ifPresent(user -> System.out.println("Found: " + user));
        
        // Finding non-existing user
        Optional<User> user999 = userService.findUserById(999);
        User defaultUser = user999.orElse(new User(0, "Guest", "guest@example.com"));
        System.out.println("User or default: " + defaultUser);
        
        // Chaining operations
        String email = userService.findUserById(2)
            .map(User::getEmail)
            .map(String::toUpperCase)
            .orElse("NO EMAIL");
        System.out.println("Email: " + email);
        
        // Using Optional in stream
        List<Integer> userIds = Arrays.asList(1, 999, 2, 888, 3);
        List<User> existingUsers = userIds.stream()
            .map(userService::findUserById)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
        System.out.println("Existing users: " + existingUsers);
        
        // Better approach with flatMap
        List<User> existingUsers2 = userIds.stream()
            .map(userService::findUserById)
            .flatMap(Optional::stream) // Java 9+, or use filter + map
            .collect(Collectors.toList());
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="date-time-api" class="section">
                    <h2>üìÖ Date & Time API</h2>
                    
                    <div class="subsection">
                        <h3>LocalDate, LocalTime, LocalDateTime</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;

public class DateTimeDemo {
    public static void main(String[] args) {
        // Current date and time
        LocalDate today = LocalDate.now();
        LocalTime currentTime = LocalTime.now();
        LocalDateTime now = LocalDateTime.now();
        
        System.out.println("Today: " + today);
        System.out.println("Current time: " + currentTime);
        System.out.println("Now: " + now);
        
        // Creating specific dates and times
        LocalDate specificDate = LocalDate.of(2024, 12, 25);
        LocalTime specificTime = LocalTime.of(14, 30, 0);
        LocalDateTime specificDateTime = LocalDateTime.of(2024, 12, 25, 14, 30, 0);
        
        // Parsing from strings
        LocalDate parsedDate = LocalDate.parse("2024-12-25");
        LocalTime parsedTime = LocalTime.parse("14:30:00");
        LocalDateTime parsedDateTime = LocalDateTime.parse("2024-12-25T14:30:00");
        
        // Date arithmetic
        LocalDate tomorrow = today.plusDays(1);
        LocalDate nextWeek = today.plusWeeks(1);
        LocalDate nextMonth = today.plusMonths(1);
        LocalDate nextYear = today.plusYears(1);
        
        LocalDate yesterday = today.minusDays(1);
        LocalDate lastMonth = today.minusMonths(1);
        
        System.out.println("Tomorrow: " + tomorrow);
        System.out.println("Next week: " + nextWeek);
        System.out.println("Yesterday: " + yesterday);
        
        // Time arithmetic
        LocalTime laterTime = currentTime.plusHours(2).plusMinutes(30);
        LocalTime earlierTime = currentTime.minusHours(1);
        
        // Comparisons
        boolean isBefore = today.isBefore(tomorrow);
        boolean isAfter = today.isAfter(yesterday);
        boolean isEqual = today.isEqual(LocalDate.now());
        
        System.out.println("Today is before tomorrow: " + isBefore);
        System.out.println("Today is after yesterday: " + isAfter);
        
        // Getting components
        int year = today.getYear();
        Month month = today.getMonth();
        int dayOfMonth = today.getDayOfMonth();
        DayOfWeek dayOfWeek = today.getDayOfWeek();
        
        System.out.println("Year: " + year);
        System.out.println("Month: " + month);
        System.out.println("Day of month: " + dayOfMonth);
        System.out.println("Day of week: " + dayOfWeek);
        
        // Formatting
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd-MM-yyyy");
        String formattedDate = today.format(formatter);
        System.out.println("Formatted date: " + formattedDate);
        
        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm:ss");
        String formattedTime = currentTime.format(timeFormatter);
        System.out.println("Formatted time: " + formattedTime);
        
        // Period and Duration
        LocalDate startDate = LocalDate.of(2024, 1, 1);
        LocalDate endDate = LocalDate.of(2024, 12, 31);
        Period period = Period.between(startDate, endDate);
        System.out.println("Period: " + period.getMonths() + " months, " + period.getDays() + " days");
        
        LocalTime startTime = LocalTime.of(9, 0);
        LocalTime endTime = LocalTime.of(17, 30);
        Duration duration = Duration.between(startTime, endTime);
        System.out.println("Duration: " + duration.toHours() + " hours, " + duration.toMinutesPart() + " minutes");
        
        // ChronoUnit for calculations
        long daysBetween = ChronoUnit.DAYS.between(startDate, endDate);
        long hoursBetween = ChronoUnit.HOURS.between(startTime, endTime);
        
        System.out.println("Days between: " + daysBetween);
        System.out.println("Hours between: " + hoursBetween);
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>ZonedDateTime and Time Zones</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.time.*;
import java.time.format.DateTimeFormatter;

public class TimeZoneDemo {
    public static void main(String[] args) {
        // Current time in system default timezone
        ZonedDateTime nowInSystemTZ = ZonedDateTime.now();
        System.out.println("Now in system TZ: " + nowInSystemTZ);
        
        // Current time in specific timezone
        ZonedDateTime nowInNY = ZonedDateTime.now(ZoneId.of("America/New_York"));
        ZonedDateTime nowInTokyo = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));
        ZonedDateTime nowInLondon = ZonedDateTime.now(ZoneId.of("Europe/London"));
        
        System.out.println("Now in NY: " + nowInNY);
        System.out.println("Now in Tokyo: " + nowInTokyo);
        System.out.println("Now in London: " + nowInLondon);
        
        // Converting between timezones
        ZonedDateTime meetingTimeNY = ZonedDateTime.of(2024, 12, 25, 14, 0, 0, 0, 
                                                      ZoneId.of("America/New_York"));
        ZonedDateTime meetingTimeTokyo = meetingTimeNY.withZoneSameInstant(ZoneId.of("Asia/Tokyo"));
        ZonedDateTime meetingTimeLondon = meetingTimeNY.withZoneSameInstant(ZoneId.of("Europe/London"));
        
        System.out.println("Meeting time in NY: " + meetingTimeNY);
        System.out.println("Meeting time in Tokyo: " + meetingTimeTokyo);
        System.out.println("Meeting time in London: " + meetingTimeLondon);
        
        // Working with Instant (UTC)
        Instant instant = Instant.now();
        System.out.println("Current instant (UTC): " + instant);
        
        // Converting between Instant and ZonedDateTime
        ZonedDateTime fromInstant = instant.atZone(ZoneId.of("America/Los_Angeles"));
        Instant backToInstant = fromInstant.toInstant();
        
        System.out.println("From instant to LA time: " + fromInstant);
        System.out.println("Back to instant: " + backToInstant);
        
        // Available time zones
        System.out.println("Available time zones (first 10):");
        ZoneId.getAvailableZoneIds().stream()
              .sorted()
              .limit(10)
              .forEach(System.out::println);
        
        // Formatting with timezone
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss z");
        String formatted = nowInNY.format(formatter);
        System.out.println("Formatted with timezone: " + formatted);
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="default-methods" class="section">
                    <h2>üîß Default Methods in Interfaces</h2>
                    
                    <div class="subsection">
                        <h3>Default Method Implementation</h3>
                        <div class="code-block">
                            <pre><code class="language-java">interface Vehicle {
    // Abstract method
    void start();
    
    // Default method
    default void stop() {
        System.out.println("Vehicle stopped");
    }
    
    default void honk() {
        System.out.println("Vehicle honks");
    }
    
    // Static method
    static void checkLicense() {
        System.out.println("Checking license...");
    }
}

interface Electric {
    default void charge() {
        System.out.println("Charging battery");
    }
    
    default void displayBatteryLevel() {
        System.out.println("Battery level: 80%");
    }
}

class Car implements Vehicle, Electric {
    @Override
    public void start() {
        System.out.println("Car engine started");
    }
    
    // Can override default methods
    @Override
    public void honk() {
        System.out.println("Car honks: Beep beep!");
    }
    
    // Inherits stop() and charge() default methods
}

class ElectricCar implements Vehicle, Electric {
    @Override
    public void start() {
        System.out.println("Electric car started silently");
    }
    
    @Override
    public void stop() {
        System.out.println("Electric car stopped with regenerative braking");
    }
    
    @Override
    public void charge() {
        System.out.println("Fast charging electric car");
    }
}

public class DefaultMethodsDemo {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();        // Implemented method
        car.stop();         // Default method from Vehicle
        car.honk();         // Overridden default method
        car.charge();       // Default method from Electric
        
        ElectricCar eCar = new ElectricCar();
        eCar.start();       // Implemented method
        eCar.stop();        // Overridden default method
        eCar.charge();      // Overridden default method
        eCar.displayBatteryLevel(); // Default method from Electric
        
        // Static method call
        Vehicle.checkLicense();
    }
}</code></pre>
                        </div>
                    </div>

                    <div class="subsection">
                        <h3>Multiple Inheritance and Diamond Problem</h3>
                        <div class="code-block">
                            <pre><code class="language-java">interface A {
    default void method() {
        System.out.println("Method from A");
    }
}

interface B {
    default void method() {
        System.out.println("Method from B");
    }
}

// Diamond problem - must resolve conflict
class C implements A, B {
    @Override
    public void method() {
        // Must provide implementation to resolve conflict
        System.out.println("Method from C");
        
        // Can call specific interface methods
        A.super.method();
        B.super.method();
    }
}

// Interface extending another interface
interface Advanced extends A {
    default void advancedMethod() {
        System.out.println("Advanced method");
        method(); // Calls inherited default method
    }
    
    // Can override inherited default method
    @Override
    default void method() {
        System.out.println("Overridden method in Advanced");
    }
}

class D implements Advanced {
    // Inherits overridden method from Advanced
}

public class DiamondProblemDemo {
    public static void main(String[] args) {
        C c = new C();
        c.method(); // Calls overridden method and both interface methods
        
        D d = new D();
        d.method();         // Calls overridden method from Advanced
        d.advancedMethod(); // Calls default method from Advanced
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <section id="best-practices" class="section">
                    <h2>üí° Java 8 Best Practices</h2>
                    
                    <div class="best-practices">
                        <div class="dos-donts">
                            <div class="dos">
                                <h3>‚úÖ Do's</h3>
                                <ul>
                                    <li>Use method references when they improve readability</li>
                                    <li>Prefer Optional over null returns</li>
                                    <li>Use streams for data processing pipelines</li>
                                    <li>Keep lambda expressions short and focused</li>
                                    <li>Use parallel streams for CPU-intensive operations</li>
                                    <li>Leverage collectors for complex reductions</li>
                                    <li>Use the new Date/Time API instead of Date/Calendar</li>
                                    <li>Create custom functional interfaces when needed</li>
                                </ul>
                            </div>
                            <div class="donts">
                                <h3>‚ùå Don'ts</h3>
                                <ul>
                                    <li>Don't use streams for simple iterations</li>
                                    <li>Don't call Optional.get() without checking isPresent()</li>
                                    <li>Don't use parallel streams for I/O operations</li>
                                    <li>Don't make lambda expressions too complex</li>
                                    <li>Don't modify external variables in lambda expressions</li>
                                    <li>Don't use streams when traditional loops are clearer</li>
                                    <li>Don't ignore the performance implications of streams</li>
                                    <li>Don't overuse Optional for everything</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="examples" class="section">
                    <h2>üåç Real-World Examples</h2>
                    
                    <div class="subsection">
                        <h3>Employee Management System</h3>
                        <div class="code-block">
                            <pre><code class="language-java">import java.util.*;
import java.util.stream.*;
import java.time.LocalDate;

class Employee {
    private String name;
    private String department;
    private double salary;
    private LocalDate joinDate;
    
    public Employee(String name, String department, double salary, LocalDate joinDate) {
        this.name = name;
        this.department = department;
        this.salary = salary;
        this.joinDate = joinDate;
    }
    
    // Getters
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
    public LocalDate getJoinDate() { return joinDate; }
    
    @Override
    public String toString() {
        return String.format("%s (%s, $%.0f)", name, department, salary);
    }
}

public class EmployeeManagementSystem {
    private List<Employee> employees;
    
    public EmployeeManagementSystem() {
        employees = Arrays.asList(
            new Employee("Alice", "Engineering", 95000, LocalDate.of(2020, 1, 15)),
            new Employee("Bob", "Marketing", 75000, LocalDate.of(2019, 3, 10)),
            new Employee("Charlie", "Engineering", 105000, LocalDate.of(2018, 7, 20)),
            new Employee("David", "Sales", 85000, LocalDate.of(2021, 2, 5)),
            new Employee("Eve", "Engineering", 98000, LocalDate.of(2020, 11, 30)),
            new Employee("Frank", "Marketing", 72000, LocalDate.of(2022, 1, 12))
        );
    }
    
    // Find employees by department
    public List<Employee> getEmployeesByDepartment(String department) {
        return employees.stream()
                       .filter(emp -> emp.getDepartment().equals(department))
                       .collect(Collectors.toList());
    }
    
    // Get average salary by department
    public Map<String, Double> getAverageSalaryByDepartment() {
        return employees.stream()
                       .collect(Collectors.groupingBy(
                           Employee::getDepartment,
                           Collectors.averagingDouble(Employee::getSalary)
                       ));
    }
    
    // Find top N earners
    public List<Employee> getTopEarners(int n) {
        return employees.stream()
                       .sorted(Comparator.comparing(Employee::getSalary).reversed())
                       .limit(n)
                       .collect(Collectors.toList());
    }
    
    // Get employees joined in specific year
    public List<Employee> getEmployeesJoinedInYear(int year) {
        return employees.stream()
                       .filter(emp -> emp.getJoinDate().getYear() == year)
                       .collect(Collectors.toList());
    }
    
    // Calculate total salary expense
    public double getTotalSalaryExpense() {
        return employees.stream()
                       .mapToDouble(Employee::getSalary)
                       .sum();
    }
    
    // Find employee with highest salary in department
    public Optional<Employee> getHighestPaidInDepartment(String department) {
        return employees.stream()
                       .filter(emp -> emp.getDepartment().equals(department))
                       .max(Comparator.comparing(Employee::getSalary));
    }
    
    public static void main(String[] args) {
        EmployeeManagementSystem ems = new EmployeeManagementSystem();
        
        // Get engineering employees
        System.out.println("Engineering employees:");
        ems.getEmployeesByDepartment("Engineering")
           .forEach(System.out::println);
        
        // Average salary by department
        System.out.println("\nAverage salary by department:");
        ems.getAverageSalaryByDepartment()
           .forEach((dept, avg) -> System.out.printf("%s: $%.0f%n", dept, avg));
        
        // Top 3 earners
        System.out.println("\nTop 3 earners:");
        ems.getTopEarners(3)
           .forEach(System.out::println);
        
        // Total salary expense
        System.out.printf("\nTotal salary expense: $%.0f%n", ems.getTotalSalaryExpense());
        
        // Highest paid in Engineering
        ems.getHighestPaidInDepartment("Engineering")
           .ifPresent(emp -> System.out.println("Highest paid in Engineering: " + emp));
    }
}</code></pre>
                        </div>
                    </div>
                </section>

                <div class="conclusion">
                    <h3>üéØ Java 8 Mastery</h3>
                    <p>You've learned the powerful features introduced in Java 8 that revolutionized Java programming. These features enable more functional, readable, and efficient code.</p>
                    <p><strong>Key Benefits:</strong> Lambda expressions reduce boilerplate code, Stream API enables powerful data processing, Optional prevents null pointer exceptions, and the new Date/Time API provides better time handling.</p>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <div class="container">
            <p>&copy; 2025 Sonu Kumar - Senior Full Stack Developer | Java Spring Boot Angular React Expert | Available for remote work, enterprise consulting, and full-time opportunities | Contact: <a href="mailto:skrdeveloper1@gmail.com">skrdeveloper1@gmail.com</a> | LinkedIn: <a href="https://www.linkedin.com/in/sonuskr">linkedin.com/in/sonuskr</a></p>
        </div>
    </footer>
</body>
</html>