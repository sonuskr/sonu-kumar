<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="dns-prefetch" href="https://fonts.gstatic.com" />
    <title>React Learning - Sonu Kumar</title>
    <link rel="stylesheet" href="tutorial-styles.css" />
  </head>
  <body class="page-react">
    <header>
      <div class="container">
        <div class="hero">
          <h1>React Learning Tutorial</h1>
          <p>Master React Advanced Patterns</p>
        </div>
      </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'react';</script>
    <script src="menu.js"></script>
    <div class="container">
      <div class="content-with-sidebar">
        <div class="sidebar-toc">
          <div class="toc-header">
            <h2>üìö Table of Contents</h2>
          </div>
          <nav class="toc-nav">
            <ul>
              <li><a href="#what-is-react">What is React?</a></li>
              <li><a href="#core-concepts">React Core Concepts</a></li>
              <li><a href="#components">Functional Components & JSX</a></li>
              <li><a href="#usestate">useState Hook</a></li>
              <li><a href="#useeffect">useEffect Hook</a></li>
              <li><a href="#usecontext">useContext</a></li>
              <li><a href="#usereducer">useReducer</a></li>
              <li><a href="#performance">useMemo & useCallback</a></li>
              <li><a href="#custom-hooks">Custom Hooks</a></li>
              <li><a href="#conditional">Conditional Rendering</a></li>
              <li><a href="#lifting-state">Lifting State Up</a></li>
              <li><a href="#router">React Router</a></li>
              <li><a href="#error-boundaries">Error Boundaries</a></li>
              <li><a href="#optimization">Performance Optimization</a></li>
              <li><a href="#state-management">State Management</a></li>
              <li><a href="#interview">Interview Questions</a></li>
              <li><a href="#best-practices">Best Practices</a></li>
              <li><a href="#testing">Testing</a></li>
            </ul>
          </nav>
        </div>
        <div class="main-content">
          <div class="topic">
            <h1>React - Complete Guide</h1>

          <section id="what-is-react" class="section">
            <h2>üöÄ What is React?</h2>
            <p><strong>What it is:</strong> React is a JavaScript library for building user interfaces using a component-based architecture and virtual DOM for efficient rendering.</p>
            <p><strong>How it works:</strong> Creates reusable UI components that manage their own state, uses virtual DOM to optimize updates, and follows unidirectional data flow.</p>
            <p><strong>Why use it:</strong> Simplifies complex UI development, provides excellent performance through virtual DOM, has huge ecosystem, and is backed by Meta (Facebook).</p>
            
            <div class="subsection">
                <h3>Key Features</h3>
                <ul>
                    <li><strong>Component-Based:</strong> Build encapsulated components that manage their own state</li>
                    <li><strong>Virtual DOM:</strong> Efficient diffing algorithm for optimal performance</li>
                    <li><strong>Declarative:</strong> Describe what UI should look like, React handles how</li>
                    <li><strong>Learn Once, Write Anywhere:</strong> React Native for mobile, Next.js for SSR</li>
                    <li><strong>Rich Ecosystem:</strong> Vast library of third-party packages and tools</li>
                </ul>
            </div>
          </section>

          <section id="core-concepts" class="section">
            <h2>üè¢ React Core Concepts</h2>
            <p><strong>What it covers:</strong> Fundamental building blocks that every React developer must understand to build effective applications.</p>
            <p><strong>How they work together:</strong> Components use JSX to render UI, manage state internally, receive props from parents, and use hooks for lifecycle and side effects.</p>
            
            <div class="subsection">
                <h3>Essential Concepts</h3>
                <ul>
                    <li><strong>Components:</strong> Reusable UI pieces (functional recommended over class-based)</li>
                    <li><strong>JSX:</strong> HTML-like syntax in JavaScript that gets transpiled to React.createElement calls</li>
                    <li><strong>State:</strong> Component's internal data that can change over time</li>
                    <li><strong>Props:</strong> Read-only data passed from parent to child components</li>
                    <li><strong>Virtual DOM:</strong> In-memory representation for efficient DOM updates</li>
                    <li><strong>Hooks:</strong> Functions that let you use state and lifecycle in functional components</li>
                    <li><strong>Context:</strong> Share data across component tree without prop drilling</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3>Data Flow</h3>
                <p>React follows <strong>unidirectional data flow:</strong><br>
                1. <strong>Props down:</strong> Data flows from parent to child<br>
                2. <strong>Events up:</strong> Child communicates to parent via callbacks<br>
                3. <strong>State management:</strong> Each component manages its own state<br>
                4. <strong>Context:</strong> Global state accessible anywhere in component tree</p>
            </div>
          </section>

          <section id="components" class="section">
            <h2>üß© Functional Components & JSX</h2>
            <p><strong>What it does:</strong> Functional components are JavaScript functions that return JSX to describe what should appear on screen.</p>
            <p><strong>How it works:</strong> JSX gets transpiled to React.createElement calls, creating a virtual DOM tree that React uses to update the real DOM efficiently.</p>
            <p><strong>Best Practice:</strong> Always use functional components with hooks instead of class components for cleaner, more testable code.</p>
          <pre><code>
// Functional component - modern approach
function Welcome(props) {
    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

// With destructuring
function Greeting({ name, age }) {
    return (
        &lt;div&gt;
            &lt;p&gt;Name: {name}&lt;/p&gt;
            &lt;p&gt;Age: {age}&lt;/p&gt;
        &lt;/div&gt;
    );
}

// JSX rules
// - Single root element
// - className instead of class
// - htmlFor instead of for
// - Event handlers in camelCase: onClick, onChange
// - Expressions in {}

function App() {
    const title = 'React App';
    const isValid = true;
    
    return (
        &lt;div className="app"&gt;
            &lt;h1&gt;{title}&lt;/h1&gt;
            &lt;input type="text" onChange={(e) =&gt; console.log(e.target.value)} /&gt;
            &lt;button onClick={() =&gt; console.log('clicked')}&gt;Click&lt;/button&gt;
            
            {isValid ? &lt;p&gt;Valid&lt;/p&gt; : &lt;p&gt;Invalid&lt;/p&gt;}
            {isValid &amp;&amp; &lt;p&gt;Shown if valid&lt;/p&gt;}
        &lt;/div&gt;
    );
}
                </code></pre>

          </section>

          <section id="usestate" class="section">
            <h2>üíæ useState Hook - State Management</h2>
            <p><strong>What it does:</strong> Adds state to functional components, allowing them to remember values between renders.</p>
            <p><strong>How it works:</strong> Returns current state value and setter function, triggers re-render when state changes.</p>
            <p><strong>Key Rule:</strong> State updates are asynchronous and may be batched for performance. Always use functional updates for state that depends on previous state.</p>
          <pre><code>
import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);
    const [user, setUser] = useState({ name: 'John', age: 30 });
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
            
            {/* Updating state correctly */}
            &lt;button onClick={() =&gt; setCount(prevCount =&gt; prevCount + 1)}&gt;
                Best Practice Increment
            &lt;/button&gt;
            
            {/* Complex state */}
            &lt;p&gt;User: {user.name}, Age: {user.age}&lt;/p&gt;
            &lt;button onClick={() =&gt; setUser({ ...user, age: user.age + 1 })}&gt;
                Increment Age
            &lt;/button&gt;
        &lt;/div&gt;
    );
}

// Multiple state variables
function Form() {
    const [formData, setFormData] = useState({
        email: '',
        password: ''
    });
    
    const handleChange = (e) =&gt; {
        const { name, value } = e.target;
        setFormData(prev =&gt; ({
            ...prev,
            [name]: value
        }));
    };
    
    return (
        &lt;form&gt;
            &lt;input name="email" value={formData.email} onChange={handleChange} /&gt;
            &lt;input name="password" type="password" value={formData.password} onChange={handleChange} /&gt;
        &lt;/form&gt;
    );
}
                </code></pre>

          </section>

          <section id="useeffect" class="section">
            <h2>‚öôÔ∏è useEffect Hook - Side Effects</h2>
            <p><strong>What it does:</strong> Handles side effects like API calls, subscriptions, timers, and DOM manipulation in functional components.</p>
            <p><strong>How it works:</strong> Runs after render, can return cleanup function, dependency array controls when it runs.</p>
            <p><strong>Critical:</strong> Always include dependencies in dependency array to avoid bugs. Use cleanup functions to prevent memory leaks.</p>
          <pre><code>
import { useState, useEffect } from 'react';

function UserProfile({ userId }) {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    // Run after every render (be careful!)
    useEffect(() =&gt; {
        console.log('Component rendered');
    });
    
    // Run once on mount (dependency array empty)
    useEffect(() =&gt; {
        console.log('Component mounted');
        return () =&gt; console.log('Component unmounted');
    }, []);
    
    // Run when userId changes
    useEffect(() =&gt; {
        setLoading(true);
        fetch(`/api/users/${userId}`)
            .then(res =&gt; res.json())
            .then(data =&gt; {
                setUser(data);
                setLoading(false);
            })
            .catch(err =&gt; console.error(err));
    }, [userId]);  // Dependency array
    
    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
    if (!user) return &lt;p&gt;No user found&lt;/p&gt;;
    
    return &lt;div&gt;&lt;h1&gt;{user.name}&lt;/h1&gt;&lt;/div&gt;;
}

// Cleanup - prevent memory leaks
function Timer() {
    const [seconds, setSeconds] = useState(0);
    
    useEffect(() =&gt; {
        const interval = setInterval(() =&gt; {
            setSeconds(s =&gt; s + 1);
        }, 1000);
        
        // Cleanup function
        return () =&gt; clearInterval(interval);
    }, []);
    
    return &lt;p&gt;Seconds: {seconds}&lt;/p&gt;;
}
                </code></pre>

          </section>

          <section id="usecontext" class="section">
            <h2>üåê useContext - Avoiding Prop Drilling</h2>
            <p><strong>What it does:</strong> Provides a way to share data across component tree without passing props through every level.</p>
            <p><strong>How it works:</strong> Context Provider supplies value, useContext hook consumes it in any descendant component.</p>
            <p><strong>When to use:</strong> For truly global data like theme, user authentication, or language settings. Don't overuse for local state.</p>
          <pre><code>
import { createContext, useState, useContext } from 'react';

// Create context
const ThemeContext = createContext();

// Provider component
export function ThemeProvider({ children }) {
    const [isDark, setIsDark] = useState(false);
    
    const toggleTheme = () =&gt; setIsDark(!isDark);
    
    const value = { isDark, toggleTheme };
    
    return (
        &lt;ThemeContext.Provider value={value}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
}

// Custom hook for using context
export function useTheme() {
    const context = useContext(ThemeContext);
    if (!context) {
        throw new Error('useTheme must be used within ThemeProvider');
    }
    return context;
}

// Using in components
function Header() {
    const { isDark, toggleTheme } = useTheme();
    
    return (
        &lt;header className={isDark ? 'dark-header' : 'light-header'}&gt;
            &lt;button onClick={toggleTheme}&gt;
                {isDark ? 'Light' : 'Dark'} Mode
            &lt;/button&gt;
        &lt;/header&gt;
    );
}

// App setup
function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;Header /&gt;
            &lt;Main /&gt;
        &lt;/ThemeProvider&gt;
    );
}
                </code></pre>

          </section>

          <section id="usereducer" class="section">
            <h2>üîÑ useReducer - Complex State Logic</h2>
            <p><strong>What it does:</strong> Manages complex state logic with predictable state transitions using reducer pattern.</p>
            <p><strong>How it works:</strong> Takes current state and action, returns new state based on action type. Similar to Redux but local to component.</p>
            <p><strong>When to use:</strong> When useState becomes complex, multiple related state variables, or need predictable state updates.</p>
          <pre><code>
import { useReducer } from 'react';

// Reducer function
const initialState = { count: 0, error: null };

function reducer(state, action) {
    switch (action.type) {
        case 'INCREMENT':
            return { ...state, count: state.count + 1 };
        case 'DECREMENT':
            return { ...state, count: state.count - 1 };
        case 'RESET':
            return initialState;
        case 'ERROR':
            return { ...state, error: action.payload };
        default:
            return state;
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {state.count}&lt;/p&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;+&lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;-&lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'RESET' })}&gt;Reset&lt;/button&gt;
            {state.error &amp;&amp; &lt;p&gt;Error: {state.error}&lt;/p&gt;}
        &lt;/div&gt;
    );
}
                </code></pre>

          </section>

          <section id="performance" class="section">
            <h2>‚ö° useMemo & useCallback - Performance Optimization</h2>
            <p><strong>What it does:</strong> Prevents expensive recalculations and unnecessary re-renders by memoizing values and functions.</p>
            <p><strong>How it works:</strong> useMemo caches computed values, useCallback caches function references, both recompute only when dependencies change.</p>
            <p><strong>Important:</strong> Don't overuse - only optimize when you have actual performance problems. Measure first, optimize second.</p>
          <pre><code>
import { useMemo, useCallback } from 'react';

function ExpensiveComponent({ items }) {
    // Memoize expensive calculation
    const expensiveValue = useMemo(() =&gt; {
        console.log('Computing expensive value...');
        return items.reduce((sum, item) =&gt; sum + item.value, 0);
    }, [items]);  // Recalculate only if items changes
    
    // Memoize callback - same reference unless dependencies change
    const handleClick = useCallback(() =&gt; {
        console.log('Clicked', items);
    }, [items]);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Total: {expensiveValue}&lt;/p&gt;
            &lt;ChildComponent onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}

// Prevent unnecessary re-renders
import { memo } from 'react';

const ChildComponent = memo(({ onClick }) =&gt; {
    console.log('ChildComponent rendered');
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});
                </code></pre>

          </section>

          <section id="custom-hooks" class="section">
            <h2>üé£ Custom Hooks - Reusable Logic</h2>
            <p><strong>What it does:</strong> Extracts component logic into reusable functions that can be shared across multiple components.</p>
            <p><strong>How it works:</strong> Custom hooks are JavaScript functions that start with 'use' and can call other hooks inside them.</p>
            <p><strong>Benefits:</strong> Code reuse, separation of concerns, easier testing, and cleaner components focused on rendering.</p>
          <pre><code>
// Custom hook for API fetching
function useFetch(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('API error');
                const result = await response.json();
                setData(result);
            } catch (err) {
                setError(err.message);
            } finally {
                setLoading(false);
            }
        };
        
        fetchData();
    }, [url]);
    
    return { data, loading, error };
}

// Usage
function UserList() {
    const { data: users, loading, error } = useFetch('/api/users');
    
    if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
    if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;
    
    return (
        &lt;ul&gt;
            {users?.map(user =&gt; &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
}

// Custom hook for form handling
function useForm(initialValues, onSubmit) {
    const [values, setValues] = useState(initialValues);
    
    const handleChange = (e) =&gt; {
        const { name, value } = e.target;
        setValues(prev =&gt; ({ ...prev, [name]: value }));
    };
    
    const handleSubmit = (e) =&gt; {
        e.preventDefault();
        onSubmit(values);
    };
    
    return { values, handleChange, handleSubmit };
}
                </code></pre>

          </section>

          <section id="conditional" class="section">
            <h2>üîÄ Conditional Rendering & Lists</h2>
            <p><strong>What it does:</strong> Controls which elements are rendered based on conditions and efficiently renders dynamic lists of data.</p>
            <p><strong>How it works:</strong> Uses JavaScript expressions (ternary, logical AND, if-else) to conditionally render JSX elements.</p>
            <p><strong>Key Rule:</strong> Always provide unique 'key' prop for list items to help React identify which items have changed for optimal performance.</p>
          <pre><code>
function App({ isLoggedIn, items }) {
    // Method 1: If-else
    if (isLoggedIn) {
        return &lt;Dashboard /&gt;;
    }
    return &lt;Login /&gt;;
    
    // Method 2: Ternary operator
    return isLoggedIn ? &lt;Dashboard /&gt; : &lt;Login /&gt;;
    
    // Method 3: Logical AND
    return isLoggedIn &amp;&amp; &lt;Dashboard /&gt;;
    
    // Method 4: Switch statement
    switch (userRole) {
        case 'admin':
            return &lt;AdminPanel /&gt;;
        case 'user':
            return &lt;UserDashboard /&gt;;
        default:
            return &lt;GuestView /&gt;;
    }
}

// Rendering lists - always use key
function ItemList({ items }) {
    return (
        &lt;ul&gt;
            {items.map(item =&gt; (
                &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

// Filtering list
function FilteredList({ items, filter }) {
    return (
        &lt;ul&gt;
            {items
                .filter(item =&gt; item.category === filter)
                .map(item =&gt; (
                    &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
                ))}
        &lt;/ul&gt;
    );
}
                </code></pre>

          </section>

          <section id="lifting-state" class="section">
            <h2>‚¨ÜÔ∏è Lifting State Up & Component Composition</h2>
            <p><strong>What it does:</strong> Moves shared state to closest common ancestor and uses composition patterns for flexible, reusable components.</p>
            <p><strong>How it works:</strong> Parent component manages state and passes it down as props, children communicate back via callback functions.</p>
            <p><strong>Design Pattern:</strong> Promotes single source of truth and makes data flow predictable and easier to debug.</p>
          <pre><code>
// State managed in parent, passed to children
function TemperatureCalculator() {
    const [celsius, setCelsius] = useState(0);
    
    const fahrenheit = (celsius * 9/5) + 32;
    
    return (
        &lt;div&gt;
            &lt;TemperatureInput
                label="Celsius"
                value={celsius}
                onChange={(e) =&gt; setCelsius(e.target.value)}
            /&gt;
            &lt;TemperatureInput
                label="Fahrenheit"
                value={fahrenheit}
                onChange={() =&gt; {}}
                readOnly
            /&gt;
        &lt;/div&gt;
    );
}

// Composition pattern - flexible components
function Card({ header, body, footer, children }) {
    return (
        &lt;div className="card"&gt;
            {header &amp;&amp; &lt;div className="header"&gt;{header}&lt;/div&gt;}
            {body &amp;&amp; &lt;div className="body"&gt;{body}&lt;/div&gt;}
            {children}
            {footer &amp;&amp; &lt;div className="footer"&gt;{footer}&lt;/div&gt;}
        &lt;/div&gt;
    );
}

// Render props pattern
function MouseTracker({ render }) {
    const [position, setPosition] = useState({ x: 0, y: 0 });
    
    const handleMouseMove = (e) =&gt; {
        setPosition({ x: e.clientX, y: e.clientY });
    };
    
    return (
        &lt;div onMouseMove={handleMouseMove}&gt;
            {render(position)}
        &lt;/div&gt;
    );
}

// Usage
&lt;MouseTracker render={({ x, y }) =&gt; &lt;p&gt;X: {x}, Y: {y}&lt;/p&gt;} /&gt;
                </code></pre>

          </section>

          <section id="router" class="section">
            <h2>üó∫Ô∏è React Router - Client-Side Navigation</h2>
            <p><strong>What it does:</strong> Enables client-side routing in single-page applications, allowing navigation without full page reloads.</p>
            <p><strong>How it works:</strong> Maps URL paths to React components, manages browser history, and provides navigation components and hooks.</p>
            <p><strong>Benefits:</strong> Faster navigation, better user experience, SEO-friendly URLs, and programmatic navigation control.</p>
          <pre><code>
import { BrowserRouter, Routes, Route, Link, useParams } from 'react-router-dom';

function App() {
    return (
        &lt;BrowserRouter&gt;
            &lt;nav&gt;
                &lt;Link to="/"&gt;Home&lt;/Link&gt;
                &lt;Link to="/about"&gt;About&lt;/Link&gt;
                &lt;Link to="/users/123"&gt;User&lt;/Link&gt;
            &lt;/nav&gt;
            
            &lt;Routes&gt;
                &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
                &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
                &lt;Route path="/users/:id" element={&lt;UserDetail /&gt;} /&gt;
                &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
            &lt;/Routes&gt;
        &lt;/BrowserRouter&gt;
    );
}

function UserDetail() {
    const { id } = useParams();
    return &lt;h1&gt;User ID: {id}&lt;/h1&gt;;
}
                </code></pre>

          </section>

          <section id="error-boundaries" class="section">
            <h2>üõ°Ô∏è Error Boundaries - Graceful Error Handling</h2>
            <p><strong>What it does:</strong> Catches JavaScript errors in component tree and displays fallback UI instead of crashing the entire application.</p>
            <p><strong>How it works:</strong> Class components with componentDidCatch lifecycle method catch errors in child components during rendering.</p>
            <p><strong>Limitation:</strong> Only catches errors in render methods and lifecycle methods, not in event handlers or async code.</p>
          <pre><code>
import { Component } from 'react';

class ErrorBoundary extends Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
    }
    
    static getDerivedStateFromError(error) {
        return { hasError: true, error };
    }
    
    componentDidCatch(error, errorInfo) {
        console.error('Error caught:', error, errorInfo);
        // Log to error reporting service
    }
    
    render() {
        if (this.state.hasError) {
            return &lt;h1&gt;Something went wrong: {this.state.error.message}&lt;/h1&gt;;
        }
        
        return this.props.children;
    }
}

// Usage
&lt;ErrorBoundary&gt;
    &lt;ProblematicComponent /&gt;
&lt;/ErrorBoundary&gt;
                </code></pre>

          </section>

          <section id="optimization" class="section">
            <h2>üöÄ Performance Optimization Techniques</h2>
            <p><strong>What it covers:</strong> Advanced techniques to make React applications faster and more efficient for better user experience.</p>
            <p><strong>How to apply:</strong> Measure performance first using React DevTools Profiler, then apply optimizations where bottlenecks exist.</p>
            
            <div class="subsection">
                <h3>Core Optimization Strategies</h3>
                <ul>
                    <li><strong>Code Splitting:</strong> Lazy load components with React.lazy() to reduce initial bundle size</li>
                    <li><strong>React.memo:</strong> Prevent unnecessary re-renders of functional components</li>
                    <li><strong>useMemo & useCallback:</strong> Memoize expensive computations and function references</li>
                    <li><strong>Virtual List:</strong> Render only visible items for large datasets (react-window)</li>
                    <li><strong>Image Optimization:</strong> Lazy load images, use WebP format, responsive images</li>
                    <li><strong>Bundle Analysis:</strong> Use Webpack Bundle Analyzer to identify large dependencies</li>
                    <li><strong>Suspense:</strong> Handle loading states elegantly with React.Suspense</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3>Performance Monitoring</h3>
                <p><strong>Tools:</strong> React DevTools Profiler, Chrome DevTools, Web Vitals<br>
                <strong>Metrics:</strong> First Contentful Paint, Largest Contentful Paint, Time to Interactive<br>
                <strong>Best Practice:</strong> Measure before optimizing, focus on user-perceived performance</p>
            </div>
          </section>

          <section id="state-management" class="section">
            <h2>üìä State Management Solutions</h2>
            <p><strong>What it solves:</strong> Managing complex application state that needs to be shared across multiple components efficiently.</p>
            <p><strong>How to choose:</strong> Start with built-in React state, add Context for global state, consider external libraries for complex apps.</p>
            
            <div class="subsection">
                <h3>State Management Options</h3>
                <ul>
                    <li><strong>useState + Context:</strong> Built-in solution for small to mid-size apps</li>
                    <li><strong>useReducer + Context:</strong> More predictable state updates for complex logic</li>
                    <li><strong>Redux Toolkit:</strong> Industry standard for large applications with time-travel debugging</li>
                    <li><strong>Zustand:</strong> Simple, lightweight alternative with minimal boilerplate</li>
                    <li><strong>Recoil:</strong> Facebook's experimental atom-based state management</li>
                    <li><strong>Jotai:</strong> Primitive and flexible bottom-up state management</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3>Decision Matrix</h3>
                <p><strong>Small apps:</strong> useState + props<br>
                <strong>Medium apps:</strong> Context + useReducer<br>
                <strong>Large apps:</strong> Redux Toolkit or Zustand<br>
                <strong>Complex async:</strong> Redux Toolkit Query or React Query</p>
            </div>
          </section>

          <section id="interview" class="section">
            <h2>üéØ Common Interview Problems & Concepts</h2>
            <p><strong>What to expect:</strong> Interviewers focus on React fundamentals, performance optimization, and real-world problem-solving scenarios.</p>
            <p><strong>How to prepare:</strong> Understand core concepts deeply, practice building components, and know when to use different patterns.</p>
            
            <div class="subsection">
                <h3>Most Asked Topics</h3>
                <ul>
                    <li><strong>Virtual DOM vs Real DOM:</strong> Explain reconciliation algorithm and why it's faster</li>
                    <li><strong>useState vs useReducer:</strong> When to use each for state management</li>
                    <li><strong>useEffect cleanup:</strong> Preventing memory leaks and handling subscriptions</li>
                    <li><strong>Key prop in lists:</strong> Why React needs keys for efficient updates</li>
                    <li><strong>Lifting state up:</strong> Managing shared state and avoiding prop drilling</li>
                    <li><strong>Performance optimization:</strong> React.memo, useMemo, useCallback usage</li>
                    <li><strong>Controlled vs uncontrolled:</strong> Form handling approaches</li>
                    <li><strong>Error boundaries:</strong> Graceful error handling in component tree</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3>Coding Challenges</h3>
                <p><strong>Build a todo app:</strong> State management, CRUD operations<br>
                <strong>Create custom hooks:</strong> useFetch, useLocalStorage<br>
                <strong>Optimize performance:</strong> Large list rendering<br>
                <strong>Handle forms:</strong> Validation and submission</p>
            </div>
          </section>

          <section id="best-practices" class="section">
            <h2>‚ú® Best Practices & Production Tips</h2>
            <p><strong>What it covers:</strong> Industry-standard practices for building maintainable, performant, and accessible React applications.</p>
            <p><strong>How to apply:</strong> Follow these patterns from project start to avoid technical debt and ensure code quality.</p>
            
            <div class="subsection">
                <h3>Development Best Practices</h3>
                <ul>
                    <li><strong>Functional Components:</strong> Always use functional components with hooks over class components</li>
                    <li><strong>Single Responsibility:</strong> Keep components small, focused, and doing one thing well</li>
                    <li><strong>Semantic HTML:</strong> Use proper HTML elements for better accessibility and SEO</li>
                    <li><strong>Accessibility (a11y):</strong> Implement ARIA labels, keyboard navigation, screen reader support</li>
                    <li><strong>TypeScript:</strong> Use TypeScript for type safety and better developer experience</li>
                    <li><strong>Error Handling:</strong> Implement proper error boundaries and loading states</li>
                    <li><strong>Performance:</strong> Avoid inline objects/functions in render, use keys in lists</li>
                    <li><strong>Testing:</strong> Write unit tests for components and custom hooks</li>
                </ul>
            </div>
            
            <div class="subsection">
                <h3>Project Structure</h3>
                <p><strong>Folder Organization:</strong> Group by feature, not by file type<br>
                <strong>Component Structure:</strong> One component per file, co-locate tests<br>
                <strong>Custom Hooks:</strong> Extract reusable logic into custom hooks<br>
                <strong>Constants:</strong> Keep magic numbers and strings in constants files</p>
            </div>
          </section>

          <section id="testing" class="section">
            <h2>üß™ Testing React Components</h2>
            <p><strong>What it does:</strong> Ensures components work correctly, prevents regressions, and improves code confidence through automated testing.</p>
            <p><strong>How it works:</strong> Uses React Testing Library to render components in test environment and simulate user interactions.</p>
            <p><strong>Best Practice:</strong> Test behavior, not implementation details. Focus on what users see and do, not internal state.</p>
          <pre><code>
import { render, screen, fireEvent } from '@testing-library/react';
import { UserCard } from './UserCard';

describe('UserCard', () =&gt; {
    test('renders user information', () =&gt; {
        render(&lt;UserCard user={{ name: 'John', age: 30 }} /&gt;);
        expect(screen.getByText('John')).toBeInTheDocument();
    });
    
    test('calls onClick when button is clicked', () =&gt; {
        const handleClick = jest.fn();
        render(&lt;UserCard user={{}} onClick={handleClick} /&gt;);
        fireEvent.click(screen.getByRole('button'));
        expect(handleClick).toHaveBeenCalled();
    });
});
                </code></pre>

          </section>

          <section id="key-questions" class="section">
            <h2>üìù Key Interview Questions & Answers</h2>
            <p><strong>What to expect:</strong> These are the most commonly asked React questions in technical interviews across all experience levels.</p>
            <p><strong>How to answer:</strong> Provide clear explanations with examples, mention trade-offs, and demonstrate practical understanding.</p>
            
            <div class="subsection">
                <h3>Fundamental Questions</h3>
                <ul>
                    <li><strong>Class vs Functional Components:</strong> Functional components with hooks are preferred for cleaner code and better performance</li>
                    <li><strong>React Hooks Purpose:</strong> Allow functional components to use state and lifecycle methods previously only available in class components</li>
                    <li><strong>Virtual DOM Working:</strong> In-memory representation that React uses to efficiently update real DOM through reconciliation</li>
                    <li><strong>Controlled vs Uncontrolled:</strong> Controlled components have React managing form state, uncontrolled use refs</li>
                    <li><strong>State vs Props:</strong> State is internal and mutable, props are external and immutable</li>
                    <li><strong>Context API Usage:</strong> For global state like theme, auth, avoiding prop drilling in deep component trees</li>
                    <li><strong>Performance Optimization:</strong> React.memo, useMemo, useCallback, code splitting, lazy loading</li>
                    <li><strong>React Fiber:</strong> Reconciliation engine that enables concurrent rendering and time-slicing</li>
                    <li><strong>Error Handling:</strong> Error boundaries for component errors, try-catch for async operations</li>
                </ul>
            </div>
          </section>
          </div>
        </div>
      </div>
    </div>
      <script src="footer.js"></script>
</body>
</html>
