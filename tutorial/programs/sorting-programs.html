<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://fonts.gstatic.com">
    <title>Sorting Programs - Sonu Kumar</title>
    <link rel="stylesheet" href="../tutorial-styles.css">
</head>
<body class="page-programs">
    <header>
        <div class="container">
            <h1>Sorting Programs</h1>
            <p>Master Sorting Algorithms with Java</p>
        </div>
    </header>
    <nav></nav>
    <script>window.activePage = 'programs';</script>
    <script src="../menu.js"></script>
    <div class="container">
        <div class="content-with-sidebar">
            <div class="sidebar-toc">
                <div class="toc-header">
                    <h2>ðŸŽ¯ Quick Navigation</h2>
                </div>
                <nav class="toc-nav">
                    <ul>
                        <li><a href="#overview">Overview</a></li>
                        <li><a href="#simple-sorts">Simple Sorting (O(nÂ²))</a></li>
                        <li><a href="#efficient-sorts">Efficient Sorting (O(n log n))</a></li>
                        <li><a href="#linear-sorts">Linear Sorting (O(n))</a></li>
                        <li><a href="#specialized-sorts">Specialized Sorting</a></li>
                        <li><a href="#comparison-analysis">Comparison & Analysis</a></li>
                        <li><a href="#practical-applications">Practical Applications</a></li>
                        <li><a href="#interview-questions">Interview Questions</a></li>
                    </ul>
                </nav>
            </div>
            <div class="main-content">
            <div class="topic" id="overview">
                <h2>Sorting Algorithms Mastery ðŸš€</h2>
                <p><strong>What is Sorting?</strong> Arranging elements in a specific order (ascending or descending) using various algorithmic approaches with different time and space complexities.</p>
                <p><strong>Why Learn Sorting Algorithms?</strong> Fundamental to computer science, essential for interviews, and forms the basis for many advanced algorithms and data structures.</p>
                <p><strong>How to Approach?</strong> Understand the algorithm logic, analyze time/space complexity, implement step-by-step, and compare performance characteristics.</p>
            </div>

            <div class="topic" id="simple-sorts">
                <h2>Simple Sorting Algorithms O(nÂ²)</h2>

                <h3>1. Bubble Sort</h3>
                <p><strong>Algorithm:</strong> Repeatedly compare adjacent elements and swap if they're in wrong order</p>
                <pre><code>public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            boolean swapped = false;
            
            // Last i elements are already sorted
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap elements
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;
                }
            }
            
            // If no swapping occurred, array is sorted
            if (!swapped) break;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bubbleSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(nÂ²) worst/average, O(n) best
   Space Complexity: O(1)
   Stable: Yes
   In-place: Yes */</code></pre>

                <h3>2. Selection Sort</h3>
                <p><strong>Algorithm:</strong> Find minimum element and place it at the beginning, repeat for remaining array</p>
                <pre><code>public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            
            // Find minimum element in remaining array
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            
            // Swap minimum element with first element
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {64, 25, 12, 22, 11};
        System.out.println("Original: " + Arrays.toString(arr));
        
        selectionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(nÂ²) all cases
   Space Complexity: O(1)
   Stable: No
   In-place: Yes */</code></pre>

                <h3>3. Insertion Sort</h3>
                <p><strong>Algorithm:</strong> Build sorted array one element at a time by inserting each element in correct position</p>
                <pre><code>public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            
            // Move elements greater than key one position ahead
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    // Binary insertion sort optimization
    public static void binaryInsertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int insertPos = binarySearch(arr, key, 0, i);
            
            // Shift elements to make space
            for (int j = i; j > insertPos; j--) {
                arr[j] = arr[j - 1];
            }
            
            arr[insertPos] = key;
        }
    }
    
    private static int binarySearch(int[] arr, int key, int start, int end) {
        while (start < end) {
            int mid = start + (end - start) / 2;
            if (arr[mid] > key) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        return start;
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        System.out.println("Original: " + Arrays.toString(arr));
        
        insertionSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(nÂ²) worst/average, O(n) best
   Space Complexity: O(1)
   Stable: Yes
   In-place: Yes */</code></pre>
            </div>

            <div class="topic" id="efficient-sorts">
                <h2>Efficient Sorting Algorithms O(n log n)</h2>

                <h3>4. Merge Sort</h3>
                <p><strong>Algorithm:</strong> Divide array into halves, recursively sort them, then merge sorted halves</p>
                <pre><code>public class MergeSort {
    public static void mergeSort(int[] arr) {
        if (arr.length <= 1) return;
        
        mergeSort(arr, 0, arr.length - 1);
    }
    
    private static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            
            // Recursively sort both halves
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            
            // Merge sorted halves
            merge(arr, left, mid, right);
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        // Create temporary arrays
        int[] leftArr = new int[mid - left + 1];
        int[] rightArr = new int[right - mid];
        
        // Copy data to temporary arrays
        System.arraycopy(arr, left, leftArr, 0, leftArr.length);
        System.arraycopy(arr, mid + 1, rightArr, 0, rightArr.length);
        
        // Merge temporary arrays back
        int i = 0, j = 0, k = left;
        
        while (i < leftArr.length && j < rightArr.length) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k] = leftArr[i];
                i++;
            } else {
                arr[k] = rightArr[j];
                j++;
            }
            k++;
        }
        
        // Copy remaining elements
        while (i < leftArr.length) {
            arr[k] = leftArr[i];
            i++;
            k++;
        }
        
        while (j < rightArr.length) {
            arr[k] = rightArr[j];
            j++;
            k++;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Original: " + Arrays.toString(arr));
        
        mergeSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n log n) all cases
   Space Complexity: O(n)
   Stable: Yes
   In-place: No */</code></pre>

                <h3>5. Quick Sort</h3>
                <p><strong>Algorithm:</strong> Choose pivot, partition array around pivot, recursively sort partitions</p>
                <pre><code>public class QuickSort {
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    
    private static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pivotIndex = partition(arr, low, high);
            
            // Recursively sort elements before and after partition
            quickSort(arr, low, pivotIndex - 1);
            quickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // Choose last element as pivot
        int i = low - 1; // Index of smaller element
        
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        
        swap(arr, i + 1, high);
        return i + 1;
    }
    
    // Randomized Quick Sort (better average performance)
    public static void randomizedQuickSort(int[] arr, int low, int high) {
        if (low < high) {
            // Randomly choose pivot
            Random rand = new Random();
            int randomIndex = low + rand.nextInt(high - low + 1);
            swap(arr, randomIndex, high);
            
            int pivotIndex = partition(arr, low, high);
            
            randomizedQuickSort(arr, low, pivotIndex - 1);
            randomizedQuickSort(arr, pivotIndex + 1, high);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        System.out.println("Original: " + Arrays.toString(arr));
        
        quickSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n log n) average, O(nÂ²) worst
   Space Complexity: O(log n) average, O(n) worst
   Stable: No
   In-place: Yes */</code></pre>

                <h3>6. Heap Sort</h3>
                <p><strong>Algorithm:</strong> Build max heap, repeatedly extract maximum and place at end</p>
                <pre><code>public class HeapSort {
    public static void heapSort(int[] arr) {
        int n = arr.length;
        
        // Build max heap
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(arr, n, i);
        }
        
        // Extract elements from heap one by one
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            swap(arr, 0, i);
            
            // Call heapify on reduced heap
            heapify(arr, i, 0);
        }
    }
    
    private static void heapify(int[] arr, int n, int i) {
        int largest = i; // Initialize largest as root
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        // If left child is larger than root
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        // If right child is larger than largest so far
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        // If largest is not root
        if (largest != i) {
            swap(arr, i, largest);
            
            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }
    
    private static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        System.out.println("Original: " + Arrays.toString(arr));
        
        heapSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n log n) all cases
   Space Complexity: O(1)
   Stable: No
   In-place: Yes */</code></pre>
            </div>

            <div class="topic" id="linear-sorts">
                <h2>Linear Sorting Algorithms O(n)</h2>

                <h3>7. Counting Sort</h3>
                <p><strong>Algorithm:</strong> Count occurrences of each element, use counts to place elements in sorted order</p>
                <pre><code>public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr.length == 0) return;
        
        // Find range
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;
        
        // Count occurrences
        int[] count = new int[range];
        for (int num : arr) {
            count[num - min]++;
        }
        
        // Modify count array to store actual positions
        for (int i = 1; i < count.length; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output array
        int[] output = new int[arr.length];
        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }
        
        // Copy output array to original array
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
    
    public static void main(String[] args) {
        int[] arr = {4, 2, 2, 8, 3, 3, 1};
        System.out.println("Original: " + Arrays.toString(arr));
        
        countingSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n + k) where k is range
   Space Complexity: O(k)
   Stable: Yes
   In-place: No
   Best for: Small range of integers */</code></pre>

                <h3>8. Radix Sort</h3>
                <p><strong>Algorithm:</strong> Sort by individual digits/characters from least to most significant</p>
                <pre><code>public class RadixSort {
    public static void radixSort(int[] arr) {
        if (arr.length == 0) return;
        
        // Find maximum number to know number of digits
        int max = Arrays.stream(arr).max().getAsInt();
        
        // Do counting sort for every digit
        for (int exp = 1; max / exp > 0; exp *= 10) {
            countingSortByDigit(arr, exp);
        }
    }
    
    private static void countingSortByDigit(int[] arr, int exp) {
        int[] output = new int[arr.length];
        int[] count = new int[10]; // 0-9 digits
        
        // Count occurrences of each digit
        for (int num : arr) {
            count[(num / exp) % 10]++;
        }
        
        // Change count[i] to actual position
        for (int i = 1; i < 10; i++) {
            count[i] += count[i - 1];
        }
        
        // Build output array
        for (int i = arr.length - 1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit] - 1] = arr[i];
            count[digit]--;
        }
        
        // Copy output array to original array
        System.arraycopy(output, 0, arr, 0, arr.length);
    }
    
    public static void main(String[] args) {
        int[] arr = {170, 45, 75, 90, 2, 802, 24, 66};
        System.out.println("Original: " + Arrays.toString(arr));
        
        radixSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(d Ã— (n + k)) where d is digits, k is base
   Space Complexity: O(n + k)
   Stable: Yes
   In-place: No
   Best for: Fixed-width integer keys */</code></pre>

                <h3>9. Bucket Sort</h3>
                <p><strong>Algorithm:</strong> Distribute elements into buckets, sort buckets individually, concatenate</p>
                <pre><code>public class BucketSort {
    public static void bucketSort(float[] arr) {
        if (arr.length <= 1) return;
        
        int n = arr.length;
        
        // Create buckets
        List&lt;List&lt;Float&gt;&gt; buckets = new ArrayList&lt;&gt;();
        for (int i = 0; i < n; i++) {
            buckets.add(new ArrayList&lt;&gt;());
        }
        
        // Distribute elements into buckets
        for (float num : arr) {
            int bucketIndex = (int) (n * num);
            if (bucketIndex == n) bucketIndex = n - 1; // Handle edge case
            buckets.get(bucketIndex).add(num);
        }
        
        // Sort individual buckets
        for (List&lt;Float&gt; bucket : buckets) {
            Collections.sort(bucket);
        }
        
        // Concatenate buckets
        int index = 0;
        for (List&lt;Float&gt; bucket : buckets) {
            for (float num : bucket) {
                arr[index++] = num;
            }
        }
    }
    
    // Integer version with custom range
    public static void bucketSortInt(int[] arr, int maxValue) {
        if (arr.length <= 1) return;
        
        int bucketCount = (int) Math.sqrt(arr.length);
        List&lt;List&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;();
        
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList&lt;&gt;());
        }
        
        // Distribute elements
        for (int num : arr) {
            int bucketIndex = (num * bucketCount) / (maxValue + 1);
            buckets.get(bucketIndex).add(num);
        }
        
        // Sort and concatenate
        int index = 0;
        for (List&lt;Integer&gt; bucket : buckets) {
            Collections.sort(bucket);
            for (int num : bucket) {
                arr[index++] = num;
            }
        }
    }
    
    public static void main(String[] args) {
        float[] arr = {0.897f, 0.565f, 0.656f, 0.1234f, 0.665f, 0.3434f};
        System.out.println("Original: " + Arrays.toString(arr));
        
        bucketSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n + k) average, O(nÂ²) worst
   Space Complexity: O(n + k)
   Stable: Yes
   In-place: No
   Best for: Uniformly distributed data */</code></pre>
            </div>

            <div class="topic" id="specialized-sorts">
                <h2>Specialized Sorting Algorithms</h2>

                <h3>10. Shell Sort</h3>
                <p><strong>Algorithm:</strong> Generalization of insertion sort with gap sequence</p>
                <pre><code>public class ShellSort {
    public static void shellSort(int[] arr) {
        int n = arr.length;
        
        // Start with large gap and reduce
        for (int gap = n / 2; gap > 0; gap /= 2) {
            // Perform gapped insertion sort
            for (int i = gap; i < n; i++) {
                int temp = arr[i];
                int j;
                
                // Shift elements until correct position is found
                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                    arr[j] = arr[j - gap];
                }
                
                arr[j] = temp;
            }
        }
    }
    
    // Using Knuth's gap sequence: 3^k - 1
    public static void shellSortKnuth(int[] arr) {
        int n = arr.length;
        int gap = 1;
        
        // Calculate starting gap
        while (gap < n / 3) {
            gap = 3 * gap + 1;
        }
        
        while (gap >= 1) {
            for (int i = gap; i < n; i++) {
                int temp = arr[i];
                int j = i;
                
                while (j >= gap && arr[j - gap] > temp) {
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                
                arr[j] = temp;
            }
            gap /= 3;
        }
    }
    
    public static void main(String[] args) {
        int[] arr = {12, 34, 54, 2, 3};
        System.out.println("Original: " + Arrays.toString(arr));
        
        shellSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n log n) to O(nÂ²) depending on gap sequence
   Space Complexity: O(1)
   Stable: No
   In-place: Yes */</code></pre>

                <h3>11. Tim Sort (Hybrid)</h3>
                <p><strong>Algorithm:</strong> Hybrid of merge sort and insertion sort, used in Java's Arrays.sort()</p>
                <pre><code>public class TimSort {
    private static final int MIN_MERGE = 32;
    
    public static void timSort(int[] arr) {
        int n = arr.length;
        
        // Sort individual subarrays of size MIN_MERGE using insertion sort
        for (int i = 0; i < n; i += MIN_MERGE) {
            insertionSort(arr, i, Math.min(i + MIN_MERGE - 1, n - 1));
        }
        
        // Start merging from size MIN_MERGE
        for (int size = MIN_MERGE; size < n; size = 2 * size) {
            for (int start = 0; start < n; start += 2 * size) {
                int mid = start + size - 1;
                int end = Math.min(start + 2 * size - 1, n - 1);
                
                if (mid < end) {
                    merge(arr, start, mid, end);
                }
            }
        }
    }
    
    private static void insertionSort(int[] arr, int left, int right) {
        for (int i = left + 1; i <= right; i++) {
            int key = arr[i];
            int j = i - 1;
            
            while (j >= left && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            
            arr[j + 1] = key;
        }
    }
    
    private static void merge(int[] arr, int left, int mid, int right) {
        int[] leftArr = new int[mid - left + 1];
        int[] rightArr = new int[right - mid];
        
        System.arraycopy(arr, left, leftArr, 0, leftArr.length);
        System.arraycopy(arr, mid + 1, rightArr, 0, rightArr.length);
        
        int i = 0, j = 0, k = left;
        
        while (i < leftArr.length && j < rightArr.length) {
            if (leftArr[i] <= rightArr[j]) {
                arr[k++] = leftArr[i++];
            } else {
                arr[k++] = rightArr[j++];
            }
        }
        
        while (i < leftArr.length) arr[k++] = leftArr[i++];
        while (j < rightArr.length) arr[k++] = rightArr[j++];
    }
    
    public static void main(String[] args) {
        int[] arr = {5, 21, 7, 23, 19, 10, 16, 2, 12, 14};
        System.out.println("Original: " + Arrays.toString(arr));
        
        timSort(arr);
        System.out.println("Sorted: " + Arrays.toString(arr));
    }
}

/* Time Complexity: O(n log n) worst case, O(n) best case
   Space Complexity: O(n)
   Stable: Yes
   In-place: No
   Used in: Java Arrays.sort() for objects */</code></pre>
            </div>

            <div class="topic" id="comparison-analysis">
                <h2>Sorting Algorithm Comparison</h2>

                <h3>Performance Comparison Table</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Best Case</th>
                            <th>Average Case</th>
                            <th>Worst Case</th>
                            <th>Space</th>
                            <th>Stable</th>
                            <th>In-Place</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Bubble Sort</strong></td>
                            <td>O(n)</td>
                            <td>O(nÂ²)</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Selection Sort</strong></td>
                            <td>O(nÂ²)</td>
                            <td>O(nÂ²)</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                            <td>No</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Insertion Sort</strong></td>
                            <td>O(n)</td>
                            <td>O(nÂ²)</td>
                            <td>O(nÂ²)</td>
                            <td>O(1)</td>
                            <td>Yes</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Merge Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n)</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Quick Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(nÂ²)</td>
                            <td>O(log n)</td>
                            <td>No</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Heap Sort</strong></td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(n log n)</td>
                            <td>O(1)</td>
                            <td>No</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Counting Sort</strong></td>
                            <td>O(n + k)</td>
                            <td>O(n + k)</td>
                            <td>O(n + k)</td>
                            <td>O(k)</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td><strong>Radix Sort</strong></td>
                            <td>O(d(n + k))</td>
                            <td>O(d(n + k))</td>
                            <td>O(d(n + k))</td>
                            <td>O(n + k)</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use Which Algorithm?</h3>
                <ul>
                    <li><strong>Small Arrays (n < 50):</strong> Insertion Sort - Simple and efficient for small datasets</li>
                    <li><strong>Nearly Sorted Data:</strong> Insertion Sort or Bubble Sort - O(n) best case</li>
                    <li><strong>Memory Constrained:</strong> Heap Sort or Shell Sort - O(1) space complexity</li>
                    <li><strong>Stability Required:</strong> Merge Sort or Tim Sort - Maintains relative order</li>
                    <li><strong>Average Performance:</strong> Quick Sort - Fastest average case for random data</li>
                    <li><strong>Guaranteed O(n log n):</strong> Merge Sort or Heap Sort - No worst-case degradation</li>
                    <li><strong>Integer Keys, Small Range:</strong> Counting Sort - Linear time complexity</li>
                    <li><strong>String/Multi-digit Numbers:</strong> Radix Sort - Efficient for fixed-width keys</li>
                </ul>

                <h3>Sorting Algorithm Benchmark</h3>
                <pre><code>public class SortingBenchmark {
    public static void benchmarkSorts(int[] arr) {
        int[] original = arr.clone();
        
        // Test different sorting algorithms
        long startTime, endTime;
        
        // Quick Sort
        arr = original.clone();
        startTime = System.nanoTime();
        QuickSort.quickSort(arr);
        endTime = System.nanoTime();
        System.out.println("Quick Sort: " + (endTime - startTime) / 1000000.0 + " ms");
        
        // Merge Sort
        arr = original.clone();
        startTime = System.nanoTime();
        MergeSort.mergeSort(arr);
        endTime = System.nanoTime();
        System.out.println("Merge Sort: " + (endTime - startTime) / 1000000.0 + " ms");
        
        // Heap Sort
        arr = original.clone();
        startTime = System.nanoTime();
        HeapSort.heapSort(arr);
        endTime = System.nanoTime();
        System.out.println("Heap Sort: " + (endTime - startTime) / 1000000.0 + " ms");
        
        // Java's Built-in Sort (Tim Sort)
        arr = original.clone();
        startTime = System.nanoTime();
        Arrays.sort(arr);
        endTime = System.nanoTime();
        System.out.println("Arrays.sort(): " + (endTime - startTime) / 1000000.0 + " ms");
    }
    
    public static void main(String[] args) {
        Random rand = new Random();
        int[] arr = new int[100000];
        
        for (int i = 0; i < arr.length; i++) {
            arr[i] = rand.nextInt(10000);
        }
        
        System.out.println("Benchmarking sorting algorithms with " + arr.length + " elements:");
        benchmarkSorts(arr);
    }
}</code></pre>
            </div>

            <div class="topic" id="practical-applications">
                <h2>Practical Applications</h2>

                <h3>Custom Comparator Sorting</h3>
                <pre><code>public class CustomSorting {
    static class Student {
        String name;
        int age;
        double gpa;
        
        Student(String name, int age, double gpa) {
            this.name = name;
            this.age = age;
            this.gpa = gpa;
        }
        
        @Override
        public String toString() {
            return name + "(" + age + ", " + gpa + ")";
        }
    }
    
    public static void main(String[] args) {
        Student[] students = {
            new Student("Alice", 20, 3.8),
            new Student("Bob", 19, 3.9),
            new Student("Charlie", 21, 3.7),
            new Student("Diana", 20, 3.9)
        };
        
        System.out.println("Original: " + Arrays.toString(students));
        
        // Sort by GPA (descending), then by age (ascending)
        Arrays.sort(students, (s1, s2) -> {
            int gpaCompare = Double.compare(s2.gpa, s1.gpa);
            if (gpaCompare != 0) return gpaCompare;
            return Integer.compare(s1.age, s2.age);
        });
        
        System.out.println("Sorted by GPA desc, Age asc: " + Arrays.toString(students));
        
        // Sort by name length, then alphabetically
        Arrays.sort(students, Comparator
            .comparing((Student s) -> s.name.length())
            .thenComparing(s -> s.name));
        
        System.out.println("Sorted by name length, then alphabetically: " + Arrays.toString(students));
    }
}</code></pre>

                <h3>ðŸŽ¯ Interview Questions</h3>
                <ol>
                    <li><strong>Sort Colors (Dutch Flag):</strong> Sort array of 0s, 1s, 2s in one pass</li>
                    <li><strong>Merge Intervals:</strong> Sort intervals by start time, then merge overlapping</li>
                    <li><strong>Largest Number:</strong> Sort numbers to form largest possible number</li>
                    <li><strong>Meeting Rooms:</strong> Sort meetings by start time to check conflicts</li>
                    <li><strong>Kth Largest Element:</strong> Use Quick Select or Min Heap</li>
                    <li><strong>Sort List:</strong> Sort linked list using merge sort</li>
                    <li><strong>Custom Sort String:</strong> Sort string based on custom order</li>
                    <li><strong>Pancake Sorting:</strong> Sort using only flip operations</li>
                    <li><strong>Wiggle Sort:</strong> Rearrange array in wave pattern</li>
                    <li><strong>Sort Characters by Frequency:</strong> Count and sort by frequency</li>
                </ol>

                <h3>Key Takeaways</h3>
                <ul>
                    <li><strong>Choose Wisely:</strong> Algorithm choice depends on data characteristics and constraints</li>
                    <li><strong>Hybrid Approaches:</strong> Real-world implementations often combine multiple algorithms</li>
                    <li><strong>Stability Matters:</strong> Important when sorting objects with multiple fields</li>
                    <li><strong>Space vs Time:</strong> Consider memory constraints in algorithm selection</li>
                    <li><strong>Adaptive Algorithms:</strong> Some algorithms perform better on partially sorted data</li>
                </ul>
            </div>
            </div>
        </div>
    </div>
    <script src="../footer.js"></script>
</body>
</html>